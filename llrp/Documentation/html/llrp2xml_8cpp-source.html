<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>LTKCPP-- LLRP Toolkit C Plus Plus Library: llrp2xml.cpp Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.9.1 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="namespacemembers.html">Namespace&nbsp;Members</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a></div>
<div class="nav">
<a class="el" href="dir_000000.html">Tests</a></div>
<h1>llrp2xml.cpp</h1><a href="llrp2xml_8cpp.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment">00001 
00002 <span class="comment">/*</span>
00003 <span class="comment"> ***************************************************************************</span>
00004 <span class="comment"> *  Copyright 2007,2008 Impinj, Inc.</span>
00005 <span class="comment"> *</span>
00006 <span class="comment"> *  Licensed under the Apache License, Version 2.0 (the "License");</span>
00007 <span class="comment"> *  you may not use this file except in compliance with the License.</span>
00008 <span class="comment"> *  You may obtain a copy of the License at</span>
00009 <span class="comment"> *</span>
00010 <span class="comment"> *      http://www.apache.org/licenses/LICENSE-2.0</span>
00011 <span class="comment"> *</span>
00012 <span class="comment"> *  Unless required by applicable law or agreed to in writing, software</span>
00013 <span class="comment"> *  distributed under the License is distributed on an "AS IS" BASIS,</span>
00014 <span class="comment"> *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
00015 <span class="comment"> *  See the License for the specific language governing permissions and</span>
00016 <span class="comment"> *  limitations under the License.</span>
00017 <span class="comment"> *</span>
00018 <span class="comment"> ***************************************************************************</span>
00019 <span class="comment"> */</span>
00020 
00021 
00056 <span class="preprocessor">#include &lt;stdio.h&gt;</span>
00057 
00058 <span class="preprocessor">#include "<a class="code" href="ltkcpp_8h.html">ltkcpp.h</a>"</span>
00059 
00060 
00061 <span class="keyword">using</span> <span class="keyword">namespace </span>LLRP;
00062 
00063 
00064 <span class="comment">/* Buffer sizes */</span>
00065 <span class="preprocessor">#define FRAME_BUF_SIZE          (4u*1024u*1024u)</span>
00066 <span class="preprocessor"></span><span class="preprocessor">#define XML_TEXT_BUF_SIZE       (10u * FRAME_BUF_SIZE)</span>
00067 <span class="preprocessor"></span>
00068 
00069 <span class="comment">/* forward declaration */</span>
00070 <span class="keywordtype">void</span>
00071 <a class="code" href="llrp2xml_8cpp.html#a7">dump</a> (
00072   <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *               pBuffer,
00073   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>                  nBuffer);
00074 
00075 
00076 <span class="comment">/*</span>
00077 <span class="comment"> * XML header and footer enclosing the sequence of messages.</span>
00078 <span class="comment"> */</span>
00079 <span class="keyword">static</span> <span class="keywordtype">char</span>
00080 g_aPacketSequenceHeader[] =
00081 {
00082   <span class="stringliteral">"&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\n"</span>
00083   <span class="stringliteral">"\n"</span>
00084   <span class="stringliteral">"&lt;ps:packetSequence\n"</span>
00085   <span class="stringliteral">"  xmlns='http://www.llrp.org/ltk/schema/core/encoding/xml/1.0'\n"</span>
00086   <span class="stringliteral">"  xmlns:xsi='http://www.w3.org/2001/XMLSchema-instance'\n"</span>
00087   <span class="stringliteral">"  xmlns:ps='http://www.llrp.org/ltk/schema/testing/encoding/xml/0.6'\n"</span>
00088   <span class="stringliteral">"  xsi:schemaLocation='http://www.llrp.org/ltk/schema/core/encoding/xml/1.0\n"</span>
00089   <span class="stringliteral">"                      http://www.llrp.org/ltk/schema/core/encoding/xml/1.0/llrp.xsd\n'&gt;"</span>
00090                         
00091 };
00092 
00093 <span class="keyword">static</span> <span class="keywordtype">char</span>
00094 g_aPacketSequenceFooter[] =
00095 {
00096   <span class="stringliteral">"\n&lt;/ps:packetSequence&gt;\n"</span>
00097 };
00098 
00099 <span class="comment">/* This is the message format that is agreed upon when messages fail</span>
00100 <span class="comment">** to decode. It's somewhat arbitrary, but allows us to do easy</span>
00101 <span class="comment">** comparisons */</span>
00102 <span class="keyword">static</span> <span class="keywordtype">char</span> * g_errMsgStr = <span class="stringliteral">"&lt;ERROR_MESSAGE MessageID=\"0\" Version=\"0\"&gt;\n"</span> \
00103                             <span class="stringliteral">"  &lt;LLRPStatus&gt;\n"</span> \
00104                             <span class="stringliteral">"    &lt;StatusCode&gt;M_Success&lt;/StatusCode&gt;\n"</span> \
00105                             <span class="stringliteral">"    &lt;ErrorDescription&gt;&lt;/ErrorDescription&gt;\n"</span> \
00106                             <span class="stringliteral">"  &lt;/LLRPStatus&gt;\n"</span> \
00107                             <span class="stringliteral">"&lt;/ERROR_MESSAGE&gt;\n"</span>;
00108 
00109 <span class="comment">/*</span>
00110 <span class="comment"> * These used to be allocated as local (auto) variables.</span>
00111 <span class="comment"> * But they are really, really big and Linux has a 10mb</span>
00112 <span class="comment"> * stack limit. So they had to be moved here.</span>
00113 <span class="comment"> */</span>
00114 <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>                   aInBuffer[FRAME_BUF_SIZE];
00115 <span class="keywordtype">char</span>                            aXMLTextBuf[XML_TEXT_BUF_SIZE];
00116 
00132 <span class="keywordtype">int</span>
<a name="l00133"></a><a class="code" href="llrp2xml_8cpp.html#a8">00133</a> <a class="code" href="example1_8cpp.html#a0">main</a> (<span class="keywordtype">int</span> ac, <span class="keywordtype">char</span> *av[])
00134 {
00135     <a class="code" href="classLLRP_1_1CTypeRegistry.html">CTypeRegistry</a> *             pTypeRegistry;
00136     FILE *                      infp;
00137 
00138     <span class="comment">/*</span>
00139 <span class="comment">     * Check arg count</span>
00140 <span class="comment">     */</span>
00141     <span class="keywordflow">if</span>(ac != 2)
00142     {
00143         fprintf(stderr, <span class="stringliteral">"ERROR: Bad usage\nusage: %s INPUTFILE\n"</span>, av[0]);
00144         exit(1);
00145     }
00146 
00147     <span class="comment">/*</span>
00148 <span class="comment">     * Open input file</span>
00149 <span class="comment">     */</span>
00150 <span class="preprocessor">#ifdef WIN32</span>
00151 <span class="preprocessor"></span>    infp = fopen(av[1], <span class="stringliteral">"rb"</span>);
00152 <span class="preprocessor">#else</span>
00153 <span class="preprocessor"></span>    infp = fopen(av[1], <span class="stringliteral">"r"</span>);
00154 <span class="preprocessor">#endif</span>
00155 <span class="preprocessor"></span>    <span class="keywordflow">if</span>(NULL == infp)
00156     {
00157         perror(av[1]);
00158         exit(2);
00159     }
00160 
00161     printf(<span class="stringliteral">"%s\n"</span>, g_aPacketSequenceHeader);
00162 
00163     <span class="comment">/*</span>
00164 <span class="comment">     * Construct the type registry. This is needed for decode.</span>
00165 <span class="comment">     */</span>
00166     pTypeRegistry = getTheTypeRegistry();
00167 
00168     <span class="comment">/*</span>
00169 <span class="comment">     * Loop iterates for each input frame</span>
00170 <span class="comment">     */</span>
00171     <span class="keywordflow">for</span>(;;)
00172     {
00173 <span class="comment">//        unsigned char           aInBuffer[FRAME_BUF_SIZE];</span>
00174         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>            nInBuffer = <span class="keyword">sizeof</span> aInBuffer;
00175         <span class="keywordtype">bool</span>                    bEOF;
00176 
00177         <span class="comment">/*</span>
00178 <span class="comment">         * Zero fill the buffer to make things easier</span>
00179 <span class="comment">         * for printing the buffer on the debugger.</span>
00180 <span class="comment">         */</span>
00181         memset(aInBuffer, 0, nInBuffer);
00182 
00183         <span class="comment">/*</span>
00184 <span class="comment">         * Set status variables before entering the frame read loop.</span>
00185 <span class="comment">         */</span>
00186         nInBuffer = 0;
00187         bEOF = FALSE;
00188 
00189         <span class="comment">/*</span>
00190 <span class="comment">         * Loop iterates for each individual file read.</span>
00191 <span class="comment">         * The size of each read is guided by LLRP_FrameExtract.</span>
00192 <span class="comment">         */</span>
00193         <span class="keywordflow">for</span>(;;)
00194         {
00195             <span class="comment">/*</span>
00196 <span class="comment">             * Ask LLRP_FrameExtract() how we are doing</span>
00197 <span class="comment">             * on building a frame. It'll tell us the</span>
00198 <span class="comment">             * status and possibly the number of bytes</span>
00199 <span class="comment">             * still needed.</span>
00200 <span class="comment">             */</span>
00201             CFrameExtract       MyFrameExtract(aInBuffer, nInBuffer);
00202 
00203             <span class="comment">/*</span>
00204 <span class="comment">             * If there is a framing error we have to declare</span>
00205 <span class="comment">             * defeat. There is no way to realign the input</span>
00206 <span class="comment">             * stream to a frame boundary. This could mean</span>
00207 <span class="comment">             * the input file is bad or that the extract</span>
00208 <span class="comment">             * function is broken.</span>
00209 <span class="comment">             */</span>
00210             <span class="keywordflow">if</span>(CFrameExtract::FRAME_ERROR == MyFrameExtract.m_eStatus)
00211             {
00212                 fprintf(stderr, <span class="stringliteral">"ERROR: Frame error, bail!\n"</span>);
00213                 bEOF = TRUE;
00214                 <span class="keywordflow">break</span>;
00215             }
00216 
00217             <span class="comment">/*</span>
00218 <span class="comment">             * If we need more bytes read them in. This may</span>
00219 <span class="comment">             * not request the entire frame. It might be</span>
00220 <span class="comment">             * only asking form enough of the frame so that</span>
00221 <span class="comment">             * LLRP_FrameExtract() can determine the actual</span>
00222 <span class="comment">             * size of the frame.</span>
00223 <span class="comment">             */</span>
00224             <span class="keywordflow">if</span>(CFrameExtract::NEED_MORE == MyFrameExtract.m_eStatus)
00225             {
00226                 <span class="keywordtype">int</span>             rc;
00227 
00228                 <span class="keywordflow">if</span> (<span class="keyword">sizeof</span> aInBuffer &lt;
00229                         nInBuffer + MyFrameExtract.m_nBytesNeeded)
00230                 {
00231                     fprintf(stderr,<span class="stringliteral">"Input frame too big\n"</span>);
00232                     exit(3);
00233                 }
00234 
00235                 rc = (int)fread(&amp;aInBuffer[nInBuffer], 1u,
00236                             MyFrameExtract.m_nBytesNeeded, infp);
00237                 <span class="keywordflow">if</span>(rc &lt;= 0)
00238                 {
00239                     <span class="keywordflow">if</span>(ferror(infp))
00240                     {
00241                         fprintf(stderr,<span class="stringliteral">"ERROR: bad file read status\n"</span>);
00242                     }
00243                     bEOF = TRUE;
00244                     <span class="keywordflow">break</span>;
00245                 }
00246                 nInBuffer += rc;
00247                 <span class="keywordflow">continue</span>;
00248             }
00249 
00250             <span class="comment">/*</span>
00251 <span class="comment">             * The only remaining extract status we recognize</span>
00252 <span class="comment">             * is READY. If it's anything else, give up.</span>
00253 <span class="comment">             * This probably means that the frame extract</span>
00254 <span class="comment">             * function is broken.</span>
00255 <span class="comment">             */</span>
00256             <span class="keywordflow">if</span>(CFrameExtract::READY != MyFrameExtract.m_eStatus)
00257             {
00258                 fprintf(stderr, <span class="stringliteral">"ERROR: Unrecognized extract status, bail!\n"</span>);
00259                 bEOF = TRUE;
00260                 <span class="keywordflow">break</span>;
00261             }
00262 
00263             <span class="keywordflow">break</span>;
00264         }
00265 
00266         <span class="comment">/*</span>
00267 <span class="comment">         * Did the inner loop detect and end-of-file or other</span>
00268 <span class="comment">         * reason to stop?</span>
00269 <span class="comment">         */</span>
00270         <span class="keywordflow">if</span>(bEOF)
00271         {
00272             <span class="keywordflow">if</span>(0 &lt; nInBuffer)
00273             {
00274                 fprintf(stderr, <span class="stringliteral">"ERROR: EOF w/ %u bytes in buffer\n"</span>, nInBuffer);
00275             }
00276             <span class="keywordflow">break</span>;
00277         }
00278 
00279         <span class="comment">/* Put a blank line between messages */</span>
00280         printf (<span class="stringliteral">"\n"</span>);
00281 
00282         <span class="comment">/*</span>
00283 <span class="comment">         * Construct a frame decoder. It references the</span>
00284 <span class="comment">         * type registry and the input buffer.</span>
00285 <span class="comment">         */</span>
00286         CFrameDecoder           MyFrameDecoder(pTypeRegistry,
00287                                         aInBuffer, nInBuffer);
00288 
00289         <span class="comment">/*</span>
00290 <span class="comment">         * Now ask the frame decoder to actually decode</span>
00291 <span class="comment">         * the message. It returns NULL for an error.</span>
00292 <span class="comment">         */</span>
00293         <a class="code" href="classLLRP_1_1CMessage.html">CMessage</a> *              pMessage;
00294 
00295         pMessage = MyFrameDecoder.decodeMessage();
00296 
00297         <span class="comment">/*</span>
00298 <span class="comment">         * Did the decode fail?</span>
00299 <span class="comment">         */</span>
00300         <span class="keywordflow">if</span>(NULL == pMessage)
00301         {
00302             <span class="keyword">const</span> <a class="code" href="classLLRP_1_1CErrorDetails.html">CErrorDetails</a> *pError;
00303 
00304             pError = &amp;MyFrameDecoder.m_ErrorDetails;
00305 
00306             fprintf(stderr, <span class="stringliteral">"ERROR: Decoder error, result=%d\n"</span>,
00307                 pError-&gt;<a class="code" href="classLLRP_1_1CErrorDetails.html#o0">m_eResultCode</a>);
00308             <span class="keywordflow">if</span>(NULL != pError-&gt;<a class="code" href="classLLRP_1_1CErrorDetails.html#o2">m_pRefType</a>)
00309             {
00310                 fprintf(stderr, <span class="stringliteral">"ERROR ... refType=%s\n"</span>,
00311                     pError-&gt;<a class="code" href="classLLRP_1_1CErrorDetails.html#o2">m_pRefType</a>-&gt;<a class="code" href="classLLRP_1_1CTypeDescriptor.html#o1">m_pName</a>);
00312             }
00313             <span class="keywordflow">if</span>(NULL != pError-&gt;<a class="code" href="classLLRP_1_1CErrorDetails.html#o3">m_pRefField</a>)
00314             {
00315                 fprintf(stderr, <span class="stringliteral">"ERROR ... refField=%s\n"</span>,
00316                     pError-&gt;<a class="code" href="classLLRP_1_1CErrorDetails.html#o3">m_pRefField</a>-&gt;<a class="code" href="classLLRP_1_1CFieldDescriptor.html#o2">m_pName</a>);
00317             }
00318 
00319         printf(<span class="stringliteral">"%s\n"</span>, g_errMsgStr);
00320 
00321             <span class="keywordflow">continue</span>;
00322         }
00323 
00324         <span class="comment">/*</span>
00325 <span class="comment">         * pMessage points to the root of an object</span>
00326 <span class="comment">         * tree representing the LLRP message.</span>
00327 <span class="comment">         */</span>
00328 
00329         <span class="comment">/*</span>
00330 <span class="comment">         * Print as XML text the LLRP message to stdout.</span>
00331 <span class="comment">         */</span>
00332         {
00333             CXMLTextEncoder     MyXMLEncoder(aXMLTextBuf, <span class="keyword">sizeof</span> aXMLTextBuf);
00334 
00335             MyXMLEncoder.encodeElement(pMessage);
00336             <span class="keywordflow">if</span>(!MyXMLEncoder.m_bOverflow)
00337             {
00338                 printf(<span class="stringliteral">"%s"</span>, aXMLTextBuf);
00339             }
00340             <span class="keywordflow">else</span>
00341             {
00342                 fprintf(stderr, <span class="stringliteral">"&lt;!-- Buffer overflow --&gt;\n"</span>);
00343             printf(<span class="stringliteral">"%s\n"</span>, g_errMsgStr);
00344             }
00345         }
00346     
00347         <span class="keyword">delete</span> pMessage;
00348     }
00349 
00350     printf(<span class="stringliteral">"%s\n"</span>, g_aPacketSequenceFooter);
00351 
00352     <span class="comment">/*</span>
00353 <span class="comment">     * Done with the type registry.</span>
00354 <span class="comment">     */</span>
00355     <span class="keyword">delete</span> pTypeRegistry;
00356 
00357     <span class="comment">/*</span>
00358 <span class="comment">     * Done with the input file.</span>
00359 <span class="comment">     */</span>
00360     fclose(infp);
00361 
00362     <span class="comment">/*</span>
00363 <span class="comment">     * When we get here everything that was allocated</span>
00364 <span class="comment">     * should now be deallocated.</span>
00365 <span class="comment">     */</span>
00366     <span class="keywordflow">return</span> 0;
00367 }
00368 
00387 <span class="keywordtype">void</span>
<a name="l00388"></a><a class="code" href="llrp2xml_8cpp.html#a7">00388</a> <a class="code" href="llrp2xml_8cpp.html#a7">dump</a> (
00389   <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *               pBuffer,
00390   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>                  nBuffer)
00391 {
00392     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>                chk = 0;
00393     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>                i;
00394 
00395     <span class="keywordflow">for</span>(i = 0; i &lt; nBuffer; i++)
00396     {
00397         <span class="keywordflow">if</span>(i%4 == 0)
00398         {
00399             printf(<span class="stringliteral">" "</span>);
00400         }
00401         printf(<span class="stringliteral">" %02X"</span>, pBuffer[i]);
00402         chk += pBuffer[i];
00403 
00404         <span class="keywordflow">if</span>(i%16 == 15)
00405         {
00406             printf(<span class="stringliteral">"  sum=%03X\n"</span>, chk);
00407             chk = 0;
00408         }
00409     }
00410     printf(<span class="stringliteral">"\n"</span>);
00411 }
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Wed Feb 24 09:16:20 2010 for LTKCPP-- LLRP Toolkit C Plus Plus Library by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.3.9.1 </small></address>
</body>
</html>
