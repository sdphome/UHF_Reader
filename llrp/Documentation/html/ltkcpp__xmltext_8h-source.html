<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>LTKCPP-- LLRP Toolkit C Plus Plus Library: ltkcpp_xmltext.h Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.9.1 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="namespacemembers.html">Namespace&nbsp;Members</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a></div>
<div class="nav">
<a class="el" href="dir_000002.html">Library</a></div>
<h1>ltkcpp_xmltext.h</h1><a href="ltkcpp__xmltext_8h.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment">00001 
00002 <span class="comment">/*</span>
00003 <span class="comment"> ***************************************************************************</span>
00004 <span class="comment"> *  Copyright 2007,2008 Impinj, Inc.</span>
00005 <span class="comment"> *</span>
00006 <span class="comment"> *  Licensed under the Apache License, Version 2.0 (the "License");</span>
00007 <span class="comment"> *  you may not use this file except in compliance with the License.</span>
00008 <span class="comment"> *  You may obtain a copy of the License at</span>
00009 <span class="comment"> *</span>
00010 <span class="comment"> *      http://www.apache.org/licenses/LICENSE-2.0</span>
00011 <span class="comment"> *</span>
00012 <span class="comment"> *  Unless required by applicable law or agreed to in writing, software</span>
00013 <span class="comment"> *  distributed under the License is distributed on an "AS IS" BASIS,</span>
00014 <span class="comment"> *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
00015 <span class="comment"> *  See the License for the specific language governing permissions and</span>
00016 <span class="comment"> *  limitations under the License.</span>
00017 <span class="comment"> *</span>
00018 <span class="comment"> ***************************************************************************</span>
00019 <span class="comment"> */</span>
00020 
00021 
00034 <span class="comment">/* forward declare these so we don't need to include the</span>
00035 <span class="comment">** whole XML header files here. Make sure they are out</span>
00036 <span class="comment">** of the namespace and extern C since they need to </span>
00037 <span class="comment">** match the C types later */</span>
00038 <span class="keyword">extern</span> <span class="stringliteral">"C"</span>
00039 {
00040     <span class="keyword">struct </span>_xmlNode;
00041     <span class="keyword">struct </span>_xmlDoc;
00042 }
00043 
00044 <span class="keyword">namespace </span>LLRP
00045 {
00046 <span class="keyword">class </span>CXMLTextEncoder;
00047 <span class="keyword">class </span>CXMLTextEncoderStream;
00048 <span class="keyword">class </span>CXMLTextDecoder;
00049 <span class="keyword">class </span>CXMLTextDecoderStream;
00050 
00051 <span class="keyword">class </span>CXMLTextEncoder : <span class="keyword">public</span> CEncoder
00052 {
00053     <span class="keyword">friend</span> <span class="keyword">class </span>CXMLTextEncoderStream;
00054 
00055   <span class="keyword">private</span>:
00056     <span class="keywordtype">char</span> *                      m_pBuffer;
00057     <span class="keywordtype">int</span>                         m_nBuffer;
00058     <span class="keywordtype">int</span>                         m_iNext;
00059 
00060   <span class="keyword">public</span>:
00061     <span class="keywordtype">int</span>                         m_bOverflow;
00062 
00063   <span class="keyword">public</span>:
00064     CXMLTextEncoder (
00065       <span class="keywordtype">char</span> *                    pBuffer,
00066       <span class="keywordtype">int</span>                       nBuffer);
00067 
00068     ~CXMLTextEncoder (<span class="keywordtype">void</span>);
00069 
00070     <span class="keywordtype">void</span>
00071     encodeElement (
00072       <span class="keyword">const</span> CElement *          pElement);
00073 };
00074 
00075 <span class="keyword">class </span>CXMLTextDecoder : <span class="keyword">public</span> CDecoder
00076 {
00077     <span class="keyword">friend</span> <span class="keyword">class </span>CXMLTextDecoderStream;
00078 
00079   <span class="keyword">private</span>:
00080     <span class="keyword">struct </span>_xmlDoc *            m_pDoc;
00081     <span class="keyword">struct </span>_xmlNode *           m_pxmlNodeTree;
00082 
00083   <span class="keyword">public</span>:
00084     CXMLTextDecoder (
00085   <span class="keyword">const</span> CTypeRegistry *         pTypeRegistry,
00086       <span class="keywordtype">char</span> *                    pBuffer,
00087       <span class="keywordtype">int</span>                       nBuffer);
00088 
00089     CXMLTextDecoder (
00090   <span class="keyword">const</span> CTypeRegistry *         pTypeRegistry,
00091       <span class="keyword">struct</span> _xmlNode *         pNodeTree);
00092 
00093 
00094     CXMLTextDecoder (
00095   <span class="keyword">const</span> CTypeRegistry *         pTypeRegistry,
00096       <span class="keywordtype">char</span> *                    fname);
00097 
00098     ~CXMLTextDecoder (<span class="keywordtype">void</span>);
00099 
00100     CMessage *
00101     decodeMessage (<span class="keywordtype">void</span>);
00102 
00103 };
00104 
00105 <span class="keyword">class </span>CXMLTextEncoderStream : <span class="keyword">public</span> CEncoderStream
00106 {
00107     <span class="keyword">friend</span> <span class="keyword">class </span>CXMLTextEncoder;
00108 
00109   <span class="keyword">public</span>:
00110     <span class="keywordtype">void</span>
00111     putRequiredSubParameter (
00112       <span class="keyword">const</span> CParameter *        pParameter,
00113       <span class="keyword">const</span> CTypeDescriptor *   pRefType);
00114 
00115     <span class="keywordtype">void</span>
00116     putOptionalSubParameter (
00117       <span class="keyword">const</span> CParameter *        pParameter,
00118       <span class="keyword">const</span> CTypeDescriptor *   pRefType);
00119 
00120     <span class="keywordtype">void</span>
00121     putRequiredSubParameterList (
00122       <span class="keyword">const</span> tListOfParameters * pParameterList,
00123       <span class="keyword">const</span> CTypeDescriptor *   pRefType);
00124 
00125     <span class="keywordtype">void</span>
00126     putOptionalSubParameterList (
00127       <span class="keyword">const</span> tListOfParameters * pParameterList,
00128       <span class="keyword">const</span> CTypeDescriptor *   pRefType);
00129 
00130     <span class="comment">/*</span>
00131 <span class="comment">     * 8-bit types</span>
00132 <span class="comment">     */</span>
00133 
00134     <span class="keywordtype">void</span>
00135     put_u8 (
00136       llrp_u8_t                 Value,
00137       <span class="keyword">const</span> CFieldDescriptor *  pFieldDescriptor);
00138 
00139     <span class="keywordtype">void</span>
00140     put_s8 (
00141       llrp_s8_t                 Value,
00142       <span class="keyword">const</span> CFieldDescriptor *  pFieldDescriptor);
00143 
00144     <span class="keywordtype">void</span>
00145     put_u8v (
00146       llrp_u8v_t                Value,
00147       <span class="keyword">const</span> CFieldDescriptor *  pFieldDescriptor);
00148 
00149     <span class="keywordtype">void</span>
00150     put_s8v (
00151       llrp_s8v_t                Value,
00152       <span class="keyword">const</span> CFieldDescriptor *  pFieldDescriptor);
00153 
00154     <span class="comment">/*</span>
00155 <span class="comment">     * 16-bit types</span>
00156 <span class="comment">     */</span>
00157 
00158     <span class="keywordtype">void</span>
00159     put_u16 (
00160       llrp_u16_t                Value,
00161       <span class="keyword">const</span> CFieldDescriptor *  pFieldDescriptor);
00162 
00163     <span class="keywordtype">void</span>
00164     put_s16 (
00165       llrp_s16_t                Value,
00166       <span class="keyword">const</span> CFieldDescriptor *  pFieldDescriptor);
00167 
00168     <span class="keywordtype">void</span>
00169     put_u16v (
00170       llrp_u16v_t               Value,
00171       <span class="keyword">const</span> CFieldDescriptor *  pFieldDescriptor);
00172 
00173     <span class="keywordtype">void</span>
00174     put_s16v (
00175       llrp_s16v_t               Value,
00176       <span class="keyword">const</span> CFieldDescriptor *  pFieldDescriptor);
00177 
00178     <span class="comment">/*</span>
00179 <span class="comment">     * 32-bit types</span>
00180 <span class="comment">     */</span>
00181 
00182     <span class="keywordtype">void</span>
00183     put_u32 (
00184       llrp_u32_t                Value,
00185       <span class="keyword">const</span> CFieldDescriptor *  pFieldDescriptor);
00186 
00187     <span class="keywordtype">void</span>
00188     put_s32 (
00189       llrp_s32_t                Value,
00190       <span class="keyword">const</span> CFieldDescriptor *  pFieldDescriptor);
00191 
00192     <span class="keywordtype">void</span>
00193     put_u32v (
00194       llrp_u32v_t               Value,
00195       <span class="keyword">const</span> CFieldDescriptor *  pFieldDescriptor);
00196 
00197     <span class="keywordtype">void</span>
00198     put_s32v (
00199       llrp_s32v_t               Value,
00200       <span class="keyword">const</span> CFieldDescriptor *  pFieldDescriptor);
00201 
00202     <span class="comment">/*</span>
00203 <span class="comment">     * 64-bit types</span>
00204 <span class="comment">     */</span>
00205 
00206     <span class="keywordtype">void</span>
00207     put_u64 (
00208       llrp_u64_t                Value,
00209       <span class="keyword">const</span> CFieldDescriptor *  pFieldDescriptor);
00210 
00211     <span class="keywordtype">void</span>
00212     put_s64 (
00213       llrp_s64_t                Value,
00214       <span class="keyword">const</span> CFieldDescriptor *  pFieldDescriptor);
00215 
00216     <span class="keywordtype">void</span>
00217     put_u64v (
00218       llrp_u64v_t               Value,
00219       <span class="keyword">const</span> CFieldDescriptor *  pFieldDescriptor);
00220 
00221     <span class="keywordtype">void</span>
00222     put_s64v (
00223       llrp_s64v_t               Value,
00224       <span class="keyword">const</span> CFieldDescriptor *  pFieldDescriptor);
00225 
00226     <span class="comment">/*</span>
00227 <span class="comment">     * Special types</span>
00228 <span class="comment">     */</span>
00229 
00230     <span class="keywordtype">void</span>
00231     put_u1 (
00232       llrp_u1_t                 Value,
00233       <span class="keyword">const</span> CFieldDescriptor *  pFieldDescriptor);
00234 
00235     <span class="keywordtype">void</span>
00236     put_u1v (
00237       llrp_u1v_t                Value,
00238       <span class="keyword">const</span> CFieldDescriptor *  pFieldDescriptor);
00239 
00240     <span class="keywordtype">void</span>
00241     put_u2 (
00242       llrp_u2_t                 Value,
00243       <span class="keyword">const</span> CFieldDescriptor *  pFieldDescriptor);
00244 
00245     <span class="keywordtype">void</span>
00246     put_u96 (
00247       llrp_u96_t                Value,
00248       <span class="keyword">const</span> CFieldDescriptor *  pFieldDescriptor);
00249 
00250     <span class="keywordtype">void</span>
00251     put_utf8v (
00252       llrp_utf8v_t              Value,
00253       <span class="keyword">const</span> CFieldDescriptor *  pFieldDescriptor);
00254 
00255     <span class="keywordtype">void</span>
00256     put_bytesToEnd (
00257       llrp_bytesToEnd_t         Value,
00258       <span class="keyword">const</span> CFieldDescriptor *  pFieldDescriptor);
00259 
00260     <span class="comment">/*</span>
00261 <span class="comment">     * Enumerated types of various sizes</span>
00262 <span class="comment">     */</span>
00263 
00264     <span class="keywordtype">void</span>
00265     put_e1 (
00266       <span class="keywordtype">int</span>                       eValue,
00267       <span class="keyword">const</span> CFieldDescriptor *  pFieldDescriptor);
00268 
00269     <span class="keywordtype">void</span>
00270     put_e2 (
00271       <span class="keywordtype">int</span>                       eValue,
00272       <span class="keyword">const</span> CFieldDescriptor *  pFieldDescriptor);
00273 
00274     <span class="keywordtype">void</span>
00275     put_e8 (
00276       <span class="keywordtype">int</span>                       eValue,
00277       <span class="keyword">const</span> CFieldDescriptor *  pFieldDescriptor);
00278 
00279     <span class="keywordtype">void</span>
00280     put_e16 (
00281       <span class="keywordtype">int</span>                       eValue,
00282       <span class="keyword">const</span> CFieldDescriptor *  pFieldDescriptor);
00283 
00284     <span class="keywordtype">void</span>
00285     put_e32 (
00286       <span class="keywordtype">int</span>                       eValue,
00287       <span class="keyword">const</span> CFieldDescriptor *  pFieldDescriptor);
00288 
00289     <span class="keywordtype">void</span>
00290     put_e8v (
00291       llrp_u8v_t                Value,
00292       <span class="keyword">const</span> CFieldDescriptor *  pFieldDescriptor);
00293 
00294     <span class="comment">/*</span>
00295 <span class="comment">     * Reserved types are some number of bits</span>
00296 <span class="comment">     */</span>
00297 
00298     <span class="keywordtype">void</span>
00299     put_reserved (
00300       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>              nBits);
00301 
00302   <span class="keyword">private</span>:
00303     CXMLTextEncoderStream (
00304       CXMLTextEncoder *         pEncoder);
00305 
00306     CXMLTextEncoderStream (
00307       CXMLTextEncoderStream *   pEnclosingEncoderStream);
00308 
00309     CXMLTextEncoder *           m_pEncoder;
00310     CXMLTextEncoderStream *     m_pEnclosingEncoderStream;
00311     <span class="keyword">const</span> CTypeDescriptor *     m_pRefType;
00312     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>                m_nDepth;
00313 
00314     <span class="keywordtype">void</span>
00315     putElement (
00316       <span class="keyword">const</span> CElement *          pElement);
00317 
00318     <span class="keywordtype">void</span>
00319     put_enum (
00320       <span class="keywordtype">int</span>                       eValue,
00321       <span class="keyword">const</span> CFieldDescriptor *  pFieldDescriptor);
00322 
00323     <span class="keywordtype">void</span>
00324     indent(<span class="keywordtype">int</span> delta = 0);
00325 
00326     <span class="keywordtype">void</span>
00327     appendOpenTag (
00328       <span class="keyword">const</span> <span class="keywordtype">char</span> *              pName);
00329 
00330     <span class="keywordtype">void</span>
00331     appendCloseTag (
00332       <span class="keyword">const</span> <span class="keywordtype">char</span> *              pName);
00333 
00334     <span class="keywordtype">void</span>
00335     appendPrefixedTagName (
00336       <span class="keyword">const</span> <span class="keywordtype">char</span> *              pName);
00337 
00338     <span class="keywordtype">void</span>
00339     appendFormat (
00340       <span class="keywordtype">char</span> *                    pFmtStr,
00341                                 ...);
00342 
00343 };
00344 
00345 <span class="keyword">class </span>CXMLTextDecoderStream : <span class="keyword">public</span> CDecoderStream
00346 {
00347   <span class="keyword">friend</span> <span class="keyword">class </span>CXMLTextDecoder;
00348 
00349   <span class="keyword">private</span>:
00350     CXMLTextDecoderStream (
00351       CXMLTextDecoder *         pDecoder);
00352 
00353     CXMLTextDecoderStream (
00354       CXMLTextDecoderStream *   pEnclosingDecoderStream);
00355 
00356   <span class="keyword">public</span>:    
00357 
00358     CElement *
00359     decodeElement (
00360       <span class="keywordtype">int</span>                           bAllowMessage,
00361       <span class="keywordtype">int</span>                           bSkipBlanks);      
00362       <span class="comment">/*</span>
00363 <span class="comment">     * 8-bit types</span>
00364 <span class="comment">     */</span>
00365 
00367     llrp_u8_t
00368     get_u8 (
00369       <span class="keyword">const</span> CFieldDescriptor *  pFieldDesc);
00370 
00372     llrp_s8_t
00373     get_s8 (
00374       <span class="keyword">const</span> CFieldDescriptor *  pFieldDesc);
00375 
00377     llrp_u8v_t
00378     get_u8v (
00379       <span class="keyword">const</span> CFieldDescriptor *  pFieldDesc);
00380 
00382     llrp_s8v_t
00383     get_s8v (
00384       <span class="keyword">const</span> CFieldDescriptor *  pFieldDesc);
00385 
00386     <span class="comment">/*</span>
00387 <span class="comment">     * 16-bit types</span>
00388 <span class="comment">     */</span>
00389 
00391     llrp_u16_t
00392     get_u16 (
00393       <span class="keyword">const</span> CFieldDescriptor *  pFieldDesc);
00394 
00396     llrp_s16_t
00397     get_s16 (
00398       <span class="keyword">const</span> CFieldDescriptor *  pFieldDesc);
00399 
00401     llrp_u16v_t
00402     get_u16v (
00403       <span class="keyword">const</span> CFieldDescriptor *  pFieldDesc);
00404 
00406     llrp_s16v_t
00407     get_s16v (
00408       <span class="keyword">const</span> CFieldDescriptor *  pFieldDesc);
00409 
00410     <span class="comment">/*</span>
00411 <span class="comment">     * 32-bit types</span>
00412 <span class="comment">     */</span>
00413 
00415     llrp_u32_t
00416     get_u32 (
00417       <span class="keyword">const</span> CFieldDescriptor *  pFieldDesc);
00418 
00420     llrp_s32_t
00421     get_s32 (
00422       <span class="keyword">const</span> CFieldDescriptor *  pFieldDesc);
00423 
00425     llrp_u32v_t
00426     get_u32v (
00427       <span class="keyword">const</span> CFieldDescriptor *  pFieldDesc);
00428 
00430     llrp_s32v_t
00431     get_s32v (
00432       <span class="keyword">const</span> CFieldDescriptor *  pFieldDesc);
00433 
00434     <span class="comment">/*</span>
00435 <span class="comment">     * 64-bit types</span>
00436 <span class="comment">     */</span>
00437 
00439     llrp_u64_t
00440     get_u64 (
00441       <span class="keyword">const</span> CFieldDescriptor *  pFieldDesc);
00442 
00444     llrp_s64_t
00445     get_s64 (
00446       <span class="keyword">const</span> CFieldDescriptor *  pFieldDesc);
00447 
00449     llrp_u64v_t
00450     get_u64v (
00451       <span class="keyword">const</span> CFieldDescriptor *  pFieldDesc);
00452 
00454     llrp_s64v_t
00455     get_s64v (
00456       <span class="keyword">const</span> CFieldDescriptor *  pFieldDesc);
00457 
00458     <span class="comment">/*</span>
00459 <span class="comment">     * Special types</span>
00460 <span class="comment">     */</span>
00461 
00463     llrp_u1_t
00464     get_u1 (
00465       <span class="keyword">const</span> CFieldDescriptor *  pFieldDesc);
00466 
00468     llrp_u1v_t
00469     get_u1v (
00470       <span class="keyword">const</span> CFieldDescriptor *  pFieldDesc);
00471 
00473     llrp_u2_t
00474     get_u2 (
00475       <span class="keyword">const</span> CFieldDescriptor *  pFieldDesc);
00476 
00478     llrp_u96_t
00479     get_u96 (
00480       <span class="keyword">const</span> CFieldDescriptor *  pFieldDesc);
00481 
00483     llrp_utf8v_t
00484     get_utf8v (
00485       <span class="keyword">const</span> CFieldDescriptor *  pFieldDesc);
00486 
00488     llrp_bytesToEnd_t
00489     get_bytesToEnd (
00490       <span class="keyword">const</span> CFieldDescriptor *  pFieldDesc);
00491 
00492     <span class="comment">/*</span>
00493 <span class="comment">     * Enumerated types of various sizes</span>
00494 <span class="comment">     */</span>
00495 
00497     <span class="keywordtype">int</span>
00498     get_e1 (
00499       <span class="keyword">const</span> CFieldDescriptor *  pFieldDesc);
00500 
00502     <span class="keywordtype">int</span>
00503     get_e2 (
00504       <span class="keyword">const</span> CFieldDescriptor *  pFieldDesc);
00505 
00507     <span class="keywordtype">int</span>
00508     get_e8 (
00509       <span class="keyword">const</span> CFieldDescriptor *  pFieldDesc);
00510 
00512     <span class="keywordtype">int</span>
00513     get_e16 (
00514       <span class="keyword">const</span> CFieldDescriptor *  pFieldDesc);
00515 
00517     <span class="keywordtype">int</span>
00518     get_e32 (
00519       <span class="keyword">const</span> CFieldDescriptor *  pFieldDesc);
00520 
00522     llrp_u8v_t
00523     get_e8v (
00524       <span class="keyword">const</span> CFieldDescriptor *  pFieldDesc);
00525 
00526     <span class="comment">/*</span>
00527 <span class="comment">     * Reserved means some number of bits</span>
00528 <span class="comment">     */</span>
00529     <span class="comment">/* @brief skips a number of reserved bits and discards during the encode/decode process */</span>
00530     <span class="keywordtype">void</span>
00531     get_reserved (
00532       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>          nBits);
00533 
00534   <span class="keyword">private</span>:
00535     CXMLTextDecoder *           m_pDecoder;
00536     CXMLTextDecoderStream *     m_pEnclosingDecoderStream;
00537     <span class="keyword">const</span> CTypeDescriptor *     m_pRefType;
00538     <span class="keyword">struct </span>_xmlNode *           m_pTargetNode;
00539     <span class="keyword">struct </span>_xmlNode *           m_pCurrentChildNode;
00540     <span class="keyword">struct </span>_xmlNode *           m_pLastFieldNode;
00541 
00542     llrp_bool_t
00543     verifyVectorAllocation (
00544       <span class="keyword">const</span> <span class="keywordtype">void</span> *              pValue,
00545       <span class="keyword">const</span> CFieldDescriptor *  pFieldDescriptor);
00546 
00547     <span class="keyword">static</span> <span class="keywordtype">int</span>
00548     isInsignificantNode (
00549       <span class="keyword">struct</span> _xmlNode *         pnode);
00550 
00551 <span class="comment">/* some class member field helpers */</span>
00552     <span class="keywordtype">int</span> 
00553     getFieldStringPtr(
00554       <span class="keyword">const</span> CFieldDescriptor *  pFieldDescriptor,
00555       <span class="keyword">const</span> llrp_u8_t **        pbuf,
00556       <span class="keyword">const</span> llrp_u8_t **        pend);
00557 
00558     llrp_s64v_t
00559     getSpacedVectorField (
00560       <span class="keyword">const</span> CFieldDescriptor *  pFieldDescriptor,
00561       llrp_s64_t                minValue,
00562       llrp_s64_t                maxValue);
00563 
00564     llrp_s64v_t
00565     getFixedVectorField (
00566       <span class="keyword">const</span> CFieldDescriptor *  pFieldDescriptor,
00567       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>              vectorSize,
00568       llrp_s64_t                minValue,
00569       llrp_s64_t                maxValue);
00570 
00571     llrp_s64_t
00572     getIntegerField (
00573       <span class="keyword">const</span> CFieldDescriptor *  pFieldDescriptor,
00574       llrp_s64_t                minValue,
00575       llrp_s64_t                maxValue);
00576 
00577     llrp_s64_t getInteger(
00578       <span class="keyword">const</span> CFieldDescriptor *  pFieldDescriptor,
00579       <span class="keyword">const</span> llrp_u8_t *         pbuf,
00580       <span class="keyword">const</span> llrp_u8_t *         pend,
00581       CErrorDetails            *pError,
00582       llrp_s64_t                minValue,
00583       llrp_s64_t                maxValue);
00584 
00585 <span class="comment">/* static string helpers */</span>
00586 
00587     <span class="keyword">static</span> <span class="keyword">const</span> llrp_u8_t *
00588     getSingleU1(
00589       <span class="keyword">const</span> llrp_u8_t *         pbuf,
00590       <span class="keyword">const</span> llrp_u8_t *         pend,
00591       llrp_s64_t *              pValue);
00592 
00593     <span class="keyword">static</span> <span class="keyword">const</span> llrp_u8_t *
00594     getSingleEnum(
00595       <span class="keyword">const</span> CFieldDescriptor *  pFieldDescriptor,
00596       <span class="keyword">const</span> llrp_u8_t *         pbuf,
00597       <span class="keyword">const</span> llrp_u8_t *         pend,
00598       llrp_s64_t *              pValue);
00599 
00600     <span class="keyword">static</span> <span class="keyword">const</span> llrp_u8_t *
00601     getSingleDecimal(
00602       <span class="keyword">const</span> llrp_u8_t *         pbuf,
00603       <span class="keyword">const</span> llrp_u8_t *         pend,
00604       llrp_s64_t *              pValue);
00605 
00606     <span class="keyword">static</span> <span class="keyword">const</span> llrp_u8_t *
00607     getSingleHexidecimal(
00608       <span class="keyword">const</span> llrp_u8_t *         pbuf,
00609       <span class="keyword">const</span> llrp_u8_t *         pend,
00610       llrp_s64_t *              pValue);
00611 
00612     <span class="keyword">static</span> <span class="keywordtype">int</span>
00613     cleanString(
00614       <span class="keyword">const</span> llrp_u8_t **        ppbuf,
00615       <span class="keyword">const</span> llrp_u8_t **        ppend);
00616 
00617     <span class="keyword">static</span> <span class="keyword">const</span> llrp_u8_t *
00618     getSingleTimestamp(
00619       <span class="keyword">const</span> llrp_u8_t *         pbuf,
00620       <span class="keyword">const</span> llrp_u8_t *         pend,
00621       llrp_s64_t *              pValue);
00622 
00623     <span class="keyword">static</span> llrp_u16_t 
00624     countElements(
00625       <span class="keyword">const</span> <span class="keywordtype">char</span> *              pval, 
00626       <span class="keywordtype">int</span>                      nval);
00627 
00628     <span class="keyword">private</span>:
00629       <span class="keyword">static</span> <span class="keyword">const</span> llrp_s64_t MAX_U8 =  ((1ull &lt;&lt; 8u) - 1u);
00630       <span class="keyword">static</span> <span class="keyword">const</span> llrp_s64_t MIN_U8 =  0ull;
00631       <span class="keyword">static</span> <span class="keyword">const</span> llrp_s64_t MAX_S8 =  ((1ull &lt;&lt; 7u) - 1u);
00632       <span class="keyword">static</span> <span class="keyword">const</span> llrp_s64_t MIN_S8 =  (-1ll - MAX_S8);
00633 
00634       <span class="keyword">static</span> <span class="keyword">const</span> llrp_s64_t MAX_U16 = ((1ull &lt;&lt; 16u) - 1u);
00635       <span class="keyword">static</span> <span class="keyword">const</span> llrp_s64_t MIN_U16 = 0ull;
00636       <span class="keyword">static</span> <span class="keyword">const</span> llrp_s64_t MAX_S16 = ((1ull &lt;&lt; 15u) - 1u);
00637       <span class="keyword">static</span> <span class="keyword">const</span> llrp_s64_t MIN_S16 = (-1ll - MAX_S16);
00638 
00639       <span class="keyword">static</span> <span class="keyword">const</span> llrp_s64_t MAX_U32 = ((1ull &lt;&lt; 32u) - 1u);
00640       <span class="keyword">static</span> <span class="keyword">const</span> llrp_s64_t MIN_U32 = 0ull;
00641       <span class="keyword">static</span> <span class="keyword">const</span> llrp_s64_t MAX_S32 = ((1ull &lt;&lt; 31u) - 1u);
00642       <span class="keyword">static</span> <span class="keyword">const</span> llrp_s64_t MIN_S32 = (-1ll - MAX_S32);
00643 
00644       <span class="keyword">static</span> <span class="keyword">const</span> llrp_s64_t MAX_U64 = ((1ull &lt;&lt; 63u) - 1u);    <span class="comment">// one bit lost</span>
00645       <span class="keyword">static</span> <span class="keyword">const</span> llrp_s64_t MIN_U64 = 0ull;
00646       <span class="keyword">static</span> <span class="keyword">const</span> llrp_s64_t MAX_S64 = ((1ull &lt;&lt; 63u) - 1u);
00647       <span class="keyword">static</span> <span class="keyword">const</span> llrp_s64_t MIN_S64 = (-1ll - MAX_S64);
00648 
00649 };
00650 
00651 };
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Wed Feb 24 09:16:21 2010 for LTKCPP-- LLRP Toolkit C Plus Plus Library by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.3.9.1 </small></address>
</body>
</html>
