<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>LTKCPP-- LLRP Toolkit C Plus Plus Library: xml2llrp.cpp Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.9.1 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="namespacemembers.html">Namespace&nbsp;Members</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a></div>
<div class="nav">
<a class="el" href="dir_000000.html">Tests</a></div>
<h1>xml2llrp.cpp</h1><div class="fragment"><pre class="fragment">00001 
00002 <span class="comment">/*</span>
00003 <span class="comment"> ***************************************************************************</span>
00004 <span class="comment"> *  Copyright 2007,2010 Impinj, Inc.</span>
00005 <span class="comment"> *</span>
00006 <span class="comment"> *  Licensed under the Apache License, Version 2.0 (the "License");</span>
00007 <span class="comment"> *  you may not use this file except in compliance with the License.</span>
00008 <span class="comment"> *  You may obtain a copy of the License at</span>
00009 <span class="comment"> *</span>
00010 <span class="comment"> *      http://www.apache.org/licenses/LICENSE-2.0</span>
00011 <span class="comment"> *</span>
00012 <span class="comment"> *  Unless required by applicable law or agreed to in writing, software</span>
00013 <span class="comment"> *  distributed under the License is distributed on an "AS IS" BASIS,</span>
00014 <span class="comment"> *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
00015 <span class="comment"> *  See the License for the specific language governing permissions and</span>
00016 <span class="comment"> *  limitations under the License.</span>
00017 <span class="comment"> *</span>
00018 <span class="comment"> ***************************************************************************</span>
00019 <span class="comment"> */</span>
00020 
00021 
00055 <span class="preprocessor">#include &lt;stdio.h&gt;</span>
00056 
00057 <span class="preprocessor">#include "<a class="code" href="ltkcpp_8h.html">ltkcpp.h</a>"</span>
00058 <span class="preprocessor">#include "libxml/parser.h"</span>
00059 <span class="preprocessor">#include "libxml/tree.h"</span>
00060 
00061 
00062 <span class="keyword">using</span> <span class="keyword">namespace </span>LLRP;
00063 
00064 <span class="comment">// turn this on to learn more about errors </span>
00065 <span class="preprocessor">#undef XML2LLRP_DEBUG</span>
00066 <span class="preprocessor"></span>
00067 <span class="preprocessor">#define FRAME_BUF_SIZE          (4u*1024u*1024u)</span>
00068 <span class="preprocessor"></span>
00069 <span class="comment">/* This is the message format that is agreed upon when messages fail</span>
00070 <span class="comment">** to decode. It's somewhat arbitrary, but allows us to do easy</span>
00071 <span class="comment">** comparisons */</span>
00072 <span class="keyword">const</span> <span class="keywordtype">char</span> * errMsgStr = <span class="stringliteral">"&lt;ERROR_MESSAGE MessageID=\"0\" Version=\"0\"&gt;\n"</span> \
00073                          <span class="stringliteral">"  &lt;LLRPStatus&gt;\n"</span> \
00074                          <span class="stringliteral">"    &lt;StatusCode&gt;M_Success&lt;/StatusCode&gt;\n"</span> \
00075                          <span class="stringliteral">"    &lt;ErrorDescription&gt;&lt;/ErrorDescription&gt;\n"</span> \
00076                          <span class="stringliteral">"  &lt;/LLRPStatus&gt;\n"</span> \
00077                          <span class="stringliteral">"&lt;/ERROR_MESSAGE&gt;\n"</span>;
00078 
00079 <span class="comment">/* the corresponding binary packet */</span>
00080 <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> errMsgBinary[18] = {0x04, 0x64, 0x00, 0x00, 
00081                                   0x00, 0x12, 0x00, 0x00, 
00082                                   0x00, 0x00, 0x01, 0x1F, 
00083                                   0x00, 0x08, 0x00, 0x00, 
00084                                   0x00, 0x00};
00085 
00101 <span class="keywordtype">int</span>
00102 <a class="code" href="example1_8cpp.html#a0">main</a> (<span class="keywordtype">int</span> ac, <span class="keywordtype">char</span> *av[])
00103 {
00104     <a class="code" href="classLLRP_1_1CTypeRegistry.html">CTypeRegistry</a> *             pTypeRegistry;
00105     CXMLTextDecoder *           pDecoder;
00106     <a class="code" href="classLLRP_1_1CMessage.html">CMessage</a> *                  pMessage;
00107     xmlDoc*                     pDoc;
00108     xmlNode*                    pNode;
00109     <span class="comment">/*</span>
00110 <span class="comment">     * Check arg count</span>
00111 <span class="comment">     */</span>
00112     <span class="keywordflow">if</span>(ac != 2)
00113     {
00114         fprintf(stderr, <span class="stringliteral">"ERROR: Bad usage\nusage: %s INPUTFILE\n"</span>, av[0]);
00115         exit(1);
00116     }
00117 
00118     <span class="comment">/*</span>
00119 <span class="comment">     * Construct the type registry. This is needed for decode.</span>
00120 <span class="comment">     */</span>
00121     pTypeRegistry = getTheTypeRegistry();
00122 
00123 
00124     <span class="comment">/* use libXML to read the DOM */</span>
00125     xmlInitParser();
00126 
00127     <span class="comment">/* set the line numbers for error reporting */</span>
00128     xmlLineNumbersDefault(1);
00129 
00130     pDoc = xmlReadFile(av[1], 
00131                        NULL, 
00132                        XML_PARSE_COMPACT | XML_PARSE_NONET);
00133 
00134     <span class="keywordflow">if</span>(NULL == pDoc)
00135     {
00136         fprintf(stderr, <span class="stringliteral">"ERROR: Could not read XML File\n"</span>);
00137         <span class="keyword">delete</span> pTypeRegistry;
00138         xmlCleanupParser();
00139         exit(2);
00140     }
00141 
00142     pNode = xmlDocGetRootElement(pDoc);
00143 
00144     <span class="comment">/* find the first element node and make sure its PS */</span>
00145     <span class="keywordflow">while</span>((pNode) &amp;&amp; (XML_ELEMENT_NODE != pNode-&gt;type))
00146     {
00147         pNode = pNode-&gt;next;
00148     }
00149 
00150     <span class="keywordflow">if</span>(NULL == pNode)
00151     {
00152         fprintf(stderr, <span class="stringliteral">"ERROR: Could not get XML PacketSequence node.  "</span> \
00153                         <span class="stringliteral">"Found no top-level Element nodes \n"</span>);
00154         <span class="keyword">delete</span> pTypeRegistry;
00155         xmlCleanupParser();
00156         exit(3);
00157     }
00158 
00159     <span class="keywordflow">if</span>(strcmp((<span class="keyword">const</span> <span class="keywordtype">char</span>*) pNode-&gt;name, <span class="stringliteral">"packetSequence"</span>) != 0)
00160     {
00161         fprintf(stderr, <span class="stringliteral">"ERROR: Could not get XML PacketSequence node.  "</span> \
00162                         <span class="stringliteral">"Found %s instead\n"</span>, pNode-&gt;name);
00163         xmlFreeDoc(pDoc);
00164         xmlCleanupParser();
00165         <span class="keyword">delete</span> pTypeRegistry;
00166         exit(4);
00167     }
00168     
00169     <span class="comment">/* not sure this is necessary */</span>
00170     freopen(NULL, <span class="stringliteral">"wb"</span>, stdout);
00171 
00172     <span class="comment">/* packets are all children of the first node */</span>
00173     pNode = pNode-&gt;children;
00174   
00175     <span class="keywordflow">while</span>(pNode != NULL)
00176     {
00177         <span class="keywordflow">if</span>(XML_ELEMENT_NODE == pNode-&gt;type)
00178         {
00179             xmlChar *           pMessageIDStr = NULL;
00180 
00181             <span class="comment">/* It helps to know the message ID for debugging */</span>
00182             pMessageIDStr = xmlGetProp(pNode, (<span class="keyword">const</span> xmlChar*) <span class="stringliteral">"MessageID"</span>);
00183 
00184             <span class="comment">/*</span>
00185 <span class="comment">             * Construct a frame decoder. It references the</span>
00186 <span class="comment">             * type registry and the input buffer.</span>
00187 <span class="comment">             */</span>
00188             pDecoder = <span class="keyword">new</span> CXMLTextDecoder(pTypeRegistry, pNode);
00189 
00190             <span class="comment">/*</span>
00191 <span class="comment">             * Now ask the frame decoder to actually decode</span>
00192 <span class="comment">             * the message. It returns NULL for an error.</span>
00193 <span class="comment">             */</span>
00194              pMessage = pDecoder-&gt;decodeMessage();
00195 
00196             <span class="comment">/*</span>
00197 <span class="comment">             * Did the decode fail?</span>
00198 <span class="comment">             */</span>
00199             <span class="keywordflow">if</span>(NULL == pMessage)
00200             {
00201                 <span class="keyword">const</span> <a class="code" href="classLLRP_1_1CErrorDetails.html">CErrorDetails</a> *pError;
00202  
00203                 <span class="comment">/* encode error message as binary */</span>
00204                 fwrite(errMsgBinary, 1, <span class="keyword">sizeof</span>(errMsgBinary), stdout);
00205 
00206                 pError = &amp;pDecoder-&gt;m_ErrorDetails;
00207  
00208 <span class="preprocessor">#ifdef XML2LLRP_DEBUG</span>
00209 <span class="preprocessor"></span>                fprintf(stderr, <span class="stringliteral">"ERROR: Decoder error, result=%d\n"</span>,
00210                         pError-&gt;<a class="code" href="classLLRP_1_1CErrorDetails.html#o0">m_eResultCode</a>);
00211 
00212                 <span class="keywordflow">if</span>(NULL != pMessageIDStr)
00213                 {
00214                     fprintf(stderr, <span class="stringliteral">"ERROR ... MessageID=%s\n"</span>, 
00215                            pMessageIDStr);
00216                 }
00217                 <span class="keywordflow">if</span>(NULL != pError-&gt;<a class="code" href="classLLRP_1_1CErrorDetails.html#o2">m_pRefType</a>)
00218                 { 
00219                     fprintf(stderr, <span class="stringliteral">"ERROR ... refType=%s\n"</span>,
00220                            pError-&gt;<a class="code" href="classLLRP_1_1CErrorDetails.html#o2">m_pRefType</a>-&gt;<a class="code" href="classLLRP_1_1CTypeDescriptor.html#o1">m_pName</a>);
00221                 }
00222                 <span class="keywordflow">if</span>(NULL != pError-&gt;<a class="code" href="classLLRP_1_1CErrorDetails.html#o3">m_pRefField</a>)
00223                 {
00224                     fprintf(stderr, <span class="stringliteral">"ERROR ... refField=%s\n"</span>,
00225                            pError-&gt;<a class="code" href="classLLRP_1_1CErrorDetails.html#o3">m_pRefField</a>-&gt;<a class="code" href="classLLRP_1_1CFieldDescriptor.html#o2">m_pName</a>);
00226                 }
00227                 <span class="keywordflow">if</span>(NULL != pError-&gt;<a class="code" href="classLLRP_1_1CErrorDetails.html#o1">m_pWhatStr</a>)
00228                 {
00229                     fprintf(stderr, <span class="stringliteral">"ERROR ... whatStr=%s\n"</span>,
00230                            pError-&gt;<a class="code" href="classLLRP_1_1CErrorDetails.html#o1">m_pWhatStr</a>); 
00231                 }
00232                 <span class="keywordflow">if</span>(0 != pError-&gt;<a class="code" href="classLLRP_1_1CErrorDetails.html#o4">m_OtherDetail</a>)
00233                 {
00234                     fprintf(stderr, <span class="stringliteral">"ERROR ... XML line number %d\n"</span>, 
00235                             pError-&gt;<a class="code" href="classLLRP_1_1CErrorDetails.html#o4">m_OtherDetail</a>);
00236                 }
00237 <span class="preprocessor">#endif </span><span class="comment">/* XML2LLRP_DEBUG */</span>
00238 
00239                 <span class="keyword">delete</span> pDecoder;
00240                 xmlFree(pMessageIDStr);
00241             }
00242             <span class="keywordflow">else</span>
00243             {
00244                 <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>           aOutBuffer[FRAME_BUF_SIZE];
00245                 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>            nOutBuffer;
00246                 CFrameEncoder *         pEncoder;
00247 
00248 <span class="preprocessor">#ifdef XML2LLRP_DEBUG</span>
00249 <span class="preprocessor"></span>                <span class="keywordflow">if</span>(NULL == pMessageIDStr)
00250                 {
00251                     pMessageIDStr = (xmlChar*) <span class="stringliteral">"unknown"</span>;
00252                 }
00253                 fprintf(stderr, <span class="stringliteral">"SUCCESS ... MessageID=%s passed encoding\n"</span>, 
00254                         pMessageIDStr);
00255 
00256 <span class="preprocessor">#endif  </span><span class="comment">/* XML2LLRP_DEBUG */</span>
00257 
00258                 xmlFree(pMessageIDStr);
00259                 <span class="keyword">delete</span> pDecoder;
00260                 
00261                 <span class="comment">/* encode the message as binary */</span>
00262  
00263                 <span class="comment">/*</span>
00264 <span class="comment">                 * Zero fill the buffer to make things easier</span>
00265 <span class="comment">                 * on the debugger.</span>
00266 <span class="comment">                 */</span>
00267                 memset(aOutBuffer, 0, <span class="keyword">sizeof</span> aOutBuffer);
00268 
00269                 <span class="comment">/*</span>
00270 <span class="comment">                 * Construct a frame encoder. It references</span>
00271 <span class="comment">                 * the output buffer and knows the maximum size.</span>
00272 <span class="comment">                 */</span>
00273                 pEncoder = <span class="keyword">new</span> CFrameEncoder(aOutBuffer, 
00274                                              <span class="keyword">sizeof</span> aOutBuffer);
00275 
00276                 <span class="comment">/*</span>
00277 <span class="comment">                 * Do the encode.</span>
00278 <span class="comment">                 * TODO: check the result, tattle on errors.</span>
00279 <span class="comment">                 */</span>
00280                 pEncoder-&gt;encodeElement(pMessage);
00281 
00282                 <span class="comment">/*</span>
00283 <span class="comment">                 * Get the byte length of the resulting frame.</span>
00284 <span class="comment">                 */</span>
00285                 nOutBuffer = pEncoder-&gt;getLength();
00286 
00287                 <span class="comment">/*</span>
00288 <span class="comment">                 * Check the status, tattle on errors</span>
00289 <span class="comment">                 */</span>
00290                 <span class="keywordflow">if</span>(<a class="code" href="namespaceLLRP.html#a333a251">RC_OK</a> != pEncoder-&gt;m_ErrorDetails.m_eResultCode)
00291                 {
00292                     <span class="keyword">const</span> <a class="code" href="classLLRP_1_1CErrorDetails.html">CErrorDetails</a> *pError;
00293 
00294                     pError = &amp;pEncoder-&gt;m_ErrorDetails;
00295 
00296                     <span class="comment">/* encode error message as binary */</span>
00297                     fwrite(errMsgBinary,1, <span class="keyword">sizeof</span>(errMsgBinary), stdout);
00298 
00299 <span class="preprocessor">#ifdef XML2LLRP_DEBUG</span>
00300 <span class="preprocessor"></span>                    fprintf(stderr, <span class="stringliteral">"Failed to Encode XML message\n"</span>);
00301                     fprintf(stderr, <span class="stringliteral">"ERROR: Encoder error, status=%d\n"</span>,
00302                             pError-&gt;<a class="code" href="classLLRP_1_1CErrorDetails.html#o0">m_eResultCode</a>);
00303                     <span class="keywordflow">if</span>(NULL != pError-&gt;<a class="code" href="classLLRP_1_1CErrorDetails.html#o2">m_pRefType</a>)
00304                     {
00305                         fprintf(stderr, <span class="stringliteral">"ERROR ... refType=%s\n"</span>,
00306                                 pError-&gt;<a class="code" href="classLLRP_1_1CErrorDetails.html#o2">m_pRefType</a>-&gt;<a class="code" href="classLLRP_1_1CTypeDescriptor.html#o1">m_pName</a>);
00307                     }
00308                     <span class="keywordflow">if</span>(NULL != pError-&gt;<a class="code" href="classLLRP_1_1CErrorDetails.html#o3">m_pRefField</a>)
00309                     {
00310                         fprintf(stderr, <span class="stringliteral">"ERROR ... refField=%s\n"</span>,
00311                                 pError-&gt;<a class="code" href="classLLRP_1_1CErrorDetails.html#o3">m_pRefField</a>-&gt;<a class="code" href="classLLRP_1_1CFieldDescriptor.html#o2">m_pName</a>);
00312                     }
00313 <span class="preprocessor">#endif </span><span class="comment">/* XML2LLRP_DEBUG */</span>
00314                 }
00315                 <span class="keywordflow">else</span>
00316                 {
00317                     fwrite(aOutBuffer, 1, nOutBuffer, stdout);
00318                 }
00319 
00320 
00321                 <span class="comment">/* free the frame encoder */</span>
00322                 <span class="keyword">delete</span> pEncoder;
00323             }
00324 
00325             <span class="comment">/* free the message we built */</span>
00326             <span class="keyword">delete</span> pMessage;
00327         }
00328         pNode = pNode-&gt;next;
00329     }
00330 
00331     xmlFreeDoc(pDoc);
00332     xmlCleanupParser();
00333     <span class="keyword">delete</span> pTypeRegistry;
00334 
00335     <span class="comment">/*</span>
00336 <span class="comment">     * When we get here everything that was allocated</span>
00337 <span class="comment">     * should now be deallocated.</span>
00338 <span class="comment">     */</span>
00339     <span class="keywordflow">return</span> 0;
00340 }
00341 
00342 
00343 
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Wed Feb 24 09:16:21 2010 for LTKCPP-- LLRP Toolkit C Plus Plus Library by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.3.9.1 </small></address>
</body>
</html>
