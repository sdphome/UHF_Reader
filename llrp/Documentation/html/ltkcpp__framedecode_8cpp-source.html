<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>LTKCPP-- LLRP Toolkit C Plus Plus Library: ltkcpp_framedecode.cpp Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.9.1 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="namespacemembers.html">Namespace&nbsp;Members</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a></div>
<div class="nav">
<a class="el" href="dir_000002.html">Library</a></div>
<h1>ltkcpp_framedecode.cpp</h1><div class="fragment"><pre class="fragment">00001 
00002 <span class="comment">/*</span>
00003 <span class="comment"> ***************************************************************************</span>
00004 <span class="comment"> *  Copyright 2007,2008 Impinj, Inc.</span>
00005 <span class="comment"> *</span>
00006 <span class="comment"> *  Licensed under the Apache License, Version 2.0 (the "License");</span>
00007 <span class="comment"> *  you may not use this file except in compliance with the License.</span>
00008 <span class="comment"> *  You may obtain a copy of the License at</span>
00009 <span class="comment"> *</span>
00010 <span class="comment"> *      http://www.apache.org/licenses/LICENSE-2.0</span>
00011 <span class="comment"> *</span>
00012 <span class="comment"> *  Unless required by applicable law or agreed to in writing, software</span>
00013 <span class="comment"> *  distributed under the License is distributed on an "AS IS" BASIS,</span>
00014 <span class="comment"> *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
00015 <span class="comment"> *  See the License for the specific language governing permissions and</span>
00016 <span class="comment"> *  limitations under the License.</span>
00017 <span class="comment"> *</span>
00018 <span class="comment"> ***************************************************************************</span>
00019 <span class="comment"> */</span>
00020 
00021 
00022 <span class="preprocessor">#include &lt;assert.h&gt;</span>
00023 
00024 <span class="preprocessor">#include "<a class="code" href="ltkcpp__platform_8h.html">ltkcpp_platform.h</a>"</span>
00025 <span class="preprocessor">#include "<a class="code" href="ltkcpp__base_8h.html">ltkcpp_base.h</a>"</span>
00026 <span class="preprocessor">#include "<a class="code" href="ltkcpp__frame_8h.html">ltkcpp_frame.h</a>"</span>
00027 
00028 
00029 <span class="keyword">namespace </span>LLRP
00030 {
00031 
00032 CFrameDecoder::CFrameDecoder (
00033   <span class="keyword">const</span> CTypeRegistry *         pTypeRegistry,
00034   <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *               pBuffer,
00035   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>                  nBuffer)
00036  : CDecoder(pTypeRegistry)
00037 {
00038     m_pBuffer        = pBuffer;
00039     m_nBuffer        = nBuffer;
00040 
00041     m_iNext          = 0;
00042     m_BitFieldBuffer = 0;
00043     m_nBitFieldResid = 0;
00044 }
00045 
00046 CFrameDecoder::~CFrameDecoder (<span class="keywordtype">void</span>)
00047 {
00048 }
00049 
00050 CMessage *
00051 CFrameDecoder::decodeMessage (<span class="keywordtype">void</span>)
00052 {
00053     CFrameDecoderStream     DecoderStream(<span class="keyword">this</span>);
00054     CMessage *              pMessage;
00055 
00056     pMessage = DecoderStream.getMessage();
00057 
00058     <span class="keywordflow">return</span> pMessage;
00059 }
00060 
00061 llrp_u8_t
00062 CFrameDecoder::next_u8 (<span class="keywordtype">void</span>)
00063 {
00064     llrp_u8_t                   Value;
00065 
00066     assert(m_iNext + 1u &lt;= m_nBuffer);
00067 
00068     Value = m_pBuffer[m_iNext++];
00069 
00070     <span class="keywordflow">return</span> Value;
00071 }
00072 
00073 llrp_u16_t
00074 CFrameDecoder::next_u16 (<span class="keywordtype">void</span>)
00075 {
00076     llrp_u16_t                  Value;
00077 
00078     assert(m_iNext + 2u &lt;= m_nBuffer);
00079 
00080     Value = m_pBuffer[m_iNext++];
00081     Value &lt;&lt;= 8u;
00082     Value |= m_pBuffer[m_iNext++];
00083 
00084     <span class="keywordflow">return</span> Value;
00085 }
00086 
00087 llrp_u32_t
00088 CFrameDecoder::next_u32 (<span class="keywordtype">void</span>)
00089 {
00090     llrp_u32_t                  Value;
00091 
00092     assert(m_iNext + 4u &lt;= m_nBuffer);
00093 
00094     Value = m_pBuffer[m_iNext++];
00095     Value &lt;&lt;= 8u;
00096     Value |= m_pBuffer[m_iNext++];
00097     Value &lt;&lt;= 8u;
00098     Value |= m_pBuffer[m_iNext++];
00099     Value &lt;&lt;= 8u;
00100     Value |= m_pBuffer[m_iNext++];
00101 
00102     <span class="keywordflow">return</span> Value;
00103 }
00104 
00105 llrp_u64_t
00106 CFrameDecoder::next_u64 (<span class="keywordtype">void</span>)
00107 {
00108     llrp_u64_t                  Value;
00109 
00110     assert(m_iNext + 8u &lt;= m_nBuffer);
00111 
00112     Value = m_pBuffer[m_iNext++];
00113     Value &lt;&lt;= 8u;
00114     Value |= m_pBuffer[m_iNext++];
00115     Value &lt;&lt;= 8u;
00116     Value |= m_pBuffer[m_iNext++];
00117     Value &lt;&lt;= 8u;
00118     Value |= m_pBuffer[m_iNext++];
00119     Value &lt;&lt;= 8u;
00120     Value |= m_pBuffer[m_iNext++];
00121     Value &lt;&lt;= 8u;
00122     Value |= m_pBuffer[m_iNext++];
00123     Value &lt;&lt;= 8u;
00124     Value |= m_pBuffer[m_iNext++];
00125     Value &lt;&lt;= 8u;
00126     Value |= m_pBuffer[m_iNext++];
00127 
00128     <span class="keywordflow">return</span> Value;
00129 }
00130 
00131 llrp_u8_t
00132 CFrameDecoderStream::get_u8 (
00133   <span class="keyword">const</span> CFieldDescriptor *      pFieldDescriptor)
00134 {
00135     llrp_u8_t                   Value;
00136 
00137     <span class="keywordflow">if</span>(checkAvailable(1u, pFieldDescriptor))
00138     {
00139         Value = m_pDecoder-&gt;next_u8();
00140     }
00141     <span class="keywordflow">else</span>
00142     {
00143         Value = 0;
00144     }
00145 
00146     <span class="keywordflow">return</span> Value;
00147 }
00148 
00149 llrp_s8_t
00150 CFrameDecoderStream::get_s8 (
00151   <span class="keyword">const</span> CFieldDescriptor *      pFieldDescriptor)
00152 {
00153     llrp_s8_t                   Value;
00154 
00155     <span class="keywordflow">if</span>(checkAvailable(1u, pFieldDescriptor))
00156     {
00157         Value = m_pDecoder-&gt;next_u8();
00158     }
00159     <span class="keywordflow">else</span>
00160     {
00161         Value = 0;
00162     }
00163 
00164     <span class="keywordflow">return</span> Value;
00165 }
00166 
00167 llrp_u8v_t
00168 CFrameDecoderStream::get_u8v (
00169   <span class="keyword">const</span> CFieldDescriptor *      pFieldDescriptor)
00170 {
00171     llrp_u16_t                  nValue;
00172     llrp_u8v_t                  Value;
00173 
00174     nValue = getVarlenCount(pFieldDescriptor);
00175 
00176     <span class="keywordflow">if</span>(0 &lt; nValue)
00177     {
00178         <span class="keywordflow">if</span>(checkAvailable(1u * nValue, pFieldDescriptor))
00179         {
00180             Value = llrp_u8v_t(nValue);
00181             <span class="keywordflow">if</span>(verifyVectorAllocation(Value.m_pValue, pFieldDescriptor))
00182             {
00183                 <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> Ix = 0; Ix &lt; nValue; Ix++)
00184                 {
00185                     Value.m_pValue[Ix] = m_pDecoder-&gt;next_u8();
00186                 }
00187             }
00188         }
00189     }
00190 
00191     <span class="keywordflow">return</span> Value;
00192 }
00193 
00194 llrp_s8v_t
00195 CFrameDecoderStream::get_s8v (
00196   <span class="keyword">const</span> CFieldDescriptor *      pFieldDescriptor)
00197 {
00198     llrp_u16_t                  nValue;
00199     llrp_s8v_t                  Value;
00200 
00201     nValue = getVarlenCount(pFieldDescriptor);
00202 
00203     <span class="keywordflow">if</span>(0 &lt; nValue)
00204     {
00205         <span class="keywordflow">if</span>(checkAvailable(1u * nValue, pFieldDescriptor))
00206         {
00207             Value = llrp_s8v_t(nValue);
00208             <span class="keywordflow">if</span>(verifyVectorAllocation(Value.m_pValue, pFieldDescriptor))
00209             {
00210                 <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> Ix = 0; Ix &lt; nValue; Ix++)
00211                 {
00212                     Value.m_pValue[Ix] = m_pDecoder-&gt;next_u8();
00213                 }
00214             }
00215         }
00216     }
00217 
00218     <span class="keywordflow">return</span> Value;
00219 }
00220 
00221 llrp_u16_t
00222 CFrameDecoderStream::get_u16 (
00223   <span class="keyword">const</span> CFieldDescriptor *      pFieldDescriptor)
00224 {
00225     llrp_u16_t                  Value;
00226 
00227     <span class="keywordflow">if</span>(checkAvailable(2u, pFieldDescriptor))
00228     {
00229         Value = m_pDecoder-&gt;next_u16();
00230     }
00231     <span class="keywordflow">else</span>
00232     {
00233         Value = 0;
00234     }
00235 
00236     <span class="keywordflow">return</span> Value;
00237 }
00238 
00239 llrp_s16_t
00240 CFrameDecoderStream::get_s16 (
00241   <span class="keyword">const</span> CFieldDescriptor *      pFieldDescriptor)
00242 {
00243     llrp_u16_t                  Value;
00244 
00245     <span class="keywordflow">if</span>(checkAvailable(2u, pFieldDescriptor))
00246     {
00247         Value = m_pDecoder-&gt;next_u16();
00248     }
00249     <span class="keywordflow">else</span>
00250     {
00251         Value = 0;
00252     }
00253 
00254     <span class="keywordflow">return</span> Value;
00255 }
00256 
00257 llrp_u16v_t
00258 CFrameDecoderStream::get_u16v (
00259   <span class="keyword">const</span> CFieldDescriptor *      pFieldDescriptor)
00260 {
00261     llrp_u16_t                  nValue;
00262     llrp_u16v_t                 Value;
00263 
00264     nValue = getVarlenCount(pFieldDescriptor);
00265 
00266     <span class="keywordflow">if</span>(0 &lt; nValue)
00267     {
00268         <span class="keywordflow">if</span>(checkAvailable(2u * nValue, pFieldDescriptor))
00269         {
00270             Value = llrp_u16v_t(nValue);
00271             <span class="keywordflow">if</span>(verifyVectorAllocation(Value.m_pValue, pFieldDescriptor))
00272             {
00273                 <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> Ix = 0; Ix &lt; nValue; Ix++)
00274                 {
00275                     Value.m_pValue[Ix] = m_pDecoder-&gt;next_u16();
00276                 }
00277             }
00278         }
00279     }
00280 
00281     <span class="keywordflow">return</span> Value;
00282 }
00283 
00284 llrp_s16v_t
00285 CFrameDecoderStream::get_s16v (
00286   <span class="keyword">const</span> CFieldDescriptor *      pFieldDescriptor)
00287 {
00288     llrp_u16_t                  nValue;
00289     llrp_s16v_t                 Value;
00290 
00291     nValue = getVarlenCount(pFieldDescriptor);
00292 
00293     <span class="keywordflow">if</span>(0 &lt; nValue)
00294     {
00295         <span class="keywordflow">if</span>(checkAvailable(2u * nValue, pFieldDescriptor))
00296         {
00297             Value = llrp_s16v_t(nValue);
00298             <span class="keywordflow">if</span>(verifyVectorAllocation(Value.m_pValue, pFieldDescriptor))
00299             {
00300                 <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> Ix = 0; Ix &lt; nValue; Ix++)
00301                 {
00302                     Value.m_pValue[Ix] = m_pDecoder-&gt;next_u16();
00303                 }
00304             }
00305         }
00306     }
00307 
00308     <span class="keywordflow">return</span> Value;
00309 }
00310 
00311 
00312 
00313 llrp_u32_t
00314 CFrameDecoderStream::get_u32 (
00315   <span class="keyword">const</span> CFieldDescriptor *      pFieldDescriptor)
00316 {
00317     llrp_u32_t                  Value;
00318 
00319     <span class="keywordflow">if</span>(checkAvailable(4u, pFieldDescriptor))
00320     {
00321         Value = m_pDecoder-&gt;next_u32();
00322     }
00323     <span class="keywordflow">else</span>
00324     {
00325         Value = 0;
00326     }
00327 
00328     <span class="keywordflow">return</span> Value;
00329 }
00330 
00331 llrp_s32_t
00332 CFrameDecoderStream::get_s32 (
00333   <span class="keyword">const</span> CFieldDescriptor *      pFieldDescriptor)
00334 {
00335     llrp_s32_t                  Value;
00336 
00337     <span class="keywordflow">if</span>(checkAvailable(4u, pFieldDescriptor))
00338     {
00339         Value = m_pDecoder-&gt;next_u32();
00340     }
00341     <span class="keywordflow">else</span>
00342     {
00343         Value = 0;
00344     }
00345 
00346     <span class="keywordflow">return</span> Value;
00347 }
00348 
00349 llrp_u32v_t
00350 CFrameDecoderStream::get_u32v (
00351   <span class="keyword">const</span> CFieldDescriptor *      pFieldDescriptor)
00352 {
00353     llrp_u16_t                  nValue;
00354     llrp_u32v_t                 Value;
00355 
00356     nValue = getVarlenCount(pFieldDescriptor);
00357 
00358     <span class="keywordflow">if</span>(0 &lt; nValue)
00359     {
00360         <span class="keywordflow">if</span>(checkAvailable(4u * nValue, pFieldDescriptor))
00361         {
00362             Value = llrp_u32v_t(nValue);
00363             <span class="keywordflow">if</span>(verifyVectorAllocation(Value.m_pValue, pFieldDescriptor))
00364             {
00365                 <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> Ix = 0; Ix &lt; nValue; Ix++)
00366                 {
00367                     Value.m_pValue[Ix] = m_pDecoder-&gt;next_u32();
00368                 }
00369             }
00370         }
00371     }
00372 
00373     <span class="keywordflow">return</span> Value;
00374 }
00375 
00376 llrp_s32v_t
00377 CFrameDecoderStream::get_s32v (
00378   <span class="keyword">const</span> CFieldDescriptor *      pFieldDescriptor)
00379 {
00380     llrp_u16_t                  nValue;
00381     llrp_s32v_t                 Value;
00382 
00383     nValue = getVarlenCount(pFieldDescriptor);
00384 
00385     <span class="keywordflow">if</span>(0 &lt; nValue)
00386     {
00387         <span class="keywordflow">if</span>(checkAvailable(4u * nValue, pFieldDescriptor))
00388         {
00389             Value = llrp_s32v_t(nValue);
00390             <span class="keywordflow">if</span>(verifyVectorAllocation(Value.m_pValue, pFieldDescriptor))
00391             {
00392                 <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> Ix = 0; Ix &lt; nValue; Ix++)
00393                 {
00394                     Value.m_pValue[Ix] = m_pDecoder-&gt;next_u32();
00395                 }
00396             }
00397         }
00398     }
00399 
00400     <span class="keywordflow">return</span> Value;
00401 }
00402 
00403 
00404 llrp_u64_t
00405 CFrameDecoderStream::get_u64 (
00406   <span class="keyword">const</span> CFieldDescriptor *      pFieldDescriptor)
00407 {
00408     llrp_u64_t                  Value;
00409 
00410     <span class="keywordflow">if</span>(checkAvailable(8u, pFieldDescriptor))
00411     {
00412         Value = m_pDecoder-&gt;next_u64();
00413     }
00414     <span class="keywordflow">else</span>
00415     {
00416         Value = 0;
00417     }
00418 
00419     <span class="keywordflow">return</span> Value;
00420 }
00421 
00422 llrp_s64_t
00423 CFrameDecoderStream::get_s64 (
00424   <span class="keyword">const</span> CFieldDescriptor *      pFieldDescriptor)
00425 {
00426     llrp_s64_t                  Value;
00427 
00428     <span class="keywordflow">if</span>(checkAvailable(8u, pFieldDescriptor))
00429     {
00430         Value = m_pDecoder-&gt;next_u64();
00431     }
00432     <span class="keywordflow">else</span>
00433     {
00434         Value = 0;
00435     }
00436 
00437     <span class="keywordflow">return</span> Value;
00438 }
00439 
00440 llrp_u64v_t
00441 CFrameDecoderStream::get_u64v (
00442   <span class="keyword">const</span> CFieldDescriptor *      pFieldDescriptor)
00443 {
00444     llrp_u16_t                  nValue;
00445     llrp_u64v_t                 Value;
00446 
00447     nValue = getVarlenCount(pFieldDescriptor);
00448 
00449     <span class="keywordflow">if</span>(0 &lt; nValue)
00450     {
00451         <span class="keywordflow">if</span>(checkAvailable(8u * nValue, pFieldDescriptor))
00452         {
00453             Value = llrp_u64v_t(nValue);
00454             <span class="keywordflow">if</span>(verifyVectorAllocation(Value.m_pValue, pFieldDescriptor))
00455             {
00456                 <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> Ix = 0; Ix &lt; nValue; Ix++)
00457                 {
00458                     Value.m_pValue[Ix] = m_pDecoder-&gt;next_u64();
00459                 }
00460             }
00461         }
00462     }
00463 
00464     <span class="keywordflow">return</span> Value;
00465 }
00466 
00467 llrp_s64v_t
00468 CFrameDecoderStream::get_s64v (
00469   <span class="keyword">const</span> CFieldDescriptor *      pFieldDescriptor)
00470 {
00471     llrp_u16_t                  nValue;
00472     llrp_s64v_t                 Value;
00473 
00474     nValue = getVarlenCount(pFieldDescriptor);
00475 
00476     <span class="keywordflow">if</span>(0 &lt; nValue)
00477     {
00478         <span class="keywordflow">if</span>(checkAvailable(8u * nValue, pFieldDescriptor))
00479         {
00480             Value = llrp_s64v_t(nValue);
00481             <span class="keywordflow">if</span>(verifyVectorAllocation(Value.m_pValue, pFieldDescriptor))
00482             {
00483                 <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> Ix = 0; Ix &lt; nValue; Ix++)
00484                 {
00485                     Value.m_pValue[Ix] = m_pDecoder-&gt;next_u64();
00486                 }
00487             }
00488         }
00489     }
00490 
00491     <span class="keywordflow">return</span> Value;
00492 }
00493 
00494 llrp_u1_t
00495 CFrameDecoderStream::get_u1 (
00496   <span class="keyword">const</span> CFieldDescriptor *      pFieldDescriptor)
00497 {
00498     llrp_u1_t                   Value;
00499 
00500     Value = getBitField(1, pFieldDescriptor);
00501 
00502     <span class="keywordflow">return</span> Value;
00503 }
00504 
00505 llrp_u1v_t
00506 CFrameDecoderStream::get_u1v (
00507   <span class="keyword">const</span> CFieldDescriptor *      pFieldDescriptor)
00508 {
00509     llrp_u16_t                  nBit;
00510     llrp_u1v_t                  Value;
00511 
00512     nBit = getVarlenCount(pFieldDescriptor);
00513 
00514     <span class="keywordflow">if</span>(0 &lt; nBit)
00515     {
00516         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>                nByte = (nBit + 7u) / 8u;
00517 
00518         <span class="keywordflow">if</span>(checkAvailable(nByte, pFieldDescriptor))
00519         {
00520             Value = llrp_u1v_t(nBit);
00521             <span class="keywordflow">if</span>(verifyVectorAllocation(Value.m_pValue, pFieldDescriptor))
00522             {
00523                 <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> Ix = 0; Ix &lt; nByte; Ix++)
00524                 {
00525                     Value.m_pValue[Ix] = m_pDecoder-&gt;next_u8();
00526                 }
00527             }
00528         }
00529     }
00530 
00531     <span class="keywordflow">return</span> Value;
00532 }
00533 
00534 llrp_u2_t
00535 CFrameDecoderStream::get_u2 (
00536   <span class="keyword">const</span> CFieldDescriptor *      pFieldDescriptor)
00537 {
00538     llrp_u2_t                   Value;
00539 
00540     Value = getBitField(2, pFieldDescriptor);
00541 
00542     <span class="keywordflow">return</span> Value;
00543 }
00544 
00545 llrp_u96_t
00546 CFrameDecoderStream::get_u96 (
00547   <span class="keyword">const</span> CFieldDescriptor *      pFieldDescriptor)
00548 {
00549     llrp_u96_t                  Value;
00550 
00551     <span class="keywordflow">if</span>(checkAvailable(12u, pFieldDescriptor))
00552     {
00553         <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> Ix = 0; Ix &lt; 12u; Ix++)
00554         {
00555             Value.m_aValue[Ix] = m_pDecoder-&gt;next_u8();
00556         }
00557     }
00558 
00559     <span class="keywordflow">return</span> Value;
00560 }
00561 
00562 llrp_utf8v_t
00563 CFrameDecoderStream::get_utf8v (
00564   <span class="keyword">const</span> CFieldDescriptor *      pFieldDescriptor)
00565 {
00566     llrp_u16_t                  nValue;
00567     llrp_utf8v_t                Value;
00568 
00569     nValue = getVarlenCount(pFieldDescriptor);
00570 
00571     <span class="keywordflow">if</span>(0 &lt; nValue)
00572     {
00573         <span class="keywordflow">if</span>(checkAvailable(1u * nValue, pFieldDescriptor))
00574         {
00575             Value = llrp_utf8v_t(nValue);
00576             <span class="keywordflow">if</span>(verifyVectorAllocation(Value.m_pValue, pFieldDescriptor))
00577             {
00578                 <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> Ix = 0; Ix &lt; nValue; Ix++)
00579                 {
00580                     Value.m_pValue[Ix] = m_pDecoder-&gt;next_u8();
00581                 }
00582             }
00583         }
00584     }
00585 
00586     <span class="keywordflow">return</span> Value;
00587 }
00588 
00589 llrp_bytesToEnd_t
00590 CFrameDecoderStream::get_bytesToEnd (
00591   <span class="keyword">const</span> CFieldDescriptor *      pFieldDescriptor)
00592 {
00593     llrp_u16_t                  nValue;
00594     llrp_bytesToEnd_t           Value;
00595 
00596     nValue = getRemainingByteCount();
00597 
00598     <span class="keywordflow">if</span>(0 &lt; nValue)
00599     {
00600         <span class="keywordflow">if</span>(checkAvailable(1u * nValue, pFieldDescriptor))
00601         {
00602             Value = llrp_bytesToEnd_t(nValue);
00603             <span class="keywordflow">if</span>(verifyVectorAllocation(Value.m_pValue, pFieldDescriptor))
00604             {
00605                 <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> Ix = 0; Ix &lt; nValue; Ix++)
00606                 {
00607                     Value.m_pValue[Ix] = m_pDecoder-&gt;next_u8();
00608                 }
00609             }
00610         }
00611     }
00612 
00613     <span class="keywordflow">return</span> Value;
00614 }
00615 
00616 <span class="keywordtype">int</span>
00617 CFrameDecoderStream::get_e1 (
00618   <span class="keyword">const</span> CFieldDescriptor *      pFieldDescriptor)
00619 {
00620     <span class="keywordtype">int</span>                         eValue;
00621 
00622     eValue = (int)get_u1(pFieldDescriptor);
00623 
00624     <span class="keywordflow">return</span> eValue;
00625 }
00626 
00627 <span class="keywordtype">int</span>
00628 CFrameDecoderStream::get_e2 (
00629   <span class="keyword">const</span> CFieldDescriptor *      pFieldDescriptor)
00630 {
00631     <span class="keywordtype">int</span>                         eValue;
00632 
00633     eValue = (int)get_u2(pFieldDescriptor);
00634 
00635     <span class="keywordflow">return</span> eValue;
00636 }
00637 
00638 <span class="keywordtype">int</span>
00639 CFrameDecoderStream::get_e8 (
00640   <span class="keyword">const</span> CFieldDescriptor *      pFieldDescriptor)
00641 {
00642     <span class="keywordtype">int</span>                         eValue;
00643 
00644     eValue = (int)get_u8(pFieldDescriptor);
00645 
00646     <span class="keywordflow">return</span> eValue;
00647 }
00648 
00649 <span class="keywordtype">int</span>
00650 CFrameDecoderStream::get_e16 (
00651   <span class="keyword">const</span> CFieldDescriptor *      pFieldDescriptor)
00652 {
00653     <span class="keywordtype">int</span>                         eValue;
00654 
00655     eValue = (int)get_u16(pFieldDescriptor);
00656 
00657     <span class="keywordflow">return</span> eValue;
00658 }
00659 
00660 <span class="keywordtype">int</span>
00661 CFrameDecoderStream::get_e32 (
00662   <span class="keyword">const</span> CFieldDescriptor *      pFieldDescriptor)
00663 {
00664     <span class="keywordtype">int</span>                         eValue;
00665 
00666     eValue = (int)get_u32(pFieldDescriptor);
00667 
00668     <span class="keywordflow">return</span> eValue;
00669 }
00670 
00671 llrp_u8v_t
00672 CFrameDecoderStream::get_e8v (
00673   <span class="keyword">const</span> CFieldDescriptor *      pFieldDescriptor)
00674 {
00675     <span class="keywordflow">return</span> get_u8v(pFieldDescriptor);
00676 }
00677 
00678 <span class="keywordtype">void</span>
00679 CFrameDecoderStream::get_reserved (
00680   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>                  nBit)
00681 {
00682     <a class="code" href="classLLRP_1_1CErrorDetails.html#a0">CErrorDetails</a> *             pError = &amp;m_pDecoder-&gt;m_ErrorDetails;
00683 
00684     <span class="keywordflow">if</span>(<a class="code" href="namespaceLLRP.html#a333a251">RC_OK</a> != pError-&gt;m_eResultCode)
00685     {
00686         <span class="keywordflow">return</span>;
00687     }
00688 
00689     <span class="keywordflow">while</span>(0 &lt; nBit)
00690     {
00691         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>            Step = 7u &amp; nBit;
00692 
00693         <span class="keywordflow">if</span>(0 != m_pDecoder-&gt;m_nBitFieldResid)
00694         {
00695             <span class="keywordflow">if</span>(Step != m_pDecoder-&gt;m_nBitFieldResid)
00696             {
00697                 pError-&gt;m_eResultCode = RC_UnalignedReservedBits;
00698                 pError-&gt;m_pWhatStr    = <span class="stringliteral">"unaligned reserved bits"</span>;
00699                 pError-&gt;m_pRefType    = m_pRefType;
00700                 pError-&gt;m_pRefField   = NULL;
00701                 pError-&gt;m_OtherDetail = m_pDecoder-&gt;m_iNext;
00702                 <span class="keywordflow">return</span>;
00703             }
00704 
00705             nBit -= Step;
00706             m_pDecoder-&gt;m_nBitFieldResid = 0;
00707         }
00708         <span class="keywordflow">else</span>
00709         {
00710             <span class="keywordflow">if</span>(0 != Step)
00711             {
00712                 pError-&gt;m_eResultCode = RC_UnalignedReservedBits;
00713                 pError-&gt;m_pWhatStr    = <span class="stringliteral">"unaligned reserved bits"</span>;
00714                 pError-&gt;m_pRefType    = m_pRefType;
00715                 pError-&gt;m_pRefField   = NULL;
00716                 pError-&gt;m_OtherDetail = m_pDecoder-&gt;m_iNext;
00717                 <span class="keywordflow">return</span>;
00718             }
00719 
00720             <span class="keywordflow">if</span>(m_pDecoder-&gt;m_iNext &gt;= m_iLimit)
00721             {
00722                 pError-&gt;m_eResultCode = RC_ReservedBitsUnderrun;
00723                 pError-&gt;m_pWhatStr    = <span class="stringliteral">"underrun at reserved bits"</span>;
00724                 pError-&gt;m_pRefType    = m_pRefType;
00725                 pError-&gt;m_pRefField   = NULL;
00726                 pError-&gt;m_OtherDetail = m_pDecoder-&gt;m_iNext;
00727                 <span class="keywordflow">return</span>;
00728             }
00729 
00730             m_pDecoder-&gt;next_u8();
00731             nBit -= 8;
00732         }
00733     }
00734 }
00735 
00736 CFrameDecoderStream::CFrameDecoderStream (
00737   CFrameDecoder *               pDecoder)
00738 {
00739     m_pDecoder                  = pDecoder;
00740     m_pEnclosingDecoderStream   = NULL;
00741     m_iBegin                    = pDecoder-&gt;m_iNext;
00742     m_iLimit                    = pDecoder-&gt;m_nBuffer;
00743     <a class="code" href="classLLRP_1_1CErrorDetails.html#o2">m_pRefType</a>                  = NULL;
00744 }
00745 
00746 CFrameDecoderStream::CFrameDecoderStream (
00747   CFrameDecoderStream *         pEnclosingDecoderStream)
00748 {
00749     m_pDecoder                  = pEnclosingDecoderStream-&gt;m_pDecoder;
00750     m_pEnclosingDecoderStream   = pEnclosingDecoderStream;
00751     m_iBegin                    = m_pDecoder-&gt;m_iNext;
00752     m_iLimit                    = pEnclosingDecoderStream-&gt;m_iLimit;
00753     <a class="code" href="classLLRP_1_1CErrorDetails.html#o2">m_pRefType</a>                  = NULL;
00754 }
00755 
00756 CMessage *
00757 CFrameDecoderStream::getMessage (<span class="keywordtype">void</span>)
00758 {
00759     <a class="code" href="classLLRP_1_1CErrorDetails.html#a0">CErrorDetails</a> *             pError = &amp;m_pDecoder-&gt;m_ErrorDetails;
00760     <span class="keyword">const</span> CTypeRegistry *       pRegistry = m_pDecoder-&gt;m_pRegistry;
00761     <span class="keyword">const</span> CTypeDescriptor *     pTypeDescriptor = NULL;
00762     llrp_u16_t                  Type;
00763     llrp_u16_t                  Vers;
00764     llrp_u32_t                  nLength;
00765     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>                iLimit;
00766     llrp_u32_t                  MessageID;
00767 
00768     <span class="keywordflow">if</span>(<a class="code" href="namespaceLLRP.html#a333a251">RC_OK</a> != pError-&gt;m_eResultCode)
00769     {
00770         <span class="keywordflow">return</span> NULL;
00771     }
00772 
00773     Type = get_u16(&amp;g_fdMessageHeader_Type);
00774     Vers = (Type &gt;&gt; 10) &amp; 3;
00775     Type &amp;= 0x3FF;
00776 
00777     <span class="keywordflow">if</span>(<a class="code" href="namespaceLLRP.html#a333a251">RC_OK</a> != pError-&gt;m_eResultCode)
00778     {
00779         <span class="keywordflow">return</span> NULL;
00780     }
00781 
00782     <span class="keywordflow">if</span>(1u != Vers)
00783     {
00784         pError-&gt;m_eResultCode = RC_BadVersion;
00785         pError-&gt;m_pWhatStr    = <span class="stringliteral">"unsupported version"</span>;
00786         pError-&gt;m_pRefType    = NULL;
00787         pError-&gt;m_pRefField   = &amp;g_fdMessageHeader_Type;
00788         pError-&gt;m_OtherDetail = m_pDecoder-&gt;m_iNext;
00789         <span class="keywordflow">return</span> NULL;
00790     }
00791 
00792     nLength = get_u32(&amp;g_fdMessageHeader_Length);
00793 
00794     <span class="keywordflow">if</span>(<a class="code" href="namespaceLLRP.html#a333a251">RC_OK</a> != pError-&gt;m_eResultCode)
00795     {
00796         <span class="keywordflow">return</span> NULL;
00797     }
00798 
00799     <span class="keywordflow">if</span>(10u &gt; nLength)
00800     {
00801         pError-&gt;m_eResultCode = RC_InvalidLength;
00802         pError-&gt;m_pWhatStr    = <span class="stringliteral">"message length too small"</span>;
00803         pError-&gt;m_pRefType    = NULL;
00804         pError-&gt;m_pRefField   = &amp;g_fdMessageHeader_Length;
00805         pError-&gt;m_OtherDetail = m_pDecoder-&gt;m_iNext;
00806         <span class="keywordflow">return</span> NULL;
00807     }
00808 
00809     iLimit = m_iBegin + nLength;
00810 
00811     <span class="keywordflow">if</span>(iLimit &gt; m_iLimit)
00812     {
00813         pError-&gt;m_eResultCode = RC_ExcessiveLength;
00814         pError-&gt;m_pWhatStr    = <span class="stringliteral">"message length exceeds enclosing length"</span>;
00815         pError-&gt;m_pRefType    = NULL;
00816         pError-&gt;m_pRefField   = &amp;g_fdMessageHeader_Length;
00817         pError-&gt;m_OtherDetail = m_pDecoder-&gt;m_iNext;
00818         <span class="keywordflow">return</span> NULL;
00819     }
00820 
00821     m_iLimit = iLimit;
00822 
00823     MessageID = get_u32(&amp;g_fdMessageHeader_MessageID);
00824 
00825     <span class="keywordflow">if</span>(<a class="code" href="namespaceLLRP.html#a333a251">RC_OK</a> != pError-&gt;m_eResultCode)
00826     {
00827         <span class="keywordflow">return</span> NULL;
00828     }
00829 
00830     <span class="comment">/* Custom? */</span>
00831     <span class="keywordflow">if</span>(1023u == Type)
00832     {
00833         llrp_u32_t              VendorPEN;
00834         llrp_u8_t               Subtype;
00835 
00836         VendorPEN = get_u32(&amp;g_fdMessageHeader_VendorPEN);
00837         Subtype   = get_u8(&amp;g_fdMessageHeader_Subtype);
00838 
00839         <span class="keywordflow">if</span>(<a class="code" href="namespaceLLRP.html#a333a251">RC_OK</a> != pError-&gt;m_eResultCode)
00840         {
00841             <span class="keywordflow">return</span> NULL;
00842         }
00843 
00844         pTypeDescriptor = pRegistry-&gt;lookupCustomMessage(VendorPEN, Subtype);
00845         <span class="keywordflow">if</span>(NULL == pTypeDescriptor)
00846         {
00847             <span class="comment">/*</span>
00848 <span class="comment">             * If we don't have a definition for a particular</span>
00849 <span class="comment">             * CUSTOM message, just use the generic one.</span>
00850 <span class="comment">             */</span>
00851             m_pDecoder-&gt;m_iNext -= 5;   <span class="comment">/* back up to VendorPEN and SubType */</span>
00852             pTypeDescriptor = pRegistry-&gt;lookupMessage(1023u);
00853         }
00854     }
00855     <span class="keywordflow">else</span>
00856     {
00857         pTypeDescriptor = pRegistry-&gt;lookupMessage(Type);
00858     }
00859 
00860     <span class="keywordflow">if</span>(NULL == pTypeDescriptor)
00861     {
00862         pError-&gt;m_eResultCode = RC_UnknownMessageType;
00863         pError-&gt;m_pWhatStr    = <span class="stringliteral">"unknown message type"</span>;
00864         pError-&gt;m_pRefType    = NULL;
00865         pError-&gt;m_pRefField   = &amp;g_fdMessageHeader_Type;
00866         pError-&gt;m_OtherDetail = 0;
00867         <span class="keywordflow">return</span> NULL;
00868     }
00869 
00870     <a class="code" href="classLLRP_1_1CErrorDetails.html#o2">m_pRefType</a> = pTypeDescriptor;
00871 
00872     CMessage *                  pMessage;
00873 
00874     pMessage = (CMessage *) pTypeDescriptor-&gt;constructElement();
00875 
00876     <span class="keywordflow">if</span>(NULL == pMessage)
00877     {
00878         pError-&gt;m_eResultCode = RC_MessageAllocationFailed;
00879         pError-&gt;m_pWhatStr    = <span class="stringliteral">"message allocation failed"</span>;
00880         pError-&gt;m_pRefType    = pTypeDescriptor;
00881         pError-&gt;m_pRefField   = NULL;
00882         pError-&gt;m_OtherDetail = m_pDecoder-&gt;m_iNext;
00883         <span class="keywordflow">return</span> NULL;
00884     }
00885 
00886     pMessage-&gt;setMessageID(MessageID);
00887 
00888     pMessage-&gt;decodeFields(<span class="keyword">this</span>);
00889 
00890     <span class="keywordflow">if</span>(<a class="code" href="namespaceLLRP.html#a333a251">RC_OK</a> != pError-&gt;m_eResultCode)
00891     {
00892         <span class="keyword">delete</span> pMessage;
00893         <span class="keywordflow">return</span> NULL;
00894     }
00895 
00896     <span class="comment">/*</span>
00897 <span class="comment">     * Subparameters</span>
00898 <span class="comment">     */</span>
00899     <span class="keywordflow">while</span>(0 &lt; getRemainingByteCount() &amp;&amp;
00900           <a class="code" href="namespaceLLRP.html#a333a251">RC_OK</a> == pError-&gt;m_eResultCode)
00901     {
00902         CFrameDecoderStream         NestStream(<span class="keyword">this</span>);
00903         CParameter *                pParameter;
00904 
00905         pParameter = NestStream.getParameter();
00906 
00907         <span class="keywordflow">if</span>(NULL == pParameter)
00908         {
00909             <span class="keywordflow">if</span>(<a class="code" href="namespaceLLRP.html#a333a251">RC_OK</a> == pError-&gt;m_eResultCode)
00910             {
00911                 pError-&gt;m_eResultCode = RC_Botch;
00912                 pError-&gt;m_pWhatStr    = <span class="stringliteral">"botch -- no param and no error"</span>;
00913                 pError-&gt;m_pRefType    = pTypeDescriptor;
00914                 pError-&gt;m_pRefField   = NULL;
00915                 pError-&gt;m_OtherDetail = m_pDecoder-&gt;m_iNext;
00916             }
00917             <span class="keywordflow">break</span>;
00918         }
00919 
00920         pParameter-&gt;m_pParent = pMessage;
00921         pMessage-&gt;addSubParameterToAllList(pParameter);
00922 
00923     }
00924 
00925     <span class="keywordflow">if</span>(<a class="code" href="namespaceLLRP.html#a333a251">RC_OK</a> == pError-&gt;m_eResultCode)
00926     {
00927         <span class="keywordflow">if</span>(m_pDecoder-&gt;m_iNext != m_iLimit)
00928         {
00929             pError-&gt;m_eResultCode = RC_ExtraBytes;
00930             pError-&gt;m_pWhatStr    = <span class="stringliteral">"extra bytes at end of message"</span>;
00931             pError-&gt;m_pRefType    = pTypeDescriptor;
00932             pError-&gt;m_pRefField   = NULL;
00933             pError-&gt;m_OtherDetail = m_pDecoder-&gt;m_iNext;
00934         }
00935     }
00936 
00937     <span class="keywordflow">if</span>(<a class="code" href="namespaceLLRP.html#a333a251">RC_OK</a> != pError-&gt;m_eResultCode)
00938     {
00939         <span class="keyword">delete</span> pMessage;
00940         <span class="keywordflow">return</span> NULL;
00941     }
00942 
00943     pMessage-&gt;assimilateSubParameters(pError);
00944 
00945     <span class="keywordflow">if</span>(<a class="code" href="namespaceLLRP.html#a333a251">RC_OK</a> != pError-&gt;m_eResultCode)
00946     {
00947         <span class="keyword">delete</span> pMessage;
00948         <span class="keywordflow">return</span> NULL;
00949     }
00950 
00951     <span class="keywordflow">return</span> pMessage;
00952 }
00953 
00954 CParameter *
00955 CFrameDecoderStream::getParameter (<span class="keywordtype">void</span>)
00956 {
00957     <a class="code" href="classLLRP_1_1CErrorDetails.html#a0">CErrorDetails</a> *             pError = &amp;m_pDecoder-&gt;m_ErrorDetails;
00958     <span class="keyword">const</span> CTypeRegistry *       pRegistry = m_pDecoder-&gt;m_pRegistry;
00959     <span class="keyword">const</span> CTypeDescriptor *     pTypeDescriptor = NULL;
00960     llrp_u16_t                  Type;
00961     <span class="keywordtype">bool</span>                        bIsTV;
00962 
00963     <span class="keywordflow">if</span>(<a class="code" href="namespaceLLRP.html#a333a251">RC_OK</a> != pError-&gt;m_eResultCode)
00964     {
00965         <span class="keywordflow">return</span> NULL;
00966     }
00967 
00968     Type = get_u8(&amp;g_fdParameterHeader_TVType);
00969 
00970     <span class="keywordflow">if</span>(<a class="code" href="namespaceLLRP.html#a333a251">RC_OK</a> != pError-&gt;m_eResultCode)
00971     {
00972         <span class="keywordflow">return</span> NULL;
00973     }
00974 
00975     <span class="keywordflow">if</span>(0 != (Type&amp;0x80))
00976     {
00977         <span class="comment">/*</span>
00978 <span class="comment">         * Type-Value (TV).</span>
00979 <span class="comment">         * All we can do is inherit the length from</span>
00980 <span class="comment">         * the enclosing element.</span>
00981 <span class="comment">         */</span>
00982         Type &amp;= 0x7F;
00983         bIsTV = TRUE;
00984     }
00985     <span class="keywordflow">else</span>
00986     {
00987         <span class="comment">/*</span>
00988 <span class="comment">         * Type-Length-Value (TLV).</span>
00989 <span class="comment">         * Back up and get the real type number,</span>
00990 <span class="comment">         * then get the length.</span>
00991 <span class="comment">         */</span>
00992         m_pDecoder-&gt;m_iNext--;
00993         Type = get_u16(&amp;g_fdParameterHeader_TLVType);
00994         Type &amp;= 0x3FF;
00995 
00996         <span class="keywordflow">if</span>(<a class="code" href="namespaceLLRP.html#a333a251">RC_OK</a> != pError-&gt;m_eResultCode)
00997         {
00998             <span class="keywordflow">return</span> NULL;
00999         }
01000 
01001         llrp_u16_t              nLength;
01002 
01003         nLength = get_u16(&amp;g_fdParameterHeader_TLVLength);
01004 
01005         <span class="keywordflow">if</span>(<a class="code" href="namespaceLLRP.html#a333a251">RC_OK</a> != pError-&gt;m_eResultCode)
01006         {
01007             <span class="keywordflow">return</span> NULL;
01008         }
01009 
01010         <span class="keywordflow">if</span>(4u &gt; nLength)
01011         {
01012             pError-&gt;m_eResultCode = RC_InvalidLength;
01013             pError-&gt;m_pWhatStr    = <span class="stringliteral">"TLV parameter length too small"</span>;
01014             pError-&gt;m_pRefType    = NULL;
01015             pError-&gt;m_pRefField   = &amp;g_fdParameterHeader_TLVLength;
01016             pError-&gt;m_OtherDetail = m_pDecoder-&gt;m_iNext;
01017             <span class="keywordflow">return</span> NULL;
01018         }
01019 
01020         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>            iLimit;
01021 
01022         iLimit = m_iBegin + nLength;
01023 
01024         <span class="keywordflow">if</span>(iLimit &gt; m_iLimit)
01025         {
01026             pError-&gt;m_eResultCode = RC_ExcessiveLength;
01027             pError-&gt;m_pWhatStr    =
01028                             <span class="stringliteral">"TLV parameter length exceeds enclosing length"</span>;
01029             pError-&gt;m_pRefType    = NULL;
01030             pError-&gt;m_pRefField   = &amp;g_fdParameterHeader_TLVLength;
01031             pError-&gt;m_OtherDetail = m_pDecoder-&gt;m_iNext;
01032             <span class="keywordflow">return</span> NULL;
01033         }
01034 
01035         m_iLimit = iLimit;
01036 
01037         bIsTV = FALSE;
01038     }
01039 
01040     <span class="comment">/* Custom? */</span>
01041     <span class="keywordflow">if</span>(1023u == Type)
01042     {
01043         llrp_u32_t              VendorPEN;
01044         llrp_u32_t               Subtype;
01045 
01046         VendorPEN = get_u32(&amp;g_fdParameterHeader_VendorPEN);
01047         Subtype   = get_u32(&amp;g_fdParameterHeader_Subtype);
01048 
01049         <span class="keywordflow">if</span>(<a class="code" href="namespaceLLRP.html#a333a251">RC_OK</a> != pError-&gt;m_eResultCode)
01050         {
01051             <span class="keywordflow">return</span> NULL;
01052         }
01053 
01054         pTypeDescriptor = pRegistry-&gt;lookupCustomParameter(VendorPEN, Subtype);
01055         <span class="keywordflow">if</span>(NULL == pTypeDescriptor)
01056         {
01057             <span class="comment">/*</span>
01058 <span class="comment">             * If we don't have a definition for a particular</span>
01059 <span class="comment">             * CUSTOM message, just use the generic one.</span>
01060 <span class="comment">             */</span>
01061             m_pDecoder-&gt;m_iNext -= 8;   <span class="comment">/* back up to VendorPEN and SubType */</span>
01062             pTypeDescriptor = pRegistry-&gt;lookupParameter(1023u);
01063         }
01064     }
01065     <span class="keywordflow">else</span>
01066     {
01067         pTypeDescriptor = pRegistry-&gt;lookupParameter(Type);
01068     }
01069 
01070     <span class="keywordflow">if</span>(NULL == pTypeDescriptor)
01071     {
01072         pError-&gt;m_eResultCode = RC_UnknownParameterType;
01073         pError-&gt;m_pWhatStr    = <span class="stringliteral">"unknown parameter type"</span>;
01074         pError-&gt;m_pRefType    = NULL;
01075         <span class="keywordflow">if</span>(bIsTV)
01076         {
01077             pError-&gt;m_pRefField = &amp;g_fdParameterHeader_TVType;
01078         }
01079         <span class="keywordflow">else</span>
01080         {
01081             pError-&gt;m_pRefField = &amp;g_fdParameterHeader_TLVType;
01082         }
01083         pError-&gt;m_OtherDetail = m_pDecoder-&gt;m_iNext;
01084         <span class="keywordflow">return</span> NULL;
01085     }
01086 
01087     <a class="code" href="classLLRP_1_1CErrorDetails.html#o2">m_pRefType</a> = pTypeDescriptor;
01088 
01089     CParameter *                pParameter;
01090 
01091     pParameter = (CParameter *) pTypeDescriptor-&gt;constructElement();
01092 
01093     <span class="keywordflow">if</span>(NULL == pParameter)
01094     {
01095         pError-&gt;m_eResultCode = RC_ParameterAllocationFailed;
01096         pError-&gt;m_pWhatStr    = <span class="stringliteral">"parameter allocation failed"</span>;
01097         pError-&gt;m_pRefType    = pTypeDescriptor;
01098         pError-&gt;m_pRefField   = NULL;
01099         pError-&gt;m_OtherDetail = m_pDecoder-&gt;m_iNext;
01100         <span class="keywordflow">return</span> NULL;
01101     }
01102 
01103     pParameter-&gt;decodeFields(<span class="keyword">this</span>);
01104 
01105     <span class="keywordflow">if</span>(<a class="code" href="namespaceLLRP.html#a333a251">RC_OK</a> != pError-&gt;m_eResultCode)
01106     {
01107         <span class="keyword">delete</span> pParameter;
01108         <span class="keywordflow">return</span> NULL;
01109     }
01110 
01111     <span class="keywordflow">if</span>(!bIsTV)
01112     {
01113         <span class="comment">/*</span>
01114 <span class="comment">         * Subparameters</span>
01115 <span class="comment">         */</span>
01116         <span class="keywordflow">while</span>(0 &lt; getRemainingByteCount() &amp;&amp;
01117           <a class="code" href="namespaceLLRP.html#a333a251">RC_OK</a> == pError-&gt;m_eResultCode)
01118         {
01119             CFrameDecoderStream         NestStream(<span class="keyword">this</span>);
01120             CParameter *                pSubParameter;
01121 
01122             pSubParameter = NestStream.getParameter();
01123 
01124             <span class="keywordflow">if</span>(NULL == pSubParameter)
01125             {
01126                 <span class="keywordflow">if</span>(<a class="code" href="namespaceLLRP.html#a333a251">RC_OK</a> == pError-&gt;m_eResultCode)
01127                 {
01128                     pError-&gt;m_eResultCode = RC_Botch;
01129                     pError-&gt;m_pWhatStr    = <span class="stringliteral">"botch -- no param and no error"</span>;
01130                     pError-&gt;m_pRefType    = pTypeDescriptor;
01131                     pError-&gt;m_pRefField   = NULL;
01132                     pError-&gt;m_OtherDetail = m_pDecoder-&gt;m_iNext;
01133                 }
01134                 <span class="keywordflow">break</span>;
01135             }
01136 
01137             pSubParameter-&gt;m_pParent = pParameter;
01138             pParameter-&gt;addSubParameterToAllList(pSubParameter);
01139         }
01140 
01141         <span class="keywordflow">if</span>(<a class="code" href="namespaceLLRP.html#a333a251">RC_OK</a> == pError-&gt;m_eResultCode)
01142         {
01143             <span class="keywordflow">if</span>(m_pDecoder-&gt;m_iNext != m_iLimit)
01144             {
01145                 pError-&gt;m_eResultCode = RC_ExtraBytes;
01146                 pError-&gt;m_pWhatStr    = <span class="stringliteral">"extra bytes at end of TLV parameter"</span>;
01147                 pError-&gt;m_pRefType    = pTypeDescriptor;
01148                 pError-&gt;m_pRefField   = NULL;
01149                 pError-&gt;m_OtherDetail = m_pDecoder-&gt;m_iNext;
01150             }
01151         }
01152 
01153         <span class="keywordflow">if</span>(<a class="code" href="namespaceLLRP.html#a333a251">RC_OK</a> != pError-&gt;m_eResultCode)
01154         {
01155             <span class="keyword">delete</span> pParameter;
01156             <span class="keywordflow">return</span> NULL;
01157         }
01158 
01159         pParameter-&gt;assimilateSubParameters(pError);
01160 
01161         <span class="keywordflow">if</span>(<a class="code" href="namespaceLLRP.html#a333a251">RC_OK</a> != pError-&gt;m_eResultCode)
01162         {
01163             <span class="keyword">delete</span> pParameter;
01164             <span class="keywordflow">return</span> NULL;
01165         }
01166     }
01167 
01168     <span class="keywordflow">return</span> pParameter;
01169 }
01170 
01171 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>
01172 CFrameDecoderStream::getRemainingByteCount (<span class="keywordtype">void</span>)
01173 {
01174     <span class="keywordflow">if</span>(m_pDecoder-&gt;m_iNext &lt; m_iLimit)
01175     {
01176         <span class="keywordflow">return</span> m_iLimit - m_pDecoder-&gt;m_iNext;
01177     }
01178     <span class="keywordflow">else</span>
01179     {
01180         <span class="keywordflow">return</span> 0;
01181     }
01182 }
01183 
01184 llrp_bool_t
01185 CFrameDecoderStream::checkAvailable (
01186   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>                  nByte,
01187   <span class="keyword">const</span> CFieldDescriptor *      pFieldDescriptor)
01188 {
01189     <a class="code" href="classLLRP_1_1CErrorDetails.html#a0">CErrorDetails</a> *             pError = &amp;m_pDecoder-&gt;m_ErrorDetails;
01190 
01191     <span class="keywordflow">if</span>(<a class="code" href="namespaceLLRP.html#a333a251">RC_OK</a> != pError-&gt;m_eResultCode)
01192     {
01193         <span class="keywordflow">return</span> FALSE;
01194     }
01195 
01196     <span class="keywordflow">if</span>(m_pDecoder-&gt;m_iNext + nByte &gt; m_iLimit)
01197     {
01198         pError-&gt;m_eResultCode = RC_FieldUnderrun;
01199         pError-&gt;m_pWhatStr    = <span class="stringliteral">"underrun at field"</span>;
01200         pError-&gt;m_pRefType    = m_pRefType;
01201         pError-&gt;m_pRefField   = pFieldDescriptor;
01202         pError-&gt;m_OtherDetail = m_pDecoder-&gt;m_iNext;
01203         <span class="keywordflow">return</span> FALSE;
01204     }
01205 
01206     <span class="keywordflow">if</span>(0 != m_pDecoder-&gt;m_nBitFieldResid)
01207     {
01208         pError-&gt;m_eResultCode = RC_UnalignedBitField;
01209         pError-&gt;m_pWhatStr    = <span class="stringliteral">"unaligned/incomplete bit field"</span>;
01210         pError-&gt;m_pRefType    = m_pRefType;
01211         pError-&gt;m_pRefField   = pFieldDescriptor;
01212         pError-&gt;m_OtherDetail = m_pDecoder-&gt;m_iNext;
01213         <span class="keywordflow">return</span> FALSE;
01214     }
01215 
01216     <span class="keywordflow">return</span> TRUE;
01217 }
01218 
01219 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>
01220 CFrameDecoderStream::getBitField (
01221   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>                  nBit,
01222   <span class="keyword">const</span> CFieldDescriptor *      pFieldDescriptor)
01223 {
01224     <a class="code" href="classLLRP_1_1CErrorDetails.html#a0">CErrorDetails</a> *             pError = &amp;m_pDecoder-&gt;m_ErrorDetails;
01225     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>                Value;
01226 
01227     <span class="keywordflow">if</span>(0 == m_pDecoder-&gt;m_nBitFieldResid)
01228     {
01229         <span class="keywordflow">if</span>(checkAvailable(1u, pFieldDescriptor))
01230         {
01231             m_pDecoder-&gt;m_BitFieldBuffer = m_pDecoder-&gt;next_u8();
01232             m_pDecoder-&gt;m_nBitFieldResid = 8u;
01233         }
01234         <span class="keywordflow">else</span>
01235         {
01236             <span class="keywordflow">return</span> 0;
01237         }
01238     }
01239 
01240     <span class="keywordflow">if</span>(m_pDecoder-&gt;m_nBitFieldResid &lt; nBit)
01241     {
01242         pError-&gt;m_eResultCode = RC_UnalignedBitField;
01243         pError-&gt;m_pWhatStr    = <span class="stringliteral">"unaligned/incomplete bit field"</span>;
01244         pError-&gt;m_pRefType    = m_pRefType;
01245         pError-&gt;m_pRefField   = pFieldDescriptor;
01246         pError-&gt;m_OtherDetail = m_pDecoder-&gt;m_iNext;
01247         <span class="keywordflow">return</span> 0;
01248     }
01249 
01250     m_pDecoder-&gt;m_nBitFieldResid -= nBit;
01251 
01252     Value = m_pDecoder-&gt;m_BitFieldBuffer &gt;&gt; m_pDecoder-&gt;m_nBitFieldResid;
01253     Value &amp;= (1u &lt;&lt; nBit) - 1u;
01254 
01255     <span class="keywordflow">return</span> Value;
01256 }
01257 
01258 llrp_u16_t
01259 CFrameDecoderStream::getVarlenCount (
01260   <span class="keyword">const</span> CFieldDescriptor *      pFieldDescriptor)
01261 {
01262     llrp_u16_t                  nValue;
01263 
01264     <span class="keywordflow">if</span>(checkAvailable(2u, pFieldDescriptor))
01265     {
01266         nValue = m_pDecoder-&gt;next_u16();
01267     }
01268     <span class="keywordflow">else</span>
01269     {
01270         nValue = 0;
01271     }
01272 
01273     <span class="keywordflow">return</span> nValue;
01274 }
01275 
01276 llrp_bool_t
01277 CFrameDecoderStream::verifyVectorAllocation (
01278   <span class="keyword">const</span> <span class="keywordtype">void</span> *              pValue,
01279   <span class="keyword">const</span> CFieldDescriptor *  pFieldDescriptor)
01280 {
01281     <span class="keywordflow">if</span>(NULL == pValue)
01282     {
01283         <a class="code" href="classLLRP_1_1CErrorDetails.html#a0">CErrorDetails</a> *     pError = &amp;m_pDecoder-&gt;m_ErrorDetails;
01284 
01285         pError-&gt;m_eResultCode = RC_FieldAllocationFailed;
01286         pError-&gt;m_pWhatStr    = <span class="stringliteral">"field allocation failed"</span>;
01287         pError-&gt;m_pRefType    = m_pRefType;
01288         pError-&gt;m_pRefField   = pFieldDescriptor;
01289         pError-&gt;m_OtherDetail = m_pDecoder-&gt;m_iNext;
01290 
01291         <span class="keywordflow">return</span> FALSE;
01292     }
01293     <span class="keywordflow">else</span>
01294     {
01295         <span class="keywordflow">return</span> TRUE;
01296     }
01297 }
01298 
01299 };  <span class="comment">/* namespace LLRP */</span>
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Wed Feb 24 09:16:21 2010 for LTKCPP-- LLRP Toolkit C Plus Plus Library by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.3.9.1 </small></address>
</body>
</html>
