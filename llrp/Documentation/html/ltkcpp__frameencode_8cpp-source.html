<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>LTKCPP-- LLRP Toolkit C Plus Plus Library: ltkcpp_frameencode.cpp Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.9.1 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="namespacemembers.html">Namespace&nbsp;Members</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a></div>
<div class="nav">
<a class="el" href="dir_000002.html">Library</a></div>
<h1>ltkcpp_frameencode.cpp</h1><div class="fragment"><pre class="fragment">00001 
00002 <span class="comment">/*</span>
00003 <span class="comment"> ***************************************************************************</span>
00004 <span class="comment"> *  Copyright 2007,2008 Impinj, Inc.</span>
00005 <span class="comment"> *</span>
00006 <span class="comment"> *  Licensed under the Apache License, Version 2.0 (the "License");</span>
00007 <span class="comment"> *  you may not use this file except in compliance with the License.</span>
00008 <span class="comment"> *  You may obtain a copy of the License at</span>
00009 <span class="comment"> *</span>
00010 <span class="comment"> *      http://www.apache.org/licenses/LICENSE-2.0</span>
00011 <span class="comment"> *</span>
00012 <span class="comment"> *  Unless required by applicable law or agreed to in writing, software</span>
00013 <span class="comment"> *  distributed under the License is distributed on an "AS IS" BASIS,</span>
00014 <span class="comment"> *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
00015 <span class="comment"> *  See the License for the specific language governing permissions and</span>
00016 <span class="comment"> *  limitations under the License.</span>
00017 <span class="comment"> *</span>
00018 <span class="comment"> ***************************************************************************</span>
00019 <span class="comment"> */</span>
00020 
00021 
00022 <span class="preprocessor">#include &lt;assert.h&gt;</span>
00023 
00024 <span class="preprocessor">#include "<a class="code" href="ltkcpp__platform_8h.html">ltkcpp_platform.h</a>"</span>
00025 <span class="preprocessor">#include "<a class="code" href="ltkcpp__base_8h.html">ltkcpp_base.h</a>"</span>
00026 <span class="preprocessor">#include "<a class="code" href="ltkcpp__frame_8h.html">ltkcpp_frame.h</a>"</span>
00027 
00028 
00029 <span class="keyword">namespace </span>LLRP
00030 {
00031 
00032 CFrameEncoder::CFrameEncoder (
00033   <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *               pBuffer,
00034   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>                  nBuffer)
00035  : CEncoder()
00036 {
00037     m_pBuffer        = pBuffer;
00038     m_nBuffer        = nBuffer;
00039 
00040     m_iNext          = 0;
00041     m_BitFieldBuffer = 0;
00042     m_nBitFieldResid = 0;
00043 }
00044 
00045 CFrameEncoder::~CFrameEncoder (<span class="keywordtype">void</span>)
00046 {
00047 }
00048 
00049 <span class="keywordtype">void</span>
00050 CFrameEncoder::encodeElement (
00051   <span class="keyword">const</span> CElement *              pElement)
00052 {
00053     CFrameEncoderStream         MyEncoderStream(<span class="keyword">this</span>);
00054 
00055     MyEncoderStream.putElement(pElement);
00056 }
00057 
00058 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>
00059 CFrameEncoder::getLength(<span class="keywordtype">void</span>)
00060 {
00061     <span class="keywordflow">return</span> m_iNext;
00062 }
00063 
00064 <span class="keywordtype">void</span>
00065 CFrameEncoderStream::putRequiredSubParameter (
00066   <span class="keyword">const</span> CParameter *            pParameter,
00067   <span class="keyword">const</span> CTypeDescriptor *       pRefType)
00068 {
00069     <span class="keywordflow">if</span>(NULL == pParameter)
00070     {
00071         <a class="code" href="classLLRP_1_1CErrorDetails.html#a0">CErrorDetails</a> *         pError = &amp;m_pEncoder-&gt;m_ErrorDetails;
00072 
00073         pError-&gt;missingParameter(pRefType);
00074 
00075         <span class="keywordflow">return</span>;
00076     }
00077 
00078     CFrameEncoderStream         NestEncoderStream(<span class="keyword">this</span>);
00079 
00080     NestEncoderStream.putElement(pParameter);
00081 }
00082 
00083 <span class="keywordtype">void</span>
00084 CFrameEncoderStream::putOptionalSubParameter (
00085   <span class="keyword">const</span> CParameter *            pParameter,
00086   <span class="keyword">const</span> CTypeDescriptor *       pRefType)
00087 {
00088     <span class="keywordflow">if</span>(NULL == pParameter)
00089     {
00090         <span class="keywordflow">return</span>;
00091     }
00092 
00093     CFrameEncoderStream         NestEncoderStream(<span class="keyword">this</span>);
00094 
00095     NestEncoderStream.putElement(pParameter);
00096 }
00097 
00098 <span class="keywordtype">void</span>
00099 CFrameEncoderStream::putRequiredSubParameterList (
00100   <span class="keyword">const</span> tListOfParameters *     pParameterList,
00101   <span class="keyword">const</span> CTypeDescriptor *       pRefType)
00102 {
00103     <span class="keywordflow">if</span>(pParameterList-&gt;empty())
00104     {
00105         <a class="code" href="classLLRP_1_1CErrorDetails.html#a0">CErrorDetails</a> *         pError = &amp;m_pEncoder-&gt;m_ErrorDetails;
00106 
00107         pError-&gt;missingParameter(pRefType);
00108 
00109         <span class="keywordflow">return</span>;
00110     }
00111 
00112     <span class="keywordflow">for</span>(
00113         tListOfParameters::const_iterator Cur = pParameterList-&gt;begin();
00114         Cur != pParameterList-&gt;end();
00115         Cur++)
00116     {
00117         putRequiredSubParameter(*Cur, pRefType);
00118     }
00119 }
00120 
00121 <span class="keywordtype">void</span>
00122 CFrameEncoderStream::putOptionalSubParameterList (
00123   <span class="keyword">const</span> tListOfParameters *     pParameterList,
00124   <span class="keyword">const</span> CTypeDescriptor *       pRefType)
00125 {
00126     <span class="keywordflow">for</span>(
00127         tListOfParameters::const_iterator Cur = pParameterList-&gt;begin();
00128         Cur != pParameterList-&gt;end();
00129         Cur++)
00130     {
00131         putRequiredSubParameter(*Cur, pRefType);
00132     }
00133 }
00134 
00135 
00136 <span class="keywordtype">void</span>
00137 CFrameEncoder::next_u8 (
00138   llrp_u8_t                     Value)
00139 {
00140     assert(m_iNext + 1u &lt;= m_nBuffer);
00141 
00142     m_pBuffer[m_iNext++] = Value;
00143 }
00144 
00145 <span class="keywordtype">void</span>
00146 CFrameEncoder::next_u16 (
00147   llrp_u16_t                    Value)
00148 {
00149     assert(m_iNext + 2u &lt;= m_nBuffer);
00150 
00151     m_pBuffer[m_iNext++] = Value &gt;&gt; 8u;
00152     m_pBuffer[m_iNext++] = Value &gt;&gt; 0u;
00153 }
00154 
00155 <span class="keywordtype">void</span>
00156 CFrameEncoder::next_u32 (
00157   llrp_u32_t                    Value)
00158 {
00159     assert(m_iNext + 4u &lt;= m_nBuffer);
00160 
00161     m_pBuffer[m_iNext++] = Value &gt;&gt; 24u;
00162     m_pBuffer[m_iNext++] = Value &gt;&gt; 16u;
00163     m_pBuffer[m_iNext++] = Value &gt;&gt; 8u;
00164     m_pBuffer[m_iNext++] = Value &gt;&gt; 0u;
00165 }
00166 
00167 <span class="keywordtype">void</span>
00168 CFrameEncoder::next_u64 (
00169   llrp_u64_t                    Value)
00170 {
00171     assert(m_iNext + 8u &lt;= m_nBuffer);
00172 
00173     m_pBuffer[m_iNext++] = (llrp_byte_t)(Value &gt;&gt; 56u);
00174     m_pBuffer[m_iNext++] = (llrp_byte_t)(Value &gt;&gt; 48u);
00175     m_pBuffer[m_iNext++] = (llrp_byte_t)(Value &gt;&gt; 40u);
00176     m_pBuffer[m_iNext++] = (llrp_byte_t)(Value &gt;&gt; 32u);
00177     m_pBuffer[m_iNext++] = (llrp_byte_t)(Value &gt;&gt; 24u);
00178     m_pBuffer[m_iNext++] = (llrp_byte_t)(Value &gt;&gt; 16u);
00179     m_pBuffer[m_iNext++] = (llrp_byte_t)(Value &gt;&gt; 8u);
00180     m_pBuffer[m_iNext++] = (llrp_byte_t)(Value &gt;&gt; 0u);
00181 }
00182 
00183 <span class="comment">/*</span>
00184 <span class="comment"> * 8-bit types</span>
00185 <span class="comment"> */</span>
00186 
00187 <span class="keywordtype">void</span>
00188 CFrameEncoderStream::put_u8 (
00189   llrp_u8_t                     Value,
00190   <span class="keyword">const</span> CFieldDescriptor *      pFieldDescriptor)
00191 {
00192     <span class="keywordflow">if</span>(checkAvailable(1u, pFieldDescriptor))
00193     {
00194         m_pEncoder-&gt;next_u8(Value);
00195     }
00196 }
00197 
00198 <span class="keywordtype">void</span>
00199 CFrameEncoderStream::put_s8 (
00200   llrp_s8_t                     Value,
00201   <span class="keyword">const</span> CFieldDescriptor *      pFieldDescriptor)
00202 {
00203     <span class="keywordflow">if</span>(checkAvailable(1u, pFieldDescriptor))
00204     {
00205         m_pEncoder-&gt;next_u8(Value);
00206     }
00207 }
00208 
00209 <span class="keywordtype">void</span>
00210 CFrameEncoderStream::put_u8v (
00211   llrp_u8v_t                    Value,
00212   <span class="keyword">const</span> CFieldDescriptor *      pFieldDescriptor)
00213 {
00214     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>                nByte;
00215 
00216     nByte = 2u + Value.m_nValue * 1u;
00217 
00218     <span class="keywordflow">if</span>(checkAvailable(nByte, pFieldDescriptor))
00219     {
00220         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>            i;
00221 
00222         m_pEncoder-&gt;next_u16(Value.m_nValue);
00223         <span class="keywordflow">for</span>(i = 0; i &lt; Value.m_nValue; i++)
00224         {
00225             m_pEncoder-&gt;next_u8(Value.m_pValue[i]);
00226         }
00227     }
00228 }
00229 
00230 <span class="keywordtype">void</span>
00231 CFrameEncoderStream::put_s8v (
00232   llrp_s8v_t                    Value,
00233   <span class="keyword">const</span> CFieldDescriptor *      pFieldDescriptor)
00234 {
00235     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>                nByte;
00236 
00237     nByte = 2u + Value.m_nValue * 1u;
00238 
00239     <span class="keywordflow">if</span>(checkAvailable(nByte, pFieldDescriptor))
00240     {
00241         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>            i;
00242 
00243         m_pEncoder-&gt;next_u16(Value.m_nValue);
00244         <span class="keywordflow">for</span>(i = 0; i &lt; Value.m_nValue; i++)
00245         {
00246             m_pEncoder-&gt;next_u8(Value.m_pValue[i]);
00247         }
00248     }
00249 }
00250 
00251 <span class="comment">/*</span>
00252 <span class="comment"> * 16-bit types</span>
00253 <span class="comment"> */</span>
00254 
00255 <span class="keywordtype">void</span>
00256 CFrameEncoderStream::put_u16 (
00257   llrp_u16_t                    Value,
00258   <span class="keyword">const</span> CFieldDescriptor *      pFieldDescriptor)
00259 {
00260     <span class="keywordflow">if</span>(checkAvailable(2u, pFieldDescriptor))
00261     {
00262         m_pEncoder-&gt;next_u16(Value);
00263     }
00264 }
00265 
00266 <span class="keywordtype">void</span>
00267 CFrameEncoderStream::put_s16 (
00268   llrp_s16_t                    Value,
00269   <span class="keyword">const</span> CFieldDescriptor *      pFieldDescriptor)
00270 {
00271     <span class="keywordflow">if</span>(checkAvailable(2u, pFieldDescriptor))
00272     {
00273         m_pEncoder-&gt;next_u16(Value);
00274     }
00275 }
00276 
00277 <span class="keywordtype">void</span>
00278 CFrameEncoderStream::put_u16v (
00279   llrp_u16v_t                   Value,
00280   <span class="keyword">const</span> CFieldDescriptor *      pFieldDescriptor)
00281 {
00282     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>                nByte;
00283 
00284     nByte = 2u + Value.m_nValue * 2u;
00285 
00286     <span class="keywordflow">if</span>(checkAvailable(nByte, pFieldDescriptor))
00287     {
00288         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>            i;
00289 
00290         m_pEncoder-&gt;next_u16(Value.m_nValue);
00291         <span class="keywordflow">for</span>(i = 0; i &lt; Value.m_nValue; i++)
00292         {
00293             m_pEncoder-&gt;next_u16(Value.m_pValue[i]);
00294         }
00295     }
00296 }
00297 
00298 <span class="keywordtype">void</span>
00299 CFrameEncoderStream::put_s16v (
00300   llrp_s16v_t                   Value,
00301   <span class="keyword">const</span> CFieldDescriptor *      pFieldDescriptor)
00302 {
00303     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>                nByte;
00304 
00305     nByte = 2u + Value.m_nValue * 2u;
00306 
00307     <span class="keywordflow">if</span>(checkAvailable(nByte, pFieldDescriptor))
00308     {
00309         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>            i;
00310 
00311         m_pEncoder-&gt;next_u16(Value.m_nValue);
00312         <span class="keywordflow">for</span>(i = 0; i &lt; Value.m_nValue; i++)
00313         {
00314             m_pEncoder-&gt;next_u16(Value.m_pValue[i]);
00315         }
00316     }
00317 }
00318 
00319 <span class="comment">/*</span>
00320 <span class="comment"> * 32-bit types</span>
00321 <span class="comment"> */</span>
00322 
00323 <span class="keywordtype">void</span>
00324 CFrameEncoderStream::put_u32 (
00325   llrp_u32_t                    Value,
00326   <span class="keyword">const</span> CFieldDescriptor *      pFieldDescriptor)
00327 {
00328     <span class="keywordflow">if</span>(checkAvailable(4u, pFieldDescriptor))
00329     {
00330         m_pEncoder-&gt;next_u32(Value);
00331     }
00332 }
00333 
00334 <span class="keywordtype">void</span>
00335 CFrameEncoderStream::put_s32 (
00336   llrp_s32_t                    Value,
00337   <span class="keyword">const</span> CFieldDescriptor *      pFieldDescriptor)
00338 {
00339     <span class="keywordflow">if</span>(checkAvailable(4u, pFieldDescriptor))
00340     {
00341         m_pEncoder-&gt;next_u32(Value);
00342     }
00343 }
00344 
00345 <span class="keywordtype">void</span>
00346 CFrameEncoderStream::put_u32v (
00347   llrp_u32v_t                   Value,
00348   <span class="keyword">const</span> CFieldDescriptor *      pFieldDescriptor)
00349 {
00350     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>                nByte;
00351 
00352     nByte = 2u + Value.m_nValue * 4u;
00353 
00354     <span class="keywordflow">if</span>(checkAvailable(nByte, pFieldDescriptor))
00355     {
00356         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>            i;
00357 
00358         m_pEncoder-&gt;next_u16(Value.m_nValue);
00359         <span class="keywordflow">for</span>(i = 0; i &lt; Value.m_nValue; i++)
00360         {
00361             m_pEncoder-&gt;next_u32(Value.m_pValue[i]);
00362         }
00363     }
00364 }
00365 
00366 <span class="keywordtype">void</span>
00367 CFrameEncoderStream::put_s32v (
00368   llrp_s32v_t                   Value,
00369   <span class="keyword">const</span> CFieldDescriptor *      pFieldDescriptor)
00370 {
00371     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>                nByte;
00372 
00373     nByte = 2u + Value.m_nValue * 4u;
00374 
00375     <span class="keywordflow">if</span>(checkAvailable(nByte, pFieldDescriptor))
00376     {
00377         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>            i;
00378 
00379         m_pEncoder-&gt;next_u16(Value.m_nValue);
00380         <span class="keywordflow">for</span>(i = 0; i &lt; Value.m_nValue; i++)
00381         {
00382             m_pEncoder-&gt;next_u32(Value.m_pValue[i]);
00383         }
00384     }
00385 }
00386 
00387 <span class="comment">/*</span>
00388 <span class="comment"> * 64-bit types</span>
00389 <span class="comment"> */</span>
00390 
00391 <span class="keywordtype">void</span>
00392 CFrameEncoderStream::put_u64 (
00393   llrp_u64_t                    Value,
00394   <span class="keyword">const</span> CFieldDescriptor *      pFieldDescriptor)
00395 {
00396     <span class="keywordflow">if</span>(checkAvailable(8u, pFieldDescriptor))
00397     {
00398         m_pEncoder-&gt;next_u64(Value);
00399     }
00400 }
00401 
00402 <span class="keywordtype">void</span>
00403 CFrameEncoderStream::put_s64 (
00404   llrp_s64_t                    Value,
00405   <span class="keyword">const</span> CFieldDescriptor *      pFieldDescriptor)
00406 {
00407     <span class="keywordflow">if</span>(checkAvailable(8u, pFieldDescriptor))
00408     {
00409         m_pEncoder-&gt;next_u64(Value);
00410     }
00411 }
00412 
00413 <span class="keywordtype">void</span>
00414 CFrameEncoderStream::put_u64v (
00415   llrp_u64v_t                   Value,
00416   <span class="keyword">const</span> CFieldDescriptor *      pFieldDescriptor)
00417 {
00418     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>                nByte;
00419 
00420     nByte = 2u + Value.m_nValue * 8u;
00421 
00422     <span class="keywordflow">if</span>(checkAvailable(nByte, pFieldDescriptor))
00423     {
00424         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>            i;
00425 
00426         m_pEncoder-&gt;next_u16(Value.m_nValue);
00427         <span class="keywordflow">for</span>(i = 0; i &lt; Value.m_nValue; i++)
00428         {
00429             m_pEncoder-&gt;next_u64(Value.m_pValue[i]);
00430         }
00431     }
00432 }
00433 
00434 <span class="keywordtype">void</span>
00435 CFrameEncoderStream::put_s64v (
00436   llrp_s64v_t                   Value,
00437   <span class="keyword">const</span> CFieldDescriptor *      pFieldDescriptor)
00438 {
00439     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>                nByte;
00440 
00441     nByte = 2u + Value.m_nValue * 8u;
00442 
00443     <span class="keywordflow">if</span>(checkAvailable(nByte, pFieldDescriptor))
00444     {
00445         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>            i;
00446 
00447         m_pEncoder-&gt;next_u16(Value.m_nValue);
00448         <span class="keywordflow">for</span>(i = 0; i &lt; Value.m_nValue; i++)
00449         {
00450             m_pEncoder-&gt;next_u64(Value.m_pValue[i]);
00451         }
00452     }
00453 }
00454 
00455 <span class="comment">/*</span>
00456 <span class="comment"> * Special types</span>
00457 <span class="comment"> */</span>
00458 
00459 <span class="keywordtype">void</span>
00460 CFrameEncoderStream::put_u1 (
00461   llrp_u1_t                     Value,
00462   <span class="keyword">const</span> CFieldDescriptor *      pFieldDescriptor)
00463 {
00464     putBitField(1u, Value, pFieldDescriptor);
00465 }
00466 
00467 <span class="keywordtype">void</span>
00468 CFrameEncoderStream::put_u1v (
00469   llrp_u1v_t                    Value,
00470   <span class="keyword">const</span> CFieldDescriptor *      pFieldDescriptor)
00471 {
00472     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>                nByte;
00473 
00474     nByte = (Value.m_nBit + 7u) / 8u;
00475 
00476     <span class="keywordflow">if</span>(checkAvailable(2u + nByte, pFieldDescriptor))
00477     {
00478         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>            i;
00479 
00480         m_pEncoder-&gt;next_u16(Value.m_nBit);
00481         <span class="keywordflow">for</span>(i = 0; i &lt; nByte; i++)
00482         {
00483             m_pEncoder-&gt;next_u8(Value.m_pValue[i]);
00484         }
00485     }
00486 }
00487 
00488 <span class="keywordtype">void</span>
00489 CFrameEncoderStream::put_u2 (
00490   llrp_u2_t                     Value,
00491   <span class="keyword">const</span> CFieldDescriptor *      pFieldDescriptor)
00492 {
00493     putBitField(2u, Value, pFieldDescriptor);
00494 }
00495 
00496 <span class="keywordtype">void</span>
00497 CFrameEncoderStream::put_u96 (
00498   llrp_u96_t                    Value,
00499   <span class="keyword">const</span> CFieldDescriptor *      pFieldDescriptor)
00500 {
00501     <span class="keywordflow">if</span>(checkAvailable(12u, pFieldDescriptor))
00502     {
00503         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>            i;
00504 
00505         <span class="keywordflow">for</span>(i = 0; i &lt; 12u; i++)
00506         {
00507             m_pEncoder-&gt;next_u8(Value.m_aValue[i]);
00508         }
00509     }
00510 }
00511 
00512 <span class="keywordtype">void</span>
00513 CFrameEncoderStream::put_utf8v (
00514   llrp_utf8v_t                  Value,
00515   <span class="keyword">const</span> CFieldDescriptor *      pFieldDescriptor)
00516 {
00517     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>                nByte;
00518 
00519     nByte = 2u + Value.m_nValue * 1u;
00520 
00521     <span class="keywordflow">if</span>(checkAvailable(nByte, pFieldDescriptor))
00522     {
00523         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>            i;
00524 
00525         m_pEncoder-&gt;next_u16(Value.m_nValue);
00526         <span class="keywordflow">for</span>(i = 0; i &lt; Value.m_nValue; i++)
00527         {
00528             m_pEncoder-&gt;next_u8(Value.m_pValue[i]);
00529         }
00530     }
00531 }
00532 
00533 <span class="keywordtype">void</span>
00534 CFrameEncoderStream::put_bytesToEnd (
00535   llrp_bytesToEnd_t             Value,
00536   <span class="keyword">const</span> CFieldDescriptor *      pFieldDescriptor)
00537 {
00538     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>                nByte;
00539 
00540     nByte = Value.m_nValue * 1u;
00541 
00542     <span class="keywordflow">if</span>(checkAvailable(nByte, pFieldDescriptor))
00543     {
00544         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>            i;
00545 
00546         <span class="keywordflow">for</span>(i = 0; i &lt; Value.m_nValue; i++)
00547         {
00548             m_pEncoder-&gt;next_u8(Value.m_pValue[i]);
00549         }
00550     }
00551 }
00552 
00553 <span class="comment">/*</span>
00554 <span class="comment"> * Enumerated types of various sizes</span>
00555 <span class="comment"> */</span>
00556 
00557 <span class="keywordtype">void</span>
00558 CFrameEncoderStream::put_e1 (
00559   <span class="keywordtype">int</span>                           eValue,
00560   <span class="keyword">const</span> CFieldDescriptor *      pFieldDescriptor)
00561 {
00562     put_u1((llrp_u1_t)eValue, pFieldDescriptor);
00563 }
00564 
00565 <span class="keywordtype">void</span>
00566 CFrameEncoderStream::put_e2 (
00567   <span class="keywordtype">int</span>                           eValue,
00568   <span class="keyword">const</span> CFieldDescriptor *      pFieldDescriptor)
00569 {
00570     put_u2((llrp_u2_t)eValue, pFieldDescriptor);
00571 }
00572 
00573 <span class="keywordtype">void</span>
00574 CFrameEncoderStream::put_e8 (
00575   <span class="keywordtype">int</span>                           eValue,
00576   <span class="keyword">const</span> CFieldDescriptor *      pFieldDescriptor)
00577 {
00578     put_u8((llrp_u8_t)eValue, pFieldDescriptor);
00579 }
00580 
00581 <span class="keywordtype">void</span>
00582 CFrameEncoderStream::put_e16 (
00583   <span class="keywordtype">int</span>                           eValue,
00584   <span class="keyword">const</span> CFieldDescriptor *      pFieldDescriptor)
00585 {
00586     put_u16((llrp_u16_t)eValue, pFieldDescriptor);
00587 }
00588 
00589 <span class="keywordtype">void</span>
00590 CFrameEncoderStream::put_e32 (
00591   <span class="keywordtype">int</span>                           eValue,
00592   <span class="keyword">const</span> CFieldDescriptor *      pFieldDescriptor)
00593 {
00594     put_u32((llrp_u32_t)eValue, pFieldDescriptor);
00595 }
00596 
00597 <span class="keywordtype">void</span>
00598 CFrameEncoderStream::put_e8v (
00599   llrp_u8v_t                    Value,
00600   <span class="keyword">const</span> CFieldDescriptor *      pFieldDescriptor)
00601 {
00602     put_u8v(Value, pFieldDescriptor);
00603 }
00604 
00605 <span class="comment">/*</span>
00606 <span class="comment"> * Reserved types are some number of bits</span>
00607 <span class="comment"> */</span>
00608 
00609 <span class="keywordtype">void</span>
00610 CFrameEncoderStream::put_reserved (
00611   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>                  nBits)
00612 {
00613     <a class="code" href="classLLRP_1_1CErrorDetails.html#a0">CErrorDetails</a> *             pError = &amp;m_pEncoder-&gt;m_ErrorDetails;
00614 
00615     <span class="keywordflow">if</span>(<a class="code" href="namespaceLLRP.html#a333a251">RC_OK</a> != pError-&gt;m_eResultCode)
00616     {
00617         <span class="keywordflow">return</span>;
00618     }
00619 
00620     <span class="keywordflow">while</span>(nBits &gt; 0)
00621     {
00622         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>            Step = 7u &amp; nBits;
00623 
00624         <span class="keywordflow">if</span>(0 != m_pEncoder-&gt;m_nBitFieldResid)
00625         {
00626             <span class="keywordflow">if</span>(Step != m_pEncoder-&gt;m_nBitFieldResid)
00627             {
00628                 pError-&gt;m_eResultCode = RC_UnalignedReservedBits;
00629                 pError-&gt;m_pWhatStr    = <span class="stringliteral">"unaligned reserved bits"</span>;
00630                 pError-&gt;m_pRefType    = m_pRefType;
00631                 pError-&gt;m_pRefField   = NULL;
00632                 pError-&gt;m_OtherDetail = m_pEncoder-&gt;m_iNext;
00633                 <span class="keywordflow">return</span>;
00634             }
00635 
00636             m_pEncoder-&gt;next_u8(m_pEncoder-&gt;m_BitFieldBuffer);
00637             nBits -= Step;
00638             m_pEncoder-&gt;m_BitFieldBuffer = 0;
00639             m_pEncoder-&gt;m_nBitFieldResid = 0;
00640         }
00641         <span class="keywordflow">else</span>
00642         {
00643             <span class="keywordflow">if</span>(0 != Step)
00644             {
00645                 pError-&gt;m_eResultCode = RC_UnalignedReservedBits;
00646                 pError-&gt;m_pWhatStr    = <span class="stringliteral">"unaligned reserved bits"</span>;
00647                 pError-&gt;m_pRefType    = m_pRefType;
00648                 pError-&gt;m_pRefField   = NULL;
00649                 pError-&gt;m_OtherDetail = m_pEncoder-&gt;m_iNext;
00650                 <span class="keywordflow">return</span>;
00651             }
00652 
00653             <span class="keywordflow">if</span>(m_pEncoder-&gt;m_iNext &gt;= m_pEncoder-&gt;m_nBuffer)
00654             {
00655                 pError-&gt;m_eResultCode = RC_ReservedBitsOverrun;
00656                 pError-&gt;m_pWhatStr    = <span class="stringliteral">"overrun at reserved bits"</span>;
00657                 pError-&gt;m_pRefType    = m_pRefType;
00658                 pError-&gt;m_pRefField   = NULL;
00659                 pError-&gt;m_OtherDetail = m_pEncoder-&gt;m_iNext;
00660                 <span class="keywordflow">return</span>;
00661             }
00662 
00663             m_pEncoder-&gt;next_u8(0);
00664             nBits -= 8;
00665         }
00666     }
00667 }
00668 
00669 CFrameEncoderStream::CFrameEncoderStream (
00670   CFrameEncoder *               pEncoder)
00671 {
00672     m_pEncoder                  = pEncoder;
00673     m_pEnclosingEncoderStream   = NULL;
00674     m_iBegin                    = m_pEncoder-&gt;m_iNext;
00675     <a class="code" href="classLLRP_1_1CErrorDetails.html#o2">m_pRefType</a>                  = NULL;
00676 }
00677 
00678 CFrameEncoderStream::CFrameEncoderStream (
00679   CFrameEncoderStream *         pEnclosingEncoderStream)
00680 {
00681     m_pEncoder                  = pEnclosingEncoderStream-&gt;m_pEncoder;
00682     m_pEnclosingEncoderStream   = pEnclosingEncoderStream;
00683     m_iBegin                    = m_pEncoder-&gt;m_iNext;
00684     <a class="code" href="classLLRP_1_1CErrorDetails.html#o2">m_pRefType</a>                  = NULL;
00685 }
00686 
00687 <span class="keywordtype">void</span>
00688 CFrameEncoderStream::putElement (
00689   <span class="keyword">const</span> CElement *              pElement)
00690 {
00691     <a class="code" href="classLLRP_1_1CErrorDetails.html#a0">CErrorDetails</a> *             pError = &amp;m_pEncoder-&gt;m_ErrorDetails;
00692     <span class="keyword">enum</span> { MSG, TLV, TV, CUST_MSG, CUST_TLV } eFormat;
00693 
00694     <span class="keywordflow">if</span>(<a class="code" href="namespaceLLRP.html#a333a251">RC_OK</a> != pError-&gt;m_eResultCode)
00695     {
00696         <span class="keywordflow">return</span>;
00697     }
00698 
00699     <a class="code" href="classLLRP_1_1CErrorDetails.html#o2">m_pRefType</a> = pElement-&gt;m_pType;
00700 
00701     <span class="keywordflow">if</span>(<a class="code" href="classLLRP_1_1CErrorDetails.html#o2">m_pRefType</a>-&gt;m_bIsMessage)
00702     {
00703         eFormat = (NULL == <a class="code" href="classLLRP_1_1CErrorDetails.html#o2">m_pRefType</a>-&gt;m_pVendorDescriptor) ? MSG : CUST_MSG;
00704     }
00705     <span class="keywordflow">else</span> <span class="keywordflow">if</span>(NULL == <a class="code" href="classLLRP_1_1CErrorDetails.html#o2">m_pRefType</a>-&gt;m_pVendorDescriptor &amp;&amp;
00706             128 &gt; <a class="code" href="classLLRP_1_1CErrorDetails.html#o2">m_pRefType</a>-&gt;m_TypeNum)
00707     {
00708         <span class="comment">/* TV parameter, never custom, no length */</span>
00709         eFormat = TV;
00710     }
00711     <span class="keywordflow">else</span>
00712     {
00713         <span class="comment">/* TLV parameter */</span>
00714         eFormat = (NULL == <a class="code" href="classLLRP_1_1CErrorDetails.html#o2">m_pRefType</a>-&gt;m_pVendorDescriptor) ? TLV : CUST_TLV;
00715     }
00716 
00717     <span class="comment">/*</span>
00718 <span class="comment">     * Format the element header. The length part, if one,</span>
00719 <span class="comment">     * is a place holder and back-patched later.</span>
00720 <span class="comment">     */</span>
00721     <span class="keywordflow">switch</span>(eFormat)
00722     {
00723     <span class="keywordflow">default</span>:
00724         assert(0);
00725         <span class="keywordflow">break</span>;
00726 
00727     <span class="keywordflow">case</span> MSG:
00728         {
00729             llrp_u16_t          VersType;
00730 
00731             VersType = (1u &lt;&lt; 10u) | <a class="code" href="classLLRP_1_1CErrorDetails.html#o2">m_pRefType</a>-&gt;m_TypeNum;
00732             put_u16(VersType, &amp;g_fdMessageHeader_Type);
00733             put_u32(0, &amp;g_fdMessageHeader_Length);
00734             put_u32(((<span class="keyword">const</span> CMessage *)pElement)-&gt;getMessageID(),
00735                 &amp;g_fdMessageHeader_MessageID);
00736         }
00737         <span class="keywordflow">break</span>;
00738 
00739     <span class="keywordflow">case</span> CUST_MSG:
00740         {
00741             llrp_u16_t          VersType;
00742 
00743             <span class="comment">/* Custom message */</span>
00744             VersType = (1u &lt;&lt; 10u) | 1023u;
00745             put_u16(VersType,
00746                 &amp;g_fdMessageHeader_Type);
00747             <span class="comment">/* length is a placeholder */</span>
00748             put_u32(0, &amp;g_fdMessageHeader_Length);
00749             put_u32(((<span class="keyword">const</span> CMessage *)pElement)-&gt;getMessageID(),
00750                 &amp;g_fdMessageHeader_MessageID);
00751             put_u32(
00752                 <a class="code" href="classLLRP_1_1CErrorDetails.html#o2">m_pRefType</a>-&gt;m_pVendorDescriptor-&gt;m_VendorID,
00753                 &amp;g_fdMessageHeader_VendorPEN);
00754             put_u8(<a class="code" href="classLLRP_1_1CErrorDetails.html#o2">m_pRefType</a>-&gt;m_TypeNum, &amp;g_fdMessageHeader_Subtype);
00755         }
00756         <span class="keywordflow">break</span>;
00757 
00758     <span class="keywordflow">case</span> TV:
00759         put_u8(<a class="code" href="classLLRP_1_1CErrorDetails.html#o2">m_pRefType</a>-&gt;m_TypeNum | 0x80u, &amp;g_fdParameterHeader_TVType);
00760         <span class="keywordflow">break</span>;
00761 
00762     <span class="keywordflow">case</span> TLV:
00763         <span class="comment">/* Standard parameter */</span>
00764         put_u16(<a class="code" href="classLLRP_1_1CErrorDetails.html#o2">m_pRefType</a>-&gt;m_TypeNum, &amp;g_fdParameterHeader_TLVType);
00765         put_u16(0, &amp;g_fdParameterHeader_TLVLength);
00766         <span class="keywordflow">break</span>;
00767 
00768     <span class="keywordflow">case</span> CUST_TLV:
00769         <span class="comment">/* Custom parameter */</span>
00770         put_u16(1023u, &amp;g_fdParameterHeader_TLVType);
00771         put_u16(0, &amp;g_fdParameterHeader_TLVLength);
00772         put_u32(
00773             <a class="code" href="classLLRP_1_1CErrorDetails.html#o2">m_pRefType</a>-&gt;m_pVendorDescriptor-&gt;m_VendorID,
00774             &amp;g_fdParameterHeader_VendorPEN);
00775         put_u32(<a class="code" href="classLLRP_1_1CErrorDetails.html#o2">m_pRefType</a>-&gt;m_TypeNum, &amp;g_fdParameterHeader_Subtype);
00776         <span class="keywordflow">break</span>;
00777     }
00778 
00779     <span class="keywordflow">if</span>(<a class="code" href="namespaceLLRP.html#a333a251">RC_OK</a> != pError-&gt;m_eResultCode)
00780     {
00781         <span class="keywordflow">return</span>;
00782     }
00783 
00784     pElement-&gt;encode(<span class="keyword">this</span>);
00785 
00786     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>        nLength;
00787     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *     pLen;
00788 
00789     nLength = m_pEncoder-&gt;m_iNext - m_iBegin;
00790     pLen = &amp;m_pEncoder-&gt;m_pBuffer[m_iBegin];
00791 
00792     <span class="keywordflow">switch</span>(eFormat)
00793     {
00794     <span class="keywordflow">default</span>:
00795         assert(0);
00796         <span class="keywordflow">break</span>;
00797 
00798     <span class="keywordflow">case</span> MSG:
00799     <span class="keywordflow">case</span> CUST_MSG:
00800         assert(nLength &gt;= 10);
00801         pLen += 2;
00802         pLen[0] = nLength &gt;&gt; 24u;
00803         pLen[1] = nLength &gt;&gt; 16u;
00804         pLen[2] = nLength &gt;&gt; 8u;
00805         pLen[3] = nLength &gt;&gt; 0u;
00806         <span class="keywordflow">break</span>;
00807 
00808     <span class="keywordflow">case</span> TV:
00809         <span class="keywordflow">break</span>;
00810 
00811     <span class="keywordflow">case</span> TLV:
00812     <span class="keywordflow">case</span> CUST_TLV:
00813         assert(nLength &gt;= 4);
00814         pLen += 2;
00815         pLen[0] = nLength &gt;&gt; 8u;
00816         pLen[1] = nLength &gt;&gt; 0u;
00817         <span class="keywordflow">break</span>;
00818     }
00819 }
00820 
00821 llrp_bool_t
00822 CFrameEncoderStream::checkAvailable (
00823   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>                  nByte,
00824   <span class="keyword">const</span> CFieldDescriptor *      pFieldDescriptor)
00825 {
00826     <a class="code" href="classLLRP_1_1CErrorDetails.html#a0">CErrorDetails</a> *             pError = &amp;m_pEncoder-&gt;m_ErrorDetails;
00827 
00828     <span class="keywordflow">if</span>(<a class="code" href="namespaceLLRP.html#a333a251">RC_OK</a> != pError-&gt;m_eResultCode)
00829     {
00830         <span class="keywordflow">return</span> FALSE;
00831     }
00832 
00833     <span class="keywordflow">if</span>(m_pEncoder-&gt;m_iNext + nByte &gt; m_pEncoder-&gt;m_nBuffer)
00834     {
00835         pError-&gt;m_eResultCode = RC_FieldOverrun;
00836         pError-&gt;m_pRefField   = pFieldDescriptor;
00837         pError-&gt;m_pRefType    = m_pRefType;
00838         pError-&gt;m_pWhatStr    = <span class="stringliteral">"overrun at field"</span>;
00839         pError-&gt;m_OtherDetail = m_pEncoder-&gt;m_iNext;
00840 
00841         <span class="keywordflow">return</span> FALSE;
00842     }
00843 
00844     <span class="keywordflow">if</span>(0 != m_pEncoder-&gt;m_nBitFieldResid)
00845     {
00846         pError-&gt;m_eResultCode = RC_UnalignedBitField;
00847         pError-&gt;m_pRefField   = pFieldDescriptor;
00848         pError-&gt;m_pRefType    = m_pRefType;
00849         pError-&gt;m_pWhatStr    = <span class="stringliteral">"unalign/incomplete bit field"</span>;
00850         pError-&gt;m_OtherDetail = m_pEncoder-&gt;m_iNext;
00851 
00852         <span class="keywordflow">return</span> FALSE;
00853     }
00854 
00855     <span class="keywordflow">return</span> TRUE;
00856 }
00857 
00858 llrp_bool_t
00859 CFrameEncoderStream::putBitField (
00860   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>                  nBit,
00861   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>                  Value,
00862   <span class="keyword">const</span> CFieldDescriptor *      pFieldDescriptor)
00863 {
00864     <a class="code" href="classLLRP_1_1CErrorDetails.html#a0">CErrorDetails</a> *             pError = &amp;m_pEncoder-&gt;m_ErrorDetails;
00865 
00866     <span class="keywordflow">if</span>(0 == m_pEncoder-&gt;m_nBitFieldResid)
00867     {
00868         <span class="keywordflow">if</span>(!checkAvailable(1u, pFieldDescriptor))
00869         {
00870             <span class="keywordflow">return</span> FALSE;
00871         }
00872         m_pEncoder-&gt;m_BitFieldBuffer = 0;
00873         m_pEncoder-&gt;m_nBitFieldResid = 8u;
00874     }
00875 
00876     <span class="keywordflow">if</span>(m_pEncoder-&gt;m_nBitFieldResid &lt; nBit)
00877     {
00878         pError-&gt;m_eResultCode = RC_UnalignedBitField;
00879         pError-&gt;m_pWhatStr    = <span class="stringliteral">"unalign/incomplete bit field"</span>;
00880         pError-&gt;m_pRefType    = m_pRefType;
00881         pError-&gt;m_pRefField   = pFieldDescriptor;
00882         pError-&gt;m_OtherDetail = m_pEncoder-&gt;m_iNext;
00883         <span class="keywordflow">return</span> FALSE;
00884     }
00885 
00886     m_pEncoder-&gt;m_nBitFieldResid -= nBit;
00887 
00888     Value &amp;= (1u &lt;&lt; nBit) - 1u;
00889 
00890     m_pEncoder-&gt;m_BitFieldBuffer |= Value &lt;&lt; m_pEncoder-&gt;m_nBitFieldResid;
00891 
00892 
00893     <span class="keywordflow">if</span>(0 == m_pEncoder-&gt;m_nBitFieldResid)
00894     {
00895         m_pEncoder-&gt;next_u8(m_pEncoder-&gt;m_BitFieldBuffer);
00896         m_pEncoder-&gt;m_BitFieldBuffer = 0;
00897         m_pEncoder-&gt;m_nBitFieldResid = 0;
00898     }
00899 
00900     <span class="keywordflow">return</span> TRUE;
00901 }
00902 
00903 };
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Wed Feb 24 09:16:21 2010 for LTKCPP-- LLRP Toolkit C Plus Plus Library by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.3.9.1 </small></address>
</body>
</html>
