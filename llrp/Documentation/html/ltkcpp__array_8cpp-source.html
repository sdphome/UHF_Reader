<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>LTKCPP-- LLRP Toolkit C Plus Plus Library: ltkcpp_array.cpp Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.9.1 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="namespacemembers.html">Namespace&nbsp;Members</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a></div>
<div class="nav">
<a class="el" href="dir_000002.html">Library</a></div>
<h1>ltkcpp_array.cpp</h1><div class="fragment"><pre class="fragment">00001 
00002 <span class="comment">/*</span>
00003 <span class="comment"> ***************************************************************************</span>
00004 <span class="comment"> *  Copyright 2007,2008 Impinj, Inc.</span>
00005 <span class="comment"> *</span>
00006 <span class="comment"> *  Licensed under the Apache License, Version 2.0 (the "License");</span>
00007 <span class="comment"> *  you may not use this file except in compliance with the License.</span>
00008 <span class="comment"> *  You may obtain a copy of the License at</span>
00009 <span class="comment"> *</span>
00010 <span class="comment"> *      http://www.apache.org/licenses/LICENSE-2.0</span>
00011 <span class="comment"> *</span>
00012 <span class="comment"> *  Unless required by applicable law or agreed to in writing, software</span>
00013 <span class="comment"> *  distributed under the License is distributed on an "AS IS" BASIS,</span>
00014 <span class="comment"> *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
00015 <span class="comment"> *  See the License for the specific language governing permissions and</span>
00016 <span class="comment"> *  limitations under the License.</span>
00017 <span class="comment"> *</span>
00018 <span class="comment"> ***************************************************************************</span>
00019 <span class="comment"> */</span>
00020 
00021 
00022 <span class="preprocessor">#include "<a class="code" href="ltkcpp__platform_8h.html">ltkcpp_platform.h</a>"</span>
00023 <span class="preprocessor">#include "<a class="code" href="ltkcpp__base_8h.html">ltkcpp_base.h</a>"</span>
00024 
00025 
00026 <span class="keyword">namespace </span>LLRP
00027 {
00028 
00029 <span class="comment">/*</span>
00030 <span class="comment"> * u8v</span>
00031 <span class="comment"> */</span>
00032 
<a name="l00033"></a><a class="code" href="classLLRP_1_1llrp__u8v__t.html#a0">00033</a> llrp_u8v_t::llrp_u8v_t (<span class="keywordtype">void</span>)
00034 {
00035     <a class="code" href="classLLRP_1_1llrp__u8v__t.html#o1">m_pValue</a> = NULL;
00036     <a class="code" href="classLLRP_1_1llrp__u8v__t.html#o0">m_nValue</a> = 0;
00037 }
00038 
<a name="l00039"></a><a class="code" href="classLLRP_1_1llrp__u8v__t.html#a1">00039</a> llrp_u8v_t::llrp_u8v_t (
00040   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>                  nValue)
00041 {
00042     <a class="code" href="classLLRP_1_1llrp__u8v__t.html#o0">m_nValue</a> = nValue;
00043     <span class="keywordflow">if</span>(0 &lt; m_nValue)
00044     {
00045         <a class="code" href="classLLRP_1_1llrp__u8v__t.html#o1">m_pValue</a> = <span class="keyword">new</span> llrp_u8_t[m_nValue];
00046         memset(<a class="code" href="classLLRP_1_1llrp__u8v__t.html#o1">m_pValue</a>, 0, <span class="keyword">sizeof</span> <a class="code" href="classLLRP_1_1llrp__u8v__t.html#o1">m_pValue</a>[0] * <a class="code" href="classLLRP_1_1llrp__u8v__t.html#o0">m_nValue</a>);
00047     }
00048     <span class="keywordflow">else</span>
00049     {
00050         <a class="code" href="classLLRP_1_1llrp__u8v__t.html#o1">m_pValue</a> = NULL;
00051     }
00052 }
00053 
<a name="l00054"></a><a class="code" href="classLLRP_1_1llrp__u8v__t.html#a2">00054</a> llrp_u8v_t::llrp_u8v_t (
00055   <span class="keyword">const</span> <a class="code" href="classLLRP_1_1llrp__u8v__t.html">llrp_u8v_t</a> &amp;           rOther)
00056 {
00057     copy(rOther);
00058 }
00059 
<a name="l00060"></a><a class="code" href="classLLRP_1_1llrp__u8v__t.html#a3">00060</a> llrp_u8v_t::~llrp_u8v_t (<span class="keywordtype">void</span>)
00061 {
00062     reset();
00063 }
00064 
00065 <a class="code" href="classLLRP_1_1llrp__u8v__t.html">llrp_u8v_t</a> &amp;
<a name="l00066"></a><a class="code" href="classLLRP_1_1llrp__u8v__t.html#a4">00066</a> llrp_u8v_t::operator= (
00067   <span class="keyword">const</span> <a class="code" href="classLLRP_1_1llrp__u8v__t.html">llrp_u8v_t</a> &amp;           rOther)
00068 {
00069     <span class="keywordflow">if</span>(<span class="keyword">this</span> != &amp;rOther)
00070     {
00071         reset();
00072         copy(rOther);
00073     }
00074 
00075     <span class="keywordflow">return</span> *<span class="keyword">this</span>;
00076 }
00077 
00078 <span class="keywordtype">void</span>
00079 llrp_u8v_t::reset(<span class="keywordtype">void</span>)
00080 {
00081     <span class="keywordflow">if</span>(NULL != m_pValue)
00082     {
00083         <span class="keyword">delete</span>[] m_pValue;
00084         m_pValue = NULL;
00085     }
00086     m_nValue = 0;
00087 }
00088 
00089 <span class="keywordtype">void</span>
00090 llrp_u8v_t::copy (
00091   <span class="keyword">const</span> llrp_u8v_t &amp;           rOther)
00092 {
00093     <a class="code" href="classLLRP_1_1llrp__u8v__t.html#o0">m_nValue</a> = rOther.m_nValue;
00094     <span class="keywordflow">if</span>(0 &lt; m_nValue)
00095     {
00096         <a class="code" href="classLLRP_1_1llrp__u8v__t.html#o1">m_pValue</a> = <span class="keyword">new</span> llrp_u8_t[m_nValue];
00097         memcpy(m_pValue, rOther.m_pValue, <span class="keyword">sizeof</span> m_pValue[0] * m_nValue);
00098     }
00099     <span class="keywordflow">else</span>
00100     {
00101         <a class="code" href="classLLRP_1_1llrp__u8v__t.html#o1">m_pValue</a> = NULL;
00102     }
00103 }
00104 
00105 
00106 
00107 
00108 
00109 <span class="comment">/*</span>
00110 <span class="comment"> * s8v</span>
00111 <span class="comment"> */</span>
00112 
<a name="l00113"></a><a class="code" href="classLLRP_1_1llrp__s8v__t.html#a0">00113</a> llrp_s8v_t::llrp_s8v_t (<span class="keywordtype">void</span>)
00114 {
00115     <a class="code" href="classLLRP_1_1llrp__s8v__t.html#o1">m_pValue</a> = NULL;
00116     <a class="code" href="classLLRP_1_1llrp__s8v__t.html#o0">m_nValue</a> = 0;
00117 }
00118 
<a name="l00119"></a><a class="code" href="classLLRP_1_1llrp__s8v__t.html#a1">00119</a> llrp_s8v_t::llrp_s8v_t (
00120   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>                  nValue)
00121 {
00122     <a class="code" href="classLLRP_1_1llrp__s8v__t.html#o0">m_nValue</a> = nValue;
00123     <span class="keywordflow">if</span>(0 &lt; m_nValue)
00124     {
00125         <a class="code" href="classLLRP_1_1llrp__s8v__t.html#o1">m_pValue</a> = <span class="keyword">new</span> llrp_s8_t[m_nValue];
00126         memset(<a class="code" href="classLLRP_1_1llrp__s8v__t.html#o1">m_pValue</a>, 0, <span class="keyword">sizeof</span> <a class="code" href="classLLRP_1_1llrp__s8v__t.html#o1">m_pValue</a>[0] * <a class="code" href="classLLRP_1_1llrp__s8v__t.html#o0">m_nValue</a>);
00127     }
00128     <span class="keywordflow">else</span>
00129     {
00130         <a class="code" href="classLLRP_1_1llrp__s8v__t.html#o1">m_pValue</a> = NULL;
00131     }
00132 }
00133 
<a name="l00134"></a><a class="code" href="classLLRP_1_1llrp__s8v__t.html#a2">00134</a> llrp_s8v_t::llrp_s8v_t (
00135   <span class="keyword">const</span> <a class="code" href="classLLRP_1_1llrp__s8v__t.html">llrp_s8v_t</a> &amp;           rOther)
00136 {
00137     copy(rOther);
00138 }
00139 
<a name="l00140"></a><a class="code" href="classLLRP_1_1llrp__s8v__t.html#a3">00140</a> llrp_s8v_t::~llrp_s8v_t (<span class="keywordtype">void</span>)
00141 {
00142     reset();
00143 }
00144 
00145 <a class="code" href="classLLRP_1_1llrp__s8v__t.html">llrp_s8v_t</a> &amp;
<a name="l00146"></a><a class="code" href="classLLRP_1_1llrp__s8v__t.html#a4">00146</a> llrp_s8v_t::operator= (
00147   <span class="keyword">const</span> <a class="code" href="classLLRP_1_1llrp__s8v__t.html">llrp_s8v_t</a> &amp;           rOther)
00148 {
00149     <span class="keywordflow">if</span>(<span class="keyword">this</span> != &amp;rOther)
00150     {
00151         reset();
00152         copy(rOther);
00153     }
00154 
00155     <span class="keywordflow">return</span> *<span class="keyword">this</span>;
00156 }
00157 
00158 <span class="keywordtype">void</span>
00159 llrp_s8v_t::reset(<span class="keywordtype">void</span>)
00160 {
00161     <span class="keywordflow">if</span>(NULL != m_pValue)
00162     {
00163         <span class="keyword">delete</span>[] m_pValue;
00164         m_pValue = NULL;
00165     }
00166     m_nValue = 0;
00167 }
00168 
00169 <span class="keywordtype">void</span>
00170 llrp_s8v_t::copy (
00171   <span class="keyword">const</span> llrp_s8v_t &amp;           rOther)
00172 {
00173     <a class="code" href="classLLRP_1_1llrp__s8v__t.html#o0">m_nValue</a> = rOther.m_nValue;
00174     <span class="keywordflow">if</span>(0 &lt; m_nValue)
00175     {
00176         <a class="code" href="classLLRP_1_1llrp__s8v__t.html#o1">m_pValue</a> = <span class="keyword">new</span> llrp_s8_t[m_nValue];
00177         memcpy(m_pValue, rOther.m_pValue, <span class="keyword">sizeof</span> m_pValue[0] * m_nValue);
00178     }
00179     <span class="keywordflow">else</span>
00180     {
00181         <a class="code" href="classLLRP_1_1llrp__s8v__t.html#o1">m_pValue</a> = NULL;
00182     }
00183 }
00184 
00185 
00186 
00187 
00188 
00189 <span class="comment">/*</span>
00190 <span class="comment"> * u16v</span>
00191 <span class="comment"> */</span>
00192 
<a name="l00193"></a><a class="code" href="classLLRP_1_1llrp__u16v__t.html#a0">00193</a> llrp_u16v_t::llrp_u16v_t (<span class="keywordtype">void</span>)
00194 {
00195     <a class="code" href="classLLRP_1_1llrp__u16v__t.html#o1">m_pValue</a> = NULL;
00196     <a class="code" href="classLLRP_1_1llrp__u16v__t.html#o0">m_nValue</a> = 0;
00197 }
00198 
<a name="l00199"></a><a class="code" href="classLLRP_1_1llrp__u16v__t.html#a1">00199</a> llrp_u16v_t::llrp_u16v_t (
00200   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>                  nValue)
00201 {
00202     <a class="code" href="classLLRP_1_1llrp__u16v__t.html#o0">m_nValue</a> = nValue;
00203     <span class="keywordflow">if</span>(0 &lt; m_nValue)
00204     {
00205         <a class="code" href="classLLRP_1_1llrp__u16v__t.html#o1">m_pValue</a> = <span class="keyword">new</span> llrp_u16_t[m_nValue];
00206         memset(<a class="code" href="classLLRP_1_1llrp__u16v__t.html#o1">m_pValue</a>, 0, <span class="keyword">sizeof</span> <a class="code" href="classLLRP_1_1llrp__u16v__t.html#o1">m_pValue</a>[0] * <a class="code" href="classLLRP_1_1llrp__u16v__t.html#o0">m_nValue</a>);
00207     }
00208     <span class="keywordflow">else</span>
00209     {
00210         <a class="code" href="classLLRP_1_1llrp__u16v__t.html#o1">m_pValue</a> = NULL;
00211     }
00212 }
00213 
<a name="l00214"></a><a class="code" href="classLLRP_1_1llrp__u16v__t.html#a2">00214</a> llrp_u16v_t::llrp_u16v_t (
00215   <span class="keyword">const</span> <a class="code" href="classLLRP_1_1llrp__u16v__t.html">llrp_u16v_t</a> &amp;           rOther)
00216 {
00217     copy(rOther);
00218 }
00219 
<a name="l00220"></a><a class="code" href="classLLRP_1_1llrp__u16v__t.html#a3">00220</a> llrp_u16v_t::~llrp_u16v_t (<span class="keywordtype">void</span>)
00221 {
00222     reset();
00223 }
00224 
00225 <a class="code" href="classLLRP_1_1llrp__u16v__t.html">llrp_u16v_t</a> &amp;
<a name="l00226"></a><a class="code" href="classLLRP_1_1llrp__u16v__t.html#a4">00226</a> llrp_u16v_t::operator= (
00227   <span class="keyword">const</span> <a class="code" href="classLLRP_1_1llrp__u16v__t.html">llrp_u16v_t</a> &amp;           rOther)
00228 {
00229     <span class="keywordflow">if</span>(<span class="keyword">this</span> != &amp;rOther)
00230     {
00231         reset();
00232         copy(rOther);
00233     }
00234 
00235     <span class="keywordflow">return</span> *<span class="keyword">this</span>;
00236 }
00237 
00238 <span class="keywordtype">void</span>
00239 llrp_u16v_t::reset(<span class="keywordtype">void</span>)
00240 {
00241     <span class="keywordflow">if</span>(NULL != m_pValue)
00242     {
00243         <span class="keyword">delete</span>[] m_pValue;
00244         m_pValue = NULL;
00245     }
00246     m_nValue = 0;
00247 }
00248 
00249 <span class="keywordtype">void</span>
00250 llrp_u16v_t::copy (
00251   <span class="keyword">const</span> llrp_u16v_t &amp;           rOther)
00252 {
00253     <a class="code" href="classLLRP_1_1llrp__u16v__t.html#o0">m_nValue</a> = rOther.m_nValue;
00254     <span class="keywordflow">if</span>(0 &lt; m_nValue)
00255     {
00256         <a class="code" href="classLLRP_1_1llrp__u16v__t.html#o1">m_pValue</a> = <span class="keyword">new</span> llrp_u16_t[m_nValue];
00257         memcpy(m_pValue, rOther.m_pValue, <span class="keyword">sizeof</span> m_pValue[0] * m_nValue);
00258     }
00259     <span class="keywordflow">else</span>
00260     {
00261         <a class="code" href="classLLRP_1_1llrp__u16v__t.html#o1">m_pValue</a> = NULL;
00262     }
00263 }
00264 
00265 
00266 
00267 
00268 
00269 <span class="comment">/*</span>
00270 <span class="comment"> * s16v</span>
00271 <span class="comment"> */</span>
00272 
<a name="l00273"></a><a class="code" href="classLLRP_1_1llrp__s16v__t.html#a0">00273</a> llrp_s16v_t::llrp_s16v_t (<span class="keywordtype">void</span>)
00274 {
00275     <a class="code" href="classLLRP_1_1llrp__s16v__t.html#o1">m_pValue</a> = NULL;
00276     <a class="code" href="classLLRP_1_1llrp__s16v__t.html#o0">m_nValue</a> = 0;
00277 }
00278 
<a name="l00279"></a><a class="code" href="classLLRP_1_1llrp__s16v__t.html#a1">00279</a> llrp_s16v_t::llrp_s16v_t (
00280   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>                  nValue)
00281 {
00282     <a class="code" href="classLLRP_1_1llrp__s16v__t.html#o0">m_nValue</a> = nValue;
00283     <span class="keywordflow">if</span>(0 &lt; m_nValue)
00284     {
00285         <a class="code" href="classLLRP_1_1llrp__s16v__t.html#o1">m_pValue</a> = <span class="keyword">new</span> llrp_s16_t[m_nValue];
00286         memset(<a class="code" href="classLLRP_1_1llrp__s16v__t.html#o1">m_pValue</a>, 0, <span class="keyword">sizeof</span> <a class="code" href="classLLRP_1_1llrp__s16v__t.html#o1">m_pValue</a>[0] * <a class="code" href="classLLRP_1_1llrp__s16v__t.html#o0">m_nValue</a>);
00287     }
00288     <span class="keywordflow">else</span>
00289     {
00290         <a class="code" href="classLLRP_1_1llrp__s16v__t.html#o1">m_pValue</a> = NULL;
00291     }
00292 }
00293 
<a name="l00294"></a><a class="code" href="classLLRP_1_1llrp__s16v__t.html#a2">00294</a> llrp_s16v_t::llrp_s16v_t (
00295   <span class="keyword">const</span> <a class="code" href="classLLRP_1_1llrp__s16v__t.html">llrp_s16v_t</a> &amp;           rOther)
00296 {
00297     copy(rOther);
00298 }
00299 
<a name="l00300"></a><a class="code" href="classLLRP_1_1llrp__s16v__t.html#a3">00300</a> llrp_s16v_t::~llrp_s16v_t (<span class="keywordtype">void</span>)
00301 {
00302     reset();
00303 }
00304 
00305 <a class="code" href="classLLRP_1_1llrp__s16v__t.html">llrp_s16v_t</a> &amp;
<a name="l00306"></a><a class="code" href="classLLRP_1_1llrp__s16v__t.html#a4">00306</a> llrp_s16v_t::operator= (
00307   <span class="keyword">const</span> <a class="code" href="classLLRP_1_1llrp__s16v__t.html">llrp_s16v_t</a> &amp;           rOther)
00308 {
00309     <span class="keywordflow">if</span>(<span class="keyword">this</span> != &amp;rOther)
00310     {
00311         reset();
00312         copy(rOther);
00313     }
00314 
00315     <span class="keywordflow">return</span> *<span class="keyword">this</span>;
00316 }
00317 
00318 <span class="keywordtype">void</span>
00319 llrp_s16v_t::reset(<span class="keywordtype">void</span>)
00320 {
00321     <span class="keywordflow">if</span>(NULL != m_pValue)
00322     {
00323         <span class="keyword">delete</span>[] m_pValue;
00324         m_pValue = NULL;
00325     }
00326     m_nValue = 0;
00327 }
00328 
00329 <span class="keywordtype">void</span>
00330 llrp_s16v_t::copy (
00331   <span class="keyword">const</span> llrp_s16v_t &amp;           rOther)
00332 {
00333     <a class="code" href="classLLRP_1_1llrp__s16v__t.html#o0">m_nValue</a> = rOther.m_nValue;
00334     <span class="keywordflow">if</span>(0 &lt; m_nValue)
00335     {
00336         <a class="code" href="classLLRP_1_1llrp__s16v__t.html#o1">m_pValue</a> = <span class="keyword">new</span> llrp_s16_t[m_nValue];
00337         memcpy(m_pValue, rOther.m_pValue, <span class="keyword">sizeof</span> m_pValue[0] * m_nValue);
00338     }
00339     <span class="keywordflow">else</span>
00340     {
00341         <a class="code" href="classLLRP_1_1llrp__s16v__t.html#o1">m_pValue</a> = NULL;
00342     }
00343 }
00344 
00345 
00346 
00347 
00348 
00349 <span class="comment">/*</span>
00350 <span class="comment"> * u32v</span>
00351 <span class="comment"> */</span>
00352 
<a name="l00353"></a><a class="code" href="classLLRP_1_1llrp__u32v__t.html#a0">00353</a> llrp_u32v_t::llrp_u32v_t (<span class="keywordtype">void</span>)
00354 {
00355     <a class="code" href="classLLRP_1_1llrp__u32v__t.html#o1">m_pValue</a> = NULL;
00356     <a class="code" href="classLLRP_1_1llrp__u32v__t.html#o0">m_nValue</a> = 0;
00357 }
00358 
<a name="l00359"></a><a class="code" href="classLLRP_1_1llrp__u32v__t.html#a1">00359</a> llrp_u32v_t::llrp_u32v_t (
00360   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>                  nValue)
00361 {
00362     <a class="code" href="classLLRP_1_1llrp__u32v__t.html#o0">m_nValue</a> = nValue;
00363     <span class="keywordflow">if</span>(0 &lt; m_nValue)
00364     {
00365         <a class="code" href="classLLRP_1_1llrp__u32v__t.html#o1">m_pValue</a> = <span class="keyword">new</span> llrp_u32_t[m_nValue];
00366         memset(<a class="code" href="classLLRP_1_1llrp__u32v__t.html#o1">m_pValue</a>, 0, <span class="keyword">sizeof</span> <a class="code" href="classLLRP_1_1llrp__u32v__t.html#o1">m_pValue</a>[0] * <a class="code" href="classLLRP_1_1llrp__u32v__t.html#o0">m_nValue</a>);
00367     }
00368     <span class="keywordflow">else</span>
00369     {
00370         <a class="code" href="classLLRP_1_1llrp__u32v__t.html#o1">m_pValue</a> = NULL;
00371     }
00372 }
00373 
<a name="l00374"></a><a class="code" href="classLLRP_1_1llrp__u32v__t.html#a2">00374</a> llrp_u32v_t::llrp_u32v_t (
00375   <span class="keyword">const</span> <a class="code" href="classLLRP_1_1llrp__u32v__t.html">llrp_u32v_t</a> &amp;           rOther)
00376 {
00377     copy(rOther);
00378 }
00379 
<a name="l00380"></a><a class="code" href="classLLRP_1_1llrp__u32v__t.html#a3">00380</a> llrp_u32v_t::~llrp_u32v_t (<span class="keywordtype">void</span>)
00381 {
00382     reset();
00383 }
00384 
00385 <a class="code" href="classLLRP_1_1llrp__u32v__t.html">llrp_u32v_t</a> &amp;
<a name="l00386"></a><a class="code" href="classLLRP_1_1llrp__u32v__t.html#a4">00386</a> llrp_u32v_t::operator= (
00387   <span class="keyword">const</span> <a class="code" href="classLLRP_1_1llrp__u32v__t.html">llrp_u32v_t</a> &amp;           rOther)
00388 {
00389     <span class="keywordflow">if</span>(<span class="keyword">this</span> != &amp;rOther)
00390     {
00391         reset();
00392         copy(rOther);
00393     }
00394 
00395     <span class="keywordflow">return</span> *<span class="keyword">this</span>;
00396 }
00397 
00398 <span class="keywordtype">void</span>
00399 llrp_u32v_t::reset(<span class="keywordtype">void</span>)
00400 {
00401     <span class="keywordflow">if</span>(NULL != m_pValue)
00402     {
00403         <span class="keyword">delete</span>[] m_pValue;
00404         m_pValue = NULL;
00405     }
00406     m_nValue = 0;
00407 }
00408 
00409 <span class="keywordtype">void</span>
00410 llrp_u32v_t::copy (
00411   <span class="keyword">const</span> llrp_u32v_t &amp;           rOther)
00412 {
00413     <a class="code" href="classLLRP_1_1llrp__u32v__t.html#o0">m_nValue</a> = rOther.m_nValue;
00414     <span class="keywordflow">if</span>(0 &lt; m_nValue)
00415     {
00416         <a class="code" href="classLLRP_1_1llrp__u32v__t.html#o1">m_pValue</a> = <span class="keyword">new</span> llrp_u32_t[m_nValue];
00417         memcpy(m_pValue, rOther.m_pValue, <span class="keyword">sizeof</span> m_pValue[0] * m_nValue);
00418     }
00419     <span class="keywordflow">else</span>
00420     {
00421         <a class="code" href="classLLRP_1_1llrp__u32v__t.html#o1">m_pValue</a> = NULL;
00422     }
00423 }
00424 
00425 
00426 
00427 
00428 
00429 <span class="comment">/*</span>
00430 <span class="comment"> * s32v</span>
00431 <span class="comment"> */</span>
00432 
<a name="l00433"></a><a class="code" href="classLLRP_1_1llrp__s32v__t.html#a0">00433</a> llrp_s32v_t::llrp_s32v_t (<span class="keywordtype">void</span>)
00434 {
00435     <a class="code" href="classLLRP_1_1llrp__s32v__t.html#o1">m_pValue</a> = NULL;
00436     <a class="code" href="classLLRP_1_1llrp__s32v__t.html#o0">m_nValue</a> = 0;
00437 }
00438 
<a name="l00439"></a><a class="code" href="classLLRP_1_1llrp__s32v__t.html#a1">00439</a> llrp_s32v_t::llrp_s32v_t (
00440   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>                  nValue)
00441 {
00442     <a class="code" href="classLLRP_1_1llrp__s32v__t.html#o0">m_nValue</a> = nValue;
00443     <span class="keywordflow">if</span>(0 &lt; m_nValue)
00444     {
00445         <a class="code" href="classLLRP_1_1llrp__s32v__t.html#o1">m_pValue</a> = <span class="keyword">new</span> llrp_s32_t[m_nValue];
00446         memset(<a class="code" href="classLLRP_1_1llrp__s32v__t.html#o1">m_pValue</a>, 0, <span class="keyword">sizeof</span> <a class="code" href="classLLRP_1_1llrp__s32v__t.html#o1">m_pValue</a>[0] * <a class="code" href="classLLRP_1_1llrp__s32v__t.html#o0">m_nValue</a>);
00447     }
00448     <span class="keywordflow">else</span>
00449     {
00450         <a class="code" href="classLLRP_1_1llrp__s32v__t.html#o1">m_pValue</a> = NULL;
00451     }
00452 }
00453 
<a name="l00454"></a><a class="code" href="classLLRP_1_1llrp__s32v__t.html#a2">00454</a> llrp_s32v_t::llrp_s32v_t (
00455   <span class="keyword">const</span> <a class="code" href="classLLRP_1_1llrp__s32v__t.html">llrp_s32v_t</a> &amp;           rOther)
00456 {
00457     copy(rOther);
00458 }
00459 
<a name="l00460"></a><a class="code" href="classLLRP_1_1llrp__s32v__t.html#a3">00460</a> llrp_s32v_t::~llrp_s32v_t (<span class="keywordtype">void</span>)
00461 {
00462     reset();
00463 }
00464 
00465 <a class="code" href="classLLRP_1_1llrp__s32v__t.html">llrp_s32v_t</a> &amp;
<a name="l00466"></a><a class="code" href="classLLRP_1_1llrp__s32v__t.html#a4">00466</a> llrp_s32v_t::operator= (
00467   <span class="keyword">const</span> <a class="code" href="classLLRP_1_1llrp__s32v__t.html">llrp_s32v_t</a> &amp;           rOther)
00468 {
00469     <span class="keywordflow">if</span>(<span class="keyword">this</span> != &amp;rOther)
00470     {
00471         reset();
00472         copy(rOther);
00473     }
00474 
00475     <span class="keywordflow">return</span> *<span class="keyword">this</span>;
00476 }
00477 
00478 <span class="keywordtype">void</span>
00479 llrp_s32v_t::reset(<span class="keywordtype">void</span>)
00480 {
00481     <span class="keywordflow">if</span>(NULL != m_pValue)
00482     {
00483         <span class="keyword">delete</span>[] m_pValue;
00484         m_pValue = NULL;
00485     }
00486     m_nValue = 0;
00487 }
00488 
00489 <span class="keywordtype">void</span>
00490 llrp_s32v_t::copy (
00491   <span class="keyword">const</span> llrp_s32v_t &amp;           rOther)
00492 {
00493     <a class="code" href="classLLRP_1_1llrp__s32v__t.html#o0">m_nValue</a> = rOther.m_nValue;
00494     <span class="keywordflow">if</span>(0 &lt; m_nValue)
00495     {
00496         <a class="code" href="classLLRP_1_1llrp__s32v__t.html#o1">m_pValue</a> = <span class="keyword">new</span> llrp_s32_t[m_nValue];
00497         memcpy(m_pValue, rOther.m_pValue, <span class="keyword">sizeof</span> m_pValue[0] * m_nValue);
00498     }
00499     <span class="keywordflow">else</span>
00500     {
00501         <a class="code" href="classLLRP_1_1llrp__s32v__t.html#o1">m_pValue</a> = NULL;
00502     }
00503 }
00504 
00505 
00506 
00507 
00508 
00509 <span class="comment">/*</span>
00510 <span class="comment"> * u64v</span>
00511 <span class="comment"> */</span>
00512 
<a name="l00513"></a><a class="code" href="classLLRP_1_1llrp__u64v__t.html#a0">00513</a> llrp_u64v_t::llrp_u64v_t (<span class="keywordtype">void</span>)
00514 {
00515     <a class="code" href="classLLRP_1_1llrp__u64v__t.html#o1">m_pValue</a> = NULL;
00516     <a class="code" href="classLLRP_1_1llrp__u64v__t.html#o0">m_nValue</a> = 0;
00517 }
00518 
<a name="l00519"></a><a class="code" href="classLLRP_1_1llrp__u64v__t.html#a1">00519</a> llrp_u64v_t::llrp_u64v_t (
00520   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>                  nValue)
00521 {
00522     <a class="code" href="classLLRP_1_1llrp__u64v__t.html#o0">m_nValue</a> = nValue;
00523     <span class="keywordflow">if</span>(0 &lt; m_nValue)
00524     {
00525         <a class="code" href="classLLRP_1_1llrp__u64v__t.html#o1">m_pValue</a> = <span class="keyword">new</span> llrp_u64_t[m_nValue];
00526         memset(<a class="code" href="classLLRP_1_1llrp__u64v__t.html#o1">m_pValue</a>, 0, <span class="keyword">sizeof</span> <a class="code" href="classLLRP_1_1llrp__u64v__t.html#o1">m_pValue</a>[0] * <a class="code" href="classLLRP_1_1llrp__u64v__t.html#o0">m_nValue</a>);
00527     }
00528     <span class="keywordflow">else</span>
00529     {
00530         <a class="code" href="classLLRP_1_1llrp__u64v__t.html#o1">m_pValue</a> = NULL;
00531     }
00532 }
00533 
<a name="l00534"></a><a class="code" href="classLLRP_1_1llrp__u64v__t.html#a2">00534</a> llrp_u64v_t::llrp_u64v_t (
00535   <span class="keyword">const</span> <a class="code" href="classLLRP_1_1llrp__u64v__t.html">llrp_u64v_t</a> &amp;           rOther)
00536 {
00537     copy(rOther);
00538 }
00539 
<a name="l00540"></a><a class="code" href="classLLRP_1_1llrp__u64v__t.html#a3">00540</a> llrp_u64v_t::~llrp_u64v_t (<span class="keywordtype">void</span>)
00541 {
00542     reset();
00543 }
00544 
00545 <a class="code" href="classLLRP_1_1llrp__u64v__t.html">llrp_u64v_t</a> &amp;
<a name="l00546"></a><a class="code" href="classLLRP_1_1llrp__u64v__t.html#a4">00546</a> llrp_u64v_t::operator= (
00547   <span class="keyword">const</span> <a class="code" href="classLLRP_1_1llrp__u64v__t.html">llrp_u64v_t</a> &amp;           rOther)
00548 {
00549     <span class="keywordflow">if</span>(<span class="keyword">this</span> != &amp;rOther)
00550     {
00551         reset();
00552         copy(rOther);
00553     }
00554 
00555     <span class="keywordflow">return</span> *<span class="keyword">this</span>;
00556 }
00557 
00558 <span class="keywordtype">void</span>
00559 llrp_u64v_t::reset(<span class="keywordtype">void</span>)
00560 {
00561     <span class="keywordflow">if</span>(NULL != m_pValue)
00562     {
00563         <span class="keyword">delete</span>[] m_pValue;
00564         m_pValue = NULL;
00565     }
00566     m_nValue = 0;
00567 }
00568 
00569 <span class="keywordtype">void</span>
00570 llrp_u64v_t::copy (
00571   <span class="keyword">const</span> llrp_u64v_t &amp;           rOther)
00572 {
00573     <a class="code" href="classLLRP_1_1llrp__u64v__t.html#o0">m_nValue</a> = rOther.m_nValue;
00574     <span class="keywordflow">if</span>(0 &lt; m_nValue)
00575     {
00576         <a class="code" href="classLLRP_1_1llrp__u64v__t.html#o1">m_pValue</a> = <span class="keyword">new</span> llrp_u64_t[m_nValue];
00577         memcpy(m_pValue, rOther.m_pValue, <span class="keyword">sizeof</span> m_pValue[0] * m_nValue);
00578     }
00579     <span class="keywordflow">else</span>
00580     {
00581         <a class="code" href="classLLRP_1_1llrp__u64v__t.html#o1">m_pValue</a> = NULL;
00582     }
00583 }
00584 
00585 
00586 
00587 
00588 
00589 <span class="comment">/*</span>
00590 <span class="comment"> * s64v</span>
00591 <span class="comment"> */</span>
00592 
<a name="l00593"></a><a class="code" href="classLLRP_1_1llrp__s64v__t.html#a0">00593</a> llrp_s64v_t::llrp_s64v_t (<span class="keywordtype">void</span>)
00594 {
00595     <a class="code" href="classLLRP_1_1llrp__s64v__t.html#o1">m_pValue</a> = NULL;
00596     <a class="code" href="classLLRP_1_1llrp__s64v__t.html#o0">m_nValue</a> = 0;
00597 }
00598 
<a name="l00599"></a><a class="code" href="classLLRP_1_1llrp__s64v__t.html#a1">00599</a> llrp_s64v_t::llrp_s64v_t (
00600   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>                  nValue)
00601 {
00602     <a class="code" href="classLLRP_1_1llrp__s64v__t.html#o0">m_nValue</a> = nValue;
00603     <span class="keywordflow">if</span>(0 &lt; m_nValue)
00604     {
00605         <a class="code" href="classLLRP_1_1llrp__s64v__t.html#o1">m_pValue</a> = <span class="keyword">new</span> llrp_s64_t[m_nValue];
00606         memset(<a class="code" href="classLLRP_1_1llrp__s64v__t.html#o1">m_pValue</a>, 0, <span class="keyword">sizeof</span> <a class="code" href="classLLRP_1_1llrp__s64v__t.html#o1">m_pValue</a>[0] * <a class="code" href="classLLRP_1_1llrp__s64v__t.html#o0">m_nValue</a>);
00607     }
00608     <span class="keywordflow">else</span>
00609     {
00610         <a class="code" href="classLLRP_1_1llrp__s64v__t.html#o1">m_pValue</a> = NULL;
00611     }
00612 }
00613 
<a name="l00614"></a><a class="code" href="classLLRP_1_1llrp__s64v__t.html#a2">00614</a> llrp_s64v_t::llrp_s64v_t (
00615   <span class="keyword">const</span> <a class="code" href="classLLRP_1_1llrp__s64v__t.html">llrp_s64v_t</a> &amp;           rOther)
00616 {
00617     copy(rOther);
00618 }
00619 
<a name="l00620"></a><a class="code" href="classLLRP_1_1llrp__s64v__t.html#a3">00620</a> llrp_s64v_t::~llrp_s64v_t (<span class="keywordtype">void</span>)
00621 {
00622     reset();
00623 }
00624 
00625 <a class="code" href="classLLRP_1_1llrp__s64v__t.html">llrp_s64v_t</a> &amp;
<a name="l00626"></a><a class="code" href="classLLRP_1_1llrp__s64v__t.html#a4">00626</a> llrp_s64v_t::operator= (
00627   <span class="keyword">const</span> <a class="code" href="classLLRP_1_1llrp__s64v__t.html">llrp_s64v_t</a> &amp;           rOther)
00628 {
00629     <span class="keywordflow">if</span>(<span class="keyword">this</span> != &amp;rOther)
00630     {
00631         reset();
00632         copy(rOther);
00633     }
00634 
00635     <span class="keywordflow">return</span> *<span class="keyword">this</span>;
00636 }
00637 
00638 <span class="keywordtype">void</span>
00639 llrp_s64v_t::reset(<span class="keywordtype">void</span>)
00640 {
00641     <span class="keywordflow">if</span>(NULL != m_pValue)
00642     {
00643         <span class="keyword">delete</span>[] m_pValue;
00644         m_pValue = NULL;
00645     }
00646     m_nValue = 0;
00647 }
00648 
00649 <span class="keywordtype">void</span>
00650 llrp_s64v_t::copy (
00651   <span class="keyword">const</span> llrp_s64v_t &amp;           rOther)
00652 {
00653     <a class="code" href="classLLRP_1_1llrp__s64v__t.html#o0">m_nValue</a> = rOther.m_nValue;
00654     <span class="keywordflow">if</span>(0 &lt; m_nValue)
00655     {
00656         <a class="code" href="classLLRP_1_1llrp__s64v__t.html#o1">m_pValue</a> = <span class="keyword">new</span> llrp_s64_t[m_nValue];
00657         memcpy(m_pValue, rOther.m_pValue, <span class="keyword">sizeof</span> m_pValue[0] * m_nValue);
00658     }
00659     <span class="keywordflow">else</span>
00660     {
00661         <a class="code" href="classLLRP_1_1llrp__s64v__t.html#o1">m_pValue</a> = NULL;
00662     }
00663 }
00664 
00665 
00666 
00667 
00668 
00669 <span class="comment">/*</span>
00670 <span class="comment"> * u1v</span>
00671 <span class="comment"> */</span>
00672 
<a name="l00673"></a><a class="code" href="classLLRP_1_1llrp__u1v__t.html#a0">00673</a> llrp_u1v_t::llrp_u1v_t (<span class="keywordtype">void</span>)
00674 {
00675     <a class="code" href="classLLRP_1_1llrp__u1v__t.html#o1">m_pValue</a> = NULL;
00676     <a class="code" href="classLLRP_1_1llrp__u1v__t.html#o0">m_nBit</a> = 0;
00677 }
00678 
<a name="l00679"></a><a class="code" href="classLLRP_1_1llrp__u1v__t.html#a1">00679</a> llrp_u1v_t::llrp_u1v_t (
00680   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>                  nBit)
00681 {
00682     <a class="code" href="classLLRP_1_1llrp__u1v__t.html#o0">m_nBit</a> = nBit;
00683     <span class="keywordflow">if</span>(0 &lt; m_nBit)
00684     {
00685         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>            nByte = (<a class="code" href="classLLRP_1_1llrp__u1v__t.html#o0">m_nBit</a> + 7u) / 8u;
00686 
00687         <a class="code" href="classLLRP_1_1llrp__u1v__t.html#o1">m_pValue</a> = <span class="keyword">new</span> llrp_byte_t[nByte];
00688         memset(<a class="code" href="classLLRP_1_1llrp__u1v__t.html#o1">m_pValue</a>, 0, nByte);
00689     }
00690     <span class="keywordflow">else</span>
00691     {
00692         <a class="code" href="classLLRP_1_1llrp__u1v__t.html#o1">m_pValue</a> = NULL;
00693     }
00694 }
00695 
<a name="l00696"></a><a class="code" href="classLLRP_1_1llrp__u1v__t.html#a2">00696</a> llrp_u1v_t::llrp_u1v_t (
00697   <span class="keyword">const</span> <a class="code" href="classLLRP_1_1llrp__u1v__t.html">llrp_u1v_t</a> &amp;           rOther)
00698 {
00699     copy(rOther);
00700 }
00701 
<a name="l00702"></a><a class="code" href="classLLRP_1_1llrp__u1v__t.html#a3">00702</a> llrp_u1v_t::~llrp_u1v_t (<span class="keywordtype">void</span>)
00703 {
00704     reset();
00705 }
00706 
00707 <a class="code" href="classLLRP_1_1llrp__u1v__t.html">llrp_u1v_t</a> &amp;
<a name="l00708"></a><a class="code" href="classLLRP_1_1llrp__u1v__t.html#a4">00708</a> llrp_u1v_t::operator= (
00709   <span class="keyword">const</span> <a class="code" href="classLLRP_1_1llrp__u1v__t.html">llrp_u1v_t</a> &amp;           rOther)
00710 {
00711     <span class="keywordflow">if</span>(<span class="keyword">this</span> != &amp;rOther)
00712     {
00713         reset();
00714         copy(rOther);
00715     }
00716 
00717     <span class="keywordflow">return</span> *<span class="keyword">this</span>;
00718 }
00719 
00720 <span class="keywordtype">void</span>
00721 llrp_u1v_t::reset(<span class="keywordtype">void</span>)
00722 {
00723     <span class="keywordflow">if</span>(NULL != m_pValue)
00724     {
00725         <span class="keyword">delete</span>[] m_pValue;
00726         m_pValue = NULL;
00727     }
00728     m_nBit = 0;
00729 }
00730 
00731 <span class="keywordtype">void</span>
00732 llrp_u1v_t::copy (
00733   <span class="keyword">const</span> llrp_u1v_t &amp;           rOther)
00734 {
00735     <a class="code" href="classLLRP_1_1llrp__u1v__t.html#o0">m_nBit</a> = rOther.m_nBit;
00736     <span class="keywordflow">if</span>(0 &lt; m_nBit)
00737     {
00738         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>            nByte = (<a class="code" href="classLLRP_1_1llrp__u1v__t.html#o0">m_nBit</a> + 7u) / 8u;
00739 
00740         <a class="code" href="classLLRP_1_1llrp__u1v__t.html#o1">m_pValue</a> = <span class="keyword">new</span> llrp_byte_t[nByte];
00741         memcpy(m_pValue, rOther.m_pValue, nByte);
00742     }
00743     <span class="keywordflow">else</span>
00744     {
00745         <a class="code" href="classLLRP_1_1llrp__u1v__t.html#o1">m_pValue</a> = NULL;
00746     }
00747 }
00748 
00749 
00750 
00751 
00752 
00753 <span class="comment">/*</span>
00754 <span class="comment"> * utf8v</span>
00755 <span class="comment"> */</span>
00756 
<a name="l00757"></a><a class="code" href="classLLRP_1_1llrp__utf8v__t.html#a0">00757</a> llrp_utf8v_t::llrp_utf8v_t (<span class="keywordtype">void</span>)
00758 {
00759     <a class="code" href="classLLRP_1_1llrp__utf8v__t.html#o1">m_pValue</a> = NULL;
00760     <a class="code" href="classLLRP_1_1llrp__utf8v__t.html#o0">m_nValue</a> = 0;
00761 }
00762 
<a name="l00763"></a><a class="code" href="classLLRP_1_1llrp__utf8v__t.html#a1">00763</a> llrp_utf8v_t::llrp_utf8v_t (
00764   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>                  nValue)
00765 {
00766     <a class="code" href="classLLRP_1_1llrp__utf8v__t.html#o0">m_nValue</a> = nValue;
00767     <span class="keywordflow">if</span>(0 &lt; m_nValue)
00768     {
00769         <a class="code" href="classLLRP_1_1llrp__utf8v__t.html#o1">m_pValue</a> = <span class="keyword">new</span> llrp_utf8_t[m_nValue];
00770         memset(<a class="code" href="classLLRP_1_1llrp__utf8v__t.html#o1">m_pValue</a>, 0, <span class="keyword">sizeof</span> <a class="code" href="classLLRP_1_1llrp__utf8v__t.html#o1">m_pValue</a>[0] * <a class="code" href="classLLRP_1_1llrp__utf8v__t.html#o0">m_nValue</a>);
00771     }
00772     <span class="keywordflow">else</span>
00773     {
00774         <a class="code" href="classLLRP_1_1llrp__utf8v__t.html#o1">m_pValue</a> = NULL;
00775     }
00776 }
00777 
<a name="l00778"></a><a class="code" href="classLLRP_1_1llrp__utf8v__t.html#a2">00778</a> llrp_utf8v_t::llrp_utf8v_t (
00779   <span class="keyword">const</span> <a class="code" href="classLLRP_1_1llrp__utf8v__t.html">llrp_utf8v_t</a> &amp;           rOther)
00780 {
00781     copy(rOther);
00782 }
00783 
<a name="l00784"></a><a class="code" href="classLLRP_1_1llrp__utf8v__t.html#a3">00784</a> llrp_utf8v_t::~llrp_utf8v_t (<span class="keywordtype">void</span>)
00785 {
00786     reset();
00787 }
00788 
00789 <a class="code" href="classLLRP_1_1llrp__utf8v__t.html">llrp_utf8v_t</a> &amp;
<a name="l00790"></a><a class="code" href="classLLRP_1_1llrp__utf8v__t.html#a4">00790</a> llrp_utf8v_t::operator= (
00791   <span class="keyword">const</span> <a class="code" href="classLLRP_1_1llrp__utf8v__t.html">llrp_utf8v_t</a> &amp;           rOther)
00792 {
00793     <span class="keywordflow">if</span>(<span class="keyword">this</span> != &amp;rOther)
00794     {
00795         reset();
00796         copy(rOther);
00797     }
00798 
00799     <span class="keywordflow">return</span> *<span class="keyword">this</span>;
00800 }
00801 
00802 <span class="keywordtype">void</span>
00803 llrp_utf8v_t::reset(<span class="keywordtype">void</span>)
00804 {
00805     <span class="keywordflow">if</span>(NULL != m_pValue)
00806     {
00807         <span class="keyword">delete</span>[] m_pValue;
00808         m_pValue = NULL;
00809     }
00810     m_nValue = 0;
00811 }
00812 
00813 <span class="keywordtype">void</span>
00814 llrp_utf8v_t::copy (
00815   <span class="keyword">const</span> llrp_utf8v_t &amp;           rOther)
00816 {
00817     <a class="code" href="classLLRP_1_1llrp__utf8v__t.html#o0">m_nValue</a> = rOther.m_nValue;
00818     <span class="keywordflow">if</span>(0 &lt; m_nValue)
00819     {
00820         <a class="code" href="classLLRP_1_1llrp__utf8v__t.html#o1">m_pValue</a> = <span class="keyword">new</span> llrp_utf8_t[m_nValue];
00821         memcpy(m_pValue, rOther.m_pValue, <span class="keyword">sizeof</span> m_pValue[0] * m_nValue);
00822     }
00823     <span class="keywordflow">else</span>
00824     {
00825         <a class="code" href="classLLRP_1_1llrp__utf8v__t.html#o1">m_pValue</a> = NULL;
00826     }
00827 }
00828 
00829 
00830 
00831 
00832 
00833 <span class="comment">/*</span>
00834 <span class="comment"> * bytesToEnd</span>
00835 <span class="comment"> */</span>
00836 
<a name="l00837"></a><a class="code" href="classLLRP_1_1llrp__bytesToEnd__t.html#a0">00837</a> llrp_bytesToEnd_t::llrp_bytesToEnd_t (<span class="keywordtype">void</span>)
00838 {
00839     <a class="code" href="classLLRP_1_1llrp__bytesToEnd__t.html#o1">m_pValue</a> = NULL;
00840     <a class="code" href="classLLRP_1_1llrp__bytesToEnd__t.html#o0">m_nValue</a> = 0;
00841 }
00842 
<a name="l00843"></a><a class="code" href="classLLRP_1_1llrp__bytesToEnd__t.html#a1">00843</a> llrp_bytesToEnd_t::llrp_bytesToEnd_t (
00844   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>                  nValue)
00845 {
00846     <a class="code" href="classLLRP_1_1llrp__bytesToEnd__t.html#o0">m_nValue</a> = nValue;
00847     <span class="keywordflow">if</span>(0 &lt; m_nValue)
00848     {
00849         <a class="code" href="classLLRP_1_1llrp__bytesToEnd__t.html#o1">m_pValue</a> = <span class="keyword">new</span> llrp_byte_t[m_nValue];
00850         memset(<a class="code" href="classLLRP_1_1llrp__bytesToEnd__t.html#o1">m_pValue</a>, 0, <span class="keyword">sizeof</span> <a class="code" href="classLLRP_1_1llrp__bytesToEnd__t.html#o1">m_pValue</a>[0] * <a class="code" href="classLLRP_1_1llrp__bytesToEnd__t.html#o0">m_nValue</a>);
00851     }
00852     <span class="keywordflow">else</span>
00853     {
00854         <a class="code" href="classLLRP_1_1llrp__bytesToEnd__t.html#o1">m_pValue</a> = NULL;
00855     }
00856 }
00857 
<a name="l00858"></a><a class="code" href="classLLRP_1_1llrp__bytesToEnd__t.html#a2">00858</a> llrp_bytesToEnd_t::llrp_bytesToEnd_t (
00859   <span class="keyword">const</span> <a class="code" href="classLLRP_1_1llrp__bytesToEnd__t.html">llrp_bytesToEnd_t</a> &amp;           rOther)
00860 {
00861     copy(rOther);
00862 }
00863 
<a name="l00864"></a><a class="code" href="classLLRP_1_1llrp__bytesToEnd__t.html#a3">00864</a> llrp_bytesToEnd_t::~llrp_bytesToEnd_t (<span class="keywordtype">void</span>)
00865 {
00866     reset();
00867 }
00868 
00869 <a class="code" href="classLLRP_1_1llrp__bytesToEnd__t.html">llrp_bytesToEnd_t</a> &amp;
<a name="l00870"></a><a class="code" href="classLLRP_1_1llrp__bytesToEnd__t.html#a4">00870</a> llrp_bytesToEnd_t::operator= (
00871   <span class="keyword">const</span> <a class="code" href="classLLRP_1_1llrp__bytesToEnd__t.html">llrp_bytesToEnd_t</a> &amp;           rOther)
00872 {
00873     <span class="keywordflow">if</span>(<span class="keyword">this</span> != &amp;rOther)
00874     {
00875         reset();
00876         copy(rOther);
00877     }
00878 
00879     <span class="keywordflow">return</span> *<span class="keyword">this</span>;
00880 }
00881 
00882 <span class="keywordtype">void</span>
00883 llrp_bytesToEnd_t::reset(<span class="keywordtype">void</span>)
00884 {
00885     <span class="keywordflow">if</span>(NULL != m_pValue)
00886     {
00887         <span class="keyword">delete</span>[] m_pValue;
00888         m_pValue = NULL;
00889     }
00890     m_nValue = 0;
00891 }
00892 
00893 <span class="keywordtype">void</span>
00894 llrp_bytesToEnd_t::copy (
00895   <span class="keyword">const</span> llrp_bytesToEnd_t &amp;           rOther)
00896 {
00897     <a class="code" href="classLLRP_1_1llrp__bytesToEnd__t.html#o0">m_nValue</a> = rOther.m_nValue;
00898     <span class="keywordflow">if</span>(0 &lt; m_nValue)
00899     {
00900         <a class="code" href="classLLRP_1_1llrp__bytesToEnd__t.html#o1">m_pValue</a> = <span class="keyword">new</span> llrp_byte_t[m_nValue];
00901         memcpy(m_pValue, rOther.m_pValue, <span class="keyword">sizeof</span> m_pValue[0] * m_nValue);
00902     }
00903     <span class="keywordflow">else</span>
00904     {
00905         <a class="code" href="classLLRP_1_1llrp__bytesToEnd__t.html#o1">m_pValue</a> = NULL;
00906     }
00907 }
00908 
00909 
00910 
00911 }; <span class="comment">/* namespace LLRP */</span>
00912 
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Wed Feb 24 09:16:20 2010 for LTKCPP-- LLRP Toolkit C Plus Plus Library by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.3.9.1 </small></address>
</body>
</html>
