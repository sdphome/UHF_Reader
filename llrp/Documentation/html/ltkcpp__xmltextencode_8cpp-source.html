<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>LTKCPP-- LLRP Toolkit C Plus Plus Library: ltkcpp_xmltextencode.cpp Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.9.1 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="namespacemembers.html">Namespace&nbsp;Members</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a></div>
<div class="nav">
<a class="el" href="dir_000002.html">Library</a></div>
<h1>ltkcpp_xmltextencode.cpp</h1><div class="fragment"><pre class="fragment">00001 
00002 <span class="comment">/*</span>
00003 <span class="comment"> ***************************************************************************</span>
00004 <span class="comment"> *  Copyright 2007,2008 Impinj, Inc.</span>
00005 <span class="comment"> *</span>
00006 <span class="comment"> *  Licensed under the Apache License, Version 2.0 (the "License");</span>
00007 <span class="comment"> *  you may not use this file except in compliance with the License.</span>
00008 <span class="comment"> *  You may obtain a copy of the License at</span>
00009 <span class="comment"> *</span>
00010 <span class="comment"> *      http://www.apache.org/licenses/LICENSE-2.0</span>
00011 <span class="comment"> *</span>
00012 <span class="comment"> *  Unless required by applicable law or agreed to in writing, software</span>
00013 <span class="comment"> *  distributed under the License is distributed on an "AS IS" BASIS,</span>
00014 <span class="comment"> *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
00015 <span class="comment"> *  See the License for the specific language governing permissions and</span>
00016 <span class="comment"> *  limitations under the License.</span>
00017 <span class="comment"> *</span>
00018 <span class="comment"> ***************************************************************************</span>
00019 <span class="comment"> */</span>
00020 
00021 
00022 <span class="preprocessor">#include &lt;stdio.h&gt;</span>
00023 <span class="preprocessor">#include &lt;stdarg.h&gt;</span>
00024 <span class="preprocessor">#include &lt;time.h&gt;</span>
00025 
00026 <span class="preprocessor">#include "<a class="code" href="ltkcpp__platform_8h.html">ltkcpp_platform.h</a>"</span>
00027 <span class="preprocessor">#include "<a class="code" href="ltkcpp__base_8h.html">ltkcpp_base.h</a>"</span>
00028 <span class="preprocessor">#include "<a class="code" href="ltkcpp__xmltext_8h.html">ltkcpp_xmltext.h</a>"</span>
00029 
00030 
00031 
00032 <span class="keyword">namespace </span>LLRP
00033 {
00034 
00035 <span class="comment">/*</span>
00036 <span class="comment"> * Structures used by discoverNamespaces() and putElement().</span>
00037 <span class="comment"> */</span>
00038 <span class="preprocessor">#define MAX_NS      10</span>
00039 <span class="preprocessor"></span><span class="keyword">struct </span>NamespaceList
00040 {
00041     <span class="keyword">const</span> CNamespaceDescriptor *apNamespaceDescriptor[MAX_NS];
00042     <span class="keywordtype">int</span>                         nNamespaceDescriptor;
00043 };
00044 <span class="keyword">typedef</span> <span class="keyword">struct </span>NamespaceList    tNamespaceList;
00045 
00046 <span class="comment">/* forward */</span>
00047 <span class="keyword">static</span> <span class="keywordtype">int</span>
00048 discoverNamespaces (
00049   <span class="keyword">const</span> CElement *              pElement,
00050   <span class="keywordtype">void</span> *                        pArg);
00051 
00052 
00053 CXMLTextEncoder::CXMLTextEncoder (
00054   <span class="keywordtype">char</span> *                        pBuffer,
00055   <span class="keywordtype">int</span>                           nBuffer)
00056 {
00057     m_pBuffer = pBuffer;
00058     m_nBuffer = nBuffer;
00059     m_iNext = 0;
00060     m_bOverflow = 0;
00061 }
00062 
00063 CXMLTextEncoder::~CXMLTextEncoder (<span class="keywordtype">void</span>)
00064 {
00065 }
00066 
00067 <span class="keywordtype">void</span>
00068 CXMLTextEncoder::encodeElement (
00069   <span class="keyword">const</span> CElement *              pElement)
00070 {
00071     CXMLTextEncoderStream         MyEncoderStream(<span class="keyword">this</span>);
00072 
00073     MyEncoderStream.putElement(pElement);
00074 }
00075 
00076 <span class="keywordtype">void</span>
00077 CXMLTextEncoderStream::putRequiredSubParameter (
00078   <span class="keyword">const</span> CParameter *            pParameter,
00079   <span class="keyword">const</span> CTypeDescriptor *       pRefType)
00080 {
00081     <span class="keywordflow">if</span>(NULL == pParameter)
00082     {
00083         appendFormat(<span class="stringliteral">"warning: missing %s\n"</span>,
00084             (NULL == pRefType) ? <span class="stringliteral">"&lt;something&gt;"</span> : pRefType-&gt;m_pName);
00085         <span class="keywordflow">return</span>;
00086     }
00087 
00088     CXMLTextEncoderStream         NestEncoderStream(<span class="keyword">this</span>);
00089 
00090     NestEncoderStream.putElement(pParameter);
00091 }
00092 
00093 <span class="keywordtype">void</span>
00094 CXMLTextEncoderStream::putOptionalSubParameter (
00095   <span class="keyword">const</span> CParameter *            pParameter,
00096   <span class="keyword">const</span> CTypeDescriptor *       pRefType)
00097 {
00098     <span class="keywordflow">if</span>(NULL == pParameter)
00099     {
00100         <span class="keywordflow">return</span>;
00101     }
00102 
00103     CXMLTextEncoderStream         NestEncoderStream(<span class="keyword">this</span>);
00104 
00105     NestEncoderStream.putElement(pParameter);
00106 }
00107 
00108 <span class="keywordtype">void</span>
00109 CXMLTextEncoderStream::putRequiredSubParameterList (
00110   <span class="keyword">const</span> tListOfParameters *     pParameterList,
00111   <span class="keyword">const</span> CTypeDescriptor *       pRefType)
00112 {
00113     <span class="keywordflow">if</span>(pParameterList-&gt;empty())
00114     {
00115         appendFormat(<span class="stringliteral">"warning: missing list of %s\n"</span>,
00116             (NULL == pRefType) ? <span class="stringliteral">"&lt;something&gt;"</span> : pRefType-&gt;m_pName);
00117         <span class="keywordflow">return</span>;
00118     }
00119 
00120     <span class="keywordflow">for</span>(
00121         tListOfParameters::const_iterator Cur = pParameterList-&gt;begin();
00122         Cur != pParameterList-&gt;end();
00123         Cur++)
00124     {
00125         putRequiredSubParameter(*Cur, pRefType);
00126     }
00127 }
00128 
00129 <span class="keywordtype">void</span>
00130 CXMLTextEncoderStream::putOptionalSubParameterList (
00131   <span class="keyword">const</span> tListOfParameters *     pParameterList,
00132   <span class="keyword">const</span> CTypeDescriptor *       pRefType)
00133 {
00134     <span class="keywordflow">for</span>(
00135         tListOfParameters::const_iterator Cur = pParameterList-&gt;begin();
00136         Cur != pParameterList-&gt;end();
00137         Cur++)
00138     {
00139         putRequiredSubParameter(*Cur, pRefType);
00140     }
00141 }
00142 
00143 
00144 <span class="comment">/*</span>
00145 <span class="comment"> * 8-bit types</span>
00146 <span class="comment"> */</span>
00147 
00148 <span class="keywordtype">void</span>
00149 CXMLTextEncoderStream::put_u8 (
00150   llrp_u8_t                     Value,
00151   <span class="keyword">const</span> CFieldDescriptor *      pFieldDescriptor)
00152 {
00153     <span class="keyword">const</span> <span class="keywordtype">char</span> *                pFieldName = pFieldDescriptor-&gt;m_pName;
00154 
00155     appendOpenTag(pFieldName);
00156     <span class="keywordflow">switch</span>(pFieldDescriptor-&gt;m_eFieldFormat)
00157     {
00158     <span class="keywordflow">case</span> CFieldDescriptor::FMT_NORMAL:
00159     <span class="keywordflow">case</span> CFieldDescriptor::FMT_DEC:
00160     <span class="keywordflow">default</span>:
00161         appendFormat(<span class="stringliteral">"%u"</span>, Value);
00162         <span class="keywordflow">break</span>;
00163 
00164     <span class="keywordflow">case</span> CFieldDescriptor::FMT_HEX:
00165         appendFormat(<span class="stringliteral">"%02X"</span>, Value);
00166         <span class="keywordflow">break</span>;
00167     }
00168     appendCloseTag(pFieldName);
00169 }
00170 
00171 <span class="keywordtype">void</span>
00172 CXMLTextEncoderStream::put_s8 (
00173   llrp_s8_t                     Value,
00174   <span class="keyword">const</span> CFieldDescriptor *      pFieldDescriptor)
00175 {
00176     <span class="keyword">const</span> <span class="keywordtype">char</span> *                pFieldName = pFieldDescriptor-&gt;m_pName;
00177 
00178     appendOpenTag(pFieldName);
00179     <span class="keywordflow">switch</span>(pFieldDescriptor-&gt;m_eFieldFormat)
00180     {
00181     <span class="keywordflow">case</span> CFieldDescriptor::FMT_NORMAL:
00182     <span class="keywordflow">case</span> CFieldDescriptor::FMT_DEC:
00183     <span class="keywordflow">default</span>:
00184         appendFormat(<span class="stringliteral">"%d"</span>, Value);
00185         <span class="keywordflow">break</span>;
00186 
00187     <span class="keywordflow">case</span> CFieldDescriptor::FMT_HEX:
00188         appendFormat(<span class="stringliteral">"%02X"</span>, 0xFF &amp; Value);
00189         <span class="keywordflow">break</span>;
00190     }
00191     appendCloseTag(pFieldName);
00192 }
00193 
00194 <span class="keywordtype">void</span>
00195 CXMLTextEncoderStream::put_u8v (
00196   llrp_u8v_t                    Value,
00197   <span class="keyword">const</span> CFieldDescriptor *      pFieldDescriptor)
00198 {
00199     <span class="keyword">const</span> <span class="keywordtype">char</span> *                pFieldName = pFieldDescriptor-&gt;m_pName;
00200 
00201     appendOpenTag(pFieldName);
00202     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; Value.m_nValue; i++)
00203     {
00204         <span class="keywordflow">switch</span>(pFieldDescriptor-&gt;m_eFieldFormat)
00205         {
00206         <span class="keywordflow">case</span> CFieldDescriptor::FMT_NORMAL:
00207         <span class="keywordflow">case</span> CFieldDescriptor::FMT_DEC:
00208         <span class="keywordflow">default</span>:
00209             <span class="keywordflow">if</span>(0 &lt; i)
00210             {
00211                 appendFormat(<span class="stringliteral">" "</span>);
00212             }
00213             appendFormat(<span class="stringliteral">"%u"</span>, Value.m_pValue[i]);
00214             <span class="keywordflow">break</span>;
00215 
00216         <span class="keywordflow">case</span> CFieldDescriptor::FMT_HEX:
00217             appendFormat(<span class="stringliteral">"%02X"</span>, 0xFF &amp; Value.m_pValue[i]);
00218             <span class="keywordflow">break</span>;
00219         }
00220     }
00221     appendCloseTag(pFieldName);
00222 }
00223 
00224 <span class="keywordtype">void</span>
00225 CXMLTextEncoderStream::put_s8v (
00226   llrp_s8v_t                    Value,
00227   <span class="keyword">const</span> CFieldDescriptor *      pFieldDescriptor)
00228 {
00229     <span class="keyword">const</span> <span class="keywordtype">char</span> *                pFieldName = pFieldDescriptor-&gt;m_pName;
00230 
00231     appendOpenTag(pFieldName);
00232     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; Value.m_nValue; i++)
00233     {
00234         <span class="keywordflow">switch</span>(pFieldDescriptor-&gt;m_eFieldFormat)
00235         {
00236         <span class="keywordflow">case</span> CFieldDescriptor::FMT_NORMAL:
00237         <span class="keywordflow">case</span> CFieldDescriptor::FMT_DEC:
00238         <span class="keywordflow">default</span>:
00239             <span class="keywordflow">if</span>(0 &lt; i)
00240             {
00241                 appendFormat(<span class="stringliteral">" "</span>);
00242             }
00243             appendFormat(<span class="stringliteral">"%d"</span>, Value.m_pValue[i]);
00244             <span class="keywordflow">break</span>;
00245 
00246         <span class="keywordflow">case</span> CFieldDescriptor::FMT_HEX:
00247             appendFormat(<span class="stringliteral">"%02X"</span>, 0xFF &amp; Value.m_pValue[i]);
00248             <span class="keywordflow">break</span>;
00249         }
00250     }
00251     appendCloseTag(pFieldName);
00252 }
00253 
00254 <span class="comment">/*</span>
00255 <span class="comment"> * 16-bit types</span>
00256 <span class="comment"> */</span>
00257 
00258 <span class="keywordtype">void</span>
00259 CXMLTextEncoderStream::put_u16 (
00260   llrp_u16_t                    Value,
00261   <span class="keyword">const</span> CFieldDescriptor *      pFieldDescriptor)
00262 {
00263     <span class="keyword">const</span> <span class="keywordtype">char</span> *                pFieldName = pFieldDescriptor-&gt;m_pName;
00264 
00265     appendOpenTag(pFieldName);
00266     <span class="keywordflow">switch</span>(pFieldDescriptor-&gt;m_eFieldFormat)
00267     {
00268     <span class="keywordflow">case</span> CFieldDescriptor::FMT_NORMAL:
00269     <span class="keywordflow">case</span> CFieldDescriptor::FMT_DEC:
00270     <span class="keywordflow">default</span>:
00271         appendFormat(<span class="stringliteral">"%u"</span>, Value);
00272         <span class="keywordflow">break</span>;
00273 
00274     <span class="keywordflow">case</span> CFieldDescriptor::FMT_HEX:
00275         appendFormat(<span class="stringliteral">"%04X"</span>, Value);
00276         <span class="keywordflow">break</span>;
00277     }
00278     appendCloseTag(pFieldName);
00279 }
00280 
00281 <span class="keywordtype">void</span>
00282 CXMLTextEncoderStream::put_s16 (
00283   llrp_s16_t                    Value,
00284   <span class="keyword">const</span> CFieldDescriptor *      pFieldDescriptor)
00285 {
00286     <span class="keyword">const</span> <span class="keywordtype">char</span> *                pFieldName = pFieldDescriptor-&gt;m_pName;
00287 
00288     appendOpenTag(pFieldName);
00289     <span class="keywordflow">switch</span>(pFieldDescriptor-&gt;m_eFieldFormat)
00290     {
00291     <span class="keywordflow">case</span> CFieldDescriptor::FMT_NORMAL:
00292     <span class="keywordflow">case</span> CFieldDescriptor::FMT_DEC:
00293     <span class="keywordflow">default</span>:
00294         appendFormat(<span class="stringliteral">"%d"</span>, Value);
00295         <span class="keywordflow">break</span>;
00296 
00297     <span class="keywordflow">case</span> CFieldDescriptor::FMT_HEX:
00298         appendFormat(<span class="stringliteral">"%04X"</span>, 0xFFFF &amp; Value);
00299         <span class="keywordflow">break</span>;
00300     }
00301     appendCloseTag(pFieldName);
00302 }
00303 
00304 <span class="keywordtype">void</span>
00305 CXMLTextEncoderStream::put_u16v (
00306   llrp_u16v_t                   Value,
00307   <span class="keyword">const</span> CFieldDescriptor *      pFieldDescriptor)
00308 {
00309     <span class="keyword">const</span> <span class="keywordtype">char</span> *                pFieldName = pFieldDescriptor-&gt;m_pName;
00310 
00311     appendOpenTag(pFieldName);
00312     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; Value.m_nValue; i++)
00313     {
00314         <span class="keywordflow">if</span>(0 &lt; i)
00315         {
00316             appendFormat(<span class="stringliteral">" "</span>);
00317         }
00318         <span class="keywordflow">switch</span>(pFieldDescriptor-&gt;m_eFieldFormat)
00319         {
00320         <span class="keywordflow">case</span> CFieldDescriptor::FMT_NORMAL:
00321         <span class="keywordflow">case</span> CFieldDescriptor::FMT_DEC:
00322         <span class="keywordflow">default</span>:
00323             appendFormat(<span class="stringliteral">"%u"</span>, Value.m_pValue[i]);
00324             <span class="keywordflow">break</span>;
00325 
00326         <span class="keywordflow">case</span> CFieldDescriptor::FMT_HEX:
00327             appendFormat(<span class="stringliteral">"%04X"</span>, 0xFFFF &amp; Value.m_pValue[i]);
00328             <span class="keywordflow">break</span>;
00329         }
00330     }
00331     appendCloseTag(pFieldName);
00332 }
00333 
00334 <span class="keywordtype">void</span>
00335 CXMLTextEncoderStream::put_s16v (
00336   llrp_s16v_t                   Value,
00337   <span class="keyword">const</span> CFieldDescriptor *      pFieldDescriptor)
00338 {
00339     <span class="keyword">const</span> <span class="keywordtype">char</span> *                pFieldName = pFieldDescriptor-&gt;m_pName;
00340 
00341     appendOpenTag(pFieldName);
00342     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; Value.m_nValue; i++)
00343     {
00344         <span class="keywordflow">if</span>(0 &lt; i)
00345         {
00346             appendFormat(<span class="stringliteral">" "</span>);
00347         }
00348         <span class="keywordflow">switch</span>(pFieldDescriptor-&gt;m_eFieldFormat)
00349         {
00350         <span class="keywordflow">case</span> CFieldDescriptor::FMT_NORMAL:
00351         <span class="keywordflow">case</span> CFieldDescriptor::FMT_DEC:
00352         <span class="keywordflow">default</span>:
00353             appendFormat(<span class="stringliteral">"%d"</span>, Value.m_pValue[i]);
00354             <span class="keywordflow">break</span>;
00355 
00356         <span class="keywordflow">case</span> CFieldDescriptor::FMT_HEX:
00357             appendFormat(<span class="stringliteral">"%04X"</span>, 0xFFFF &amp; Value.m_pValue[i]);
00358             <span class="keywordflow">break</span>;
00359         }
00360     }
00361     appendCloseTag(pFieldName);
00362 }
00363 
00364 <span class="comment">/*</span>
00365 <span class="comment"> * 32-bit types</span>
00366 <span class="comment"> */</span>
00367 
00368 <span class="keywordtype">void</span>
00369 CXMLTextEncoderStream::put_u32 (
00370   llrp_u32_t                    Value,
00371   <span class="keyword">const</span> CFieldDescriptor *      pFieldDescriptor)
00372 {
00373     <span class="keyword">const</span> <span class="keywordtype">char</span> *                pFieldName = pFieldDescriptor-&gt;m_pName;
00374 
00375     appendOpenTag(pFieldName);
00376     <span class="keywordflow">switch</span>(pFieldDescriptor-&gt;m_eFieldFormat)
00377     {
00378     <span class="keywordflow">case</span> CFieldDescriptor::FMT_NORMAL:
00379     <span class="keywordflow">case</span> CFieldDescriptor::FMT_DEC:
00380     <span class="keywordflow">default</span>:
00381         appendFormat(<span class="stringliteral">"%u"</span>, Value);
00382         <span class="keywordflow">break</span>;
00383 
00384     <span class="keywordflow">case</span> CFieldDescriptor::FMT_HEX:
00385         appendFormat(<span class="stringliteral">"%08X"</span>, Value);
00386         <span class="keywordflow">break</span>;
00387     }
00388     appendCloseTag(pFieldName);
00389 }
00390 
00391 <span class="keywordtype">void</span>
00392 CXMLTextEncoderStream::put_s32 (
00393   llrp_s32_t                    Value,
00394   <span class="keyword">const</span> CFieldDescriptor *      pFieldDescriptor)
00395 {
00396     <span class="keyword">const</span> <span class="keywordtype">char</span> *                pFieldName = pFieldDescriptor-&gt;m_pName;
00397 
00398     appendOpenTag(pFieldName);
00399     <span class="keywordflow">switch</span>(pFieldDescriptor-&gt;m_eFieldFormat)
00400     {
00401     <span class="keywordflow">case</span> CFieldDescriptor::FMT_NORMAL:
00402     <span class="keywordflow">case</span> CFieldDescriptor::FMT_DEC:
00403     <span class="keywordflow">default</span>:
00404         appendFormat(<span class="stringliteral">"%d"</span>, Value);
00405         <span class="keywordflow">break</span>;
00406 
00407     <span class="keywordflow">case</span> CFieldDescriptor::FMT_HEX:
00408         appendFormat(<span class="stringliteral">"%08X"</span>, Value);
00409         <span class="keywordflow">break</span>;
00410     }
00411     appendCloseTag(pFieldName);
00412 }
00413 
00414 <span class="keywordtype">void</span>
00415 CXMLTextEncoderStream::put_u32v (
00416   llrp_u32v_t                   Value,
00417   <span class="keyword">const</span> CFieldDescriptor *      pFieldDescriptor)
00418 {
00419     <span class="keyword">const</span> <span class="keywordtype">char</span> *                pFieldName = pFieldDescriptor-&gt;m_pName;
00420 
00421     appendOpenTag(pFieldName);
00422     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; Value.m_nValue; i++)
00423     {
00424         <span class="keywordflow">if</span>(0 &lt; i)
00425         {
00426             appendFormat(<span class="stringliteral">" "</span>);
00427         }
00428         <span class="keywordflow">switch</span>(pFieldDescriptor-&gt;m_eFieldFormat)
00429         {
00430         <span class="keywordflow">case</span> CFieldDescriptor::FMT_NORMAL:
00431         <span class="keywordflow">case</span> CFieldDescriptor::FMT_DEC:
00432         <span class="keywordflow">default</span>:
00433             appendFormat(<span class="stringliteral">"%u"</span>, Value.m_pValue[i]);
00434             <span class="keywordflow">break</span>;
00435 
00436         <span class="keywordflow">case</span> CFieldDescriptor::FMT_HEX:
00437             appendFormat(<span class="stringliteral">"%08X"</span>, Value.m_pValue[i]);
00438             <span class="keywordflow">break</span>;
00439         }
00440     }
00441     appendCloseTag(pFieldName);
00442 }
00443 
00444 <span class="keywordtype">void</span>
00445 CXMLTextEncoderStream::put_s32v (
00446   llrp_s32v_t                   Value,
00447   <span class="keyword">const</span> CFieldDescriptor *      pFieldDescriptor)
00448 {
00449     <span class="keyword">const</span> <span class="keywordtype">char</span> *                pFieldName = pFieldDescriptor-&gt;m_pName;
00450 
00451     appendOpenTag(pFieldName);
00452     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; Value.m_nValue; i++)
00453     {
00454         <span class="keywordflow">if</span>(0 &lt; i)
00455         {
00456             appendFormat(<span class="stringliteral">" "</span>);
00457         }
00458         <span class="keywordflow">switch</span>(pFieldDescriptor-&gt;m_eFieldFormat)
00459         {
00460         <span class="keywordflow">case</span> CFieldDescriptor::FMT_NORMAL:
00461         <span class="keywordflow">case</span> CFieldDescriptor::FMT_DEC:
00462         <span class="keywordflow">default</span>:
00463             appendFormat(<span class="stringliteral">"%d"</span>, Value.m_pValue[i]);
00464             <span class="keywordflow">break</span>;
00465 
00466         <span class="keywordflow">case</span> CFieldDescriptor::FMT_HEX:
00467             appendFormat(<span class="stringliteral">"%08X"</span>, Value.m_pValue[i]);
00468             <span class="keywordflow">break</span>;
00469         }
00470     }
00471     appendCloseTag(pFieldName);
00472 }
00473 
00474 <span class="comment">/*</span>
00475 <span class="comment"> * 64-bit types</span>
00476 <span class="comment"> */</span>
00477 
00478 <span class="keywordtype">void</span>
00479 CXMLTextEncoderStream::put_u64 (
00480   llrp_u64_t                    Value,
00481   <span class="keyword">const</span> CFieldDescriptor *      pFieldDescriptor)
00482 {
00483     <span class="keyword">const</span> <span class="keywordtype">char</span> *                pFieldName = pFieldDescriptor-&gt;m_pName;
00484 
00485     appendOpenTag(pFieldName);
00486     <span class="keywordflow">switch</span>(pFieldDescriptor-&gt;m_eFieldFormat)
00487     {
00488     <span class="keywordflow">case</span> CFieldDescriptor::FMT_NORMAL:
00489     <span class="keywordflow">case</span> CFieldDescriptor::FMT_DEC:
00490     <span class="keywordflow">default</span>:
00491 <span class="preprocessor">#ifdef WIN32</span>
00492 <span class="preprocessor"></span>        appendFormat(<span class="stringliteral">"%I64u"</span>, Value);
00493 <span class="preprocessor">#else</span>
00494 <span class="preprocessor"></span>        appendFormat(<span class="stringliteral">"%llu"</span>, Value);
00495 <span class="preprocessor">#endif</span>
00496 <span class="preprocessor"></span>        <span class="keywordflow">break</span>;
00497 
00498     <span class="keywordflow">case</span> CFieldDescriptor::FMT_HEX:
00499 <span class="preprocessor">#ifdef WIN32</span>
00500 <span class="preprocessor"></span>        appendFormat(<span class="stringliteral">"%016I64X"</span>, Value);
00501 <span class="preprocessor">#else</span>
00502 <span class="preprocessor"></span>        appendFormat(<span class="stringliteral">"%016llX"</span>, Value);
00503 <span class="preprocessor">#endif</span>
00504 <span class="preprocessor"></span>        <span class="keywordflow">break</span>;
00505 
00506     <span class="keywordflow">case</span> CFieldDescriptor::FMT_DATETIME:
00507         {
00508             <span class="keywordtype">char</span>                aBuf[64];
00509             time_t              CurSec  = (time_t)(Value / 1000000u);
00510             llrp_u32_t          CurUSec = (llrp_u32_t)(Value % 1000000u);
00511             <span class="keyword">struct </span>tm *         pGMTime;
00512 
00513             pGMTime = gmtime(&amp;CurSec);
00514             strftime(aBuf, <span class="keyword">sizeof</span> aBuf, <span class="stringliteral">"%Y-%m-%dT%H:%M:%S"</span>, pGMTime);
00515             appendFormat(<span class="stringliteral">"%s.%06d"</span>, aBuf, CurUSec);
00516         }
00517         <span class="keywordflow">break</span>;
00518     }
00519     appendCloseTag(pFieldName);
00520 }
00521 
00522 <span class="keywordtype">void</span>
00523 CXMLTextEncoderStream::put_s64 (
00524   llrp_s64_t                    Value,
00525   <span class="keyword">const</span> CFieldDescriptor *      pFieldDescriptor)
00526 {
00527     <span class="keyword">const</span> <span class="keywordtype">char</span> *                pFieldName = pFieldDescriptor-&gt;m_pName;
00528 
00529     appendOpenTag(pFieldName);
00530     <span class="keywordflow">switch</span>(pFieldDescriptor-&gt;m_eFieldFormat)
00531     {
00532     <span class="keywordflow">case</span> CFieldDescriptor::FMT_NORMAL:
00533     <span class="keywordflow">case</span> CFieldDescriptor::FMT_DEC:
00534     <span class="keywordflow">default</span>:
00535 <span class="preprocessor">#ifdef WIN32</span>
00536 <span class="preprocessor"></span>        appendFormat(<span class="stringliteral">"%I64d"</span>, Value);
00537 <span class="preprocessor">#else</span>
00538 <span class="preprocessor"></span>        appendFormat(<span class="stringliteral">"%lld"</span>, Value);
00539 <span class="preprocessor">#endif</span>
00540 <span class="preprocessor"></span>        <span class="keywordflow">break</span>;
00541 
00542     <span class="keywordflow">case</span> CFieldDescriptor::FMT_HEX:
00543 <span class="preprocessor">#ifdef WIN32</span>
00544 <span class="preprocessor"></span>        appendFormat(<span class="stringliteral">"%016I64X"</span>, Value);
00545 <span class="preprocessor">#else</span>
00546 <span class="preprocessor"></span>        appendFormat(<span class="stringliteral">"%016llX"</span>, Value);
00547 <span class="preprocessor">#endif</span>
00548 <span class="preprocessor"></span>        <span class="keywordflow">break</span>;
00549     }
00550     appendCloseTag(pFieldName);
00551 }
00552 
00553 <span class="keywordtype">void</span>
00554 CXMLTextEncoderStream::put_u64v (
00555   llrp_u64v_t                   Value,
00556   <span class="keyword">const</span> CFieldDescriptor *      pFieldDescriptor)
00557 {
00558     <span class="keyword">const</span> <span class="keywordtype">char</span> *                pFieldName = pFieldDescriptor-&gt;m_pName;
00559 
00560     appendOpenTag(pFieldName);
00561     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; Value.m_nValue; i++)
00562     {
00563         <span class="keywordflow">if</span>(0 &lt; i)
00564         {
00565             appendFormat(<span class="stringliteral">" "</span>);
00566         }
00567         <span class="keywordflow">switch</span>(pFieldDescriptor-&gt;m_eFieldFormat)
00568         {
00569         <span class="keywordflow">case</span> CFieldDescriptor::FMT_NORMAL:
00570         <span class="keywordflow">case</span> CFieldDescriptor::FMT_DEC:
00571         <span class="keywordflow">default</span>:
00572 <span class="preprocessor">#ifdef WIN32</span>
00573 <span class="preprocessor"></span>            appendFormat(<span class="stringliteral">"%I64u"</span>, Value.m_pValue[i]);
00574 <span class="preprocessor">#else</span>
00575 <span class="preprocessor"></span>            appendFormat(<span class="stringliteral">"%llu"</span>, Value.m_pValue[i]);
00576 <span class="preprocessor">#endif</span>
00577 <span class="preprocessor"></span>            <span class="keywordflow">break</span>;
00578 
00579         <span class="keywordflow">case</span> CFieldDescriptor::FMT_HEX:
00580 <span class="preprocessor">#ifdef WIN32</span>
00581 <span class="preprocessor"></span>            appendFormat(<span class="stringliteral">"%016I64X"</span>, Value.m_pValue[i]);
00582 <span class="preprocessor">#else</span>
00583 <span class="preprocessor"></span>            appendFormat(<span class="stringliteral">"%016llX"</span>, Value.m_pValue[i]);
00584 <span class="preprocessor">#endif</span>
00585 <span class="preprocessor"></span>            <span class="keywordflow">break</span>;
00586         }
00587     }
00588     appendCloseTag(pFieldName);
00589 }
00590 
00591 <span class="keywordtype">void</span>
00592 CXMLTextEncoderStream::put_s64v (
00593   llrp_s64v_t                   Value,
00594   <span class="keyword">const</span> CFieldDescriptor *      pFieldDescriptor)
00595 {
00596     <span class="keyword">const</span> <span class="keywordtype">char</span> *                pFieldName = pFieldDescriptor-&gt;m_pName;
00597 
00598     appendOpenTag(pFieldName);
00599     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; Value.m_nValue; i++)
00600     {
00601         <span class="keywordflow">if</span>(0 &lt; i)
00602         {
00603             appendFormat(<span class="stringliteral">" "</span>);
00604         }
00605         <span class="keywordflow">switch</span>(pFieldDescriptor-&gt;m_eFieldFormat)
00606         {
00607         <span class="keywordflow">case</span> CFieldDescriptor::FMT_NORMAL:
00608         <span class="keywordflow">case</span> CFieldDescriptor::FMT_DEC:
00609         <span class="keywordflow">default</span>:
00610 <span class="preprocessor">#ifdef WIN32</span>
00611 <span class="preprocessor"></span>            appendFormat(<span class="stringliteral">"%I64d"</span>, Value.m_pValue[i]);
00612 <span class="preprocessor">#else</span>
00613 <span class="preprocessor"></span>            appendFormat(<span class="stringliteral">"%lld"</span>, Value.m_pValue[i]);
00614 <span class="preprocessor">#endif</span>
00615 <span class="preprocessor"></span>            <span class="keywordflow">break</span>;
00616 
00617         <span class="keywordflow">case</span> CFieldDescriptor::FMT_HEX:
00618 <span class="preprocessor">#ifdef WIN32</span>
00619 <span class="preprocessor"></span>            appendFormat(<span class="stringliteral">"%016I64X"</span>, Value.m_pValue[i]);
00620 <span class="preprocessor">#else</span>
00621 <span class="preprocessor"></span>            appendFormat(<span class="stringliteral">"%016llX"</span>, Value.m_pValue[i]);
00622 <span class="preprocessor">#endif</span>
00623 <span class="preprocessor"></span>            <span class="keywordflow">break</span>;
00624         }
00625     }
00626     appendCloseTag(pFieldName);
00627 }
00628 
00629 <span class="comment">/*</span>
00630 <span class="comment"> * Special types</span>
00631 <span class="comment"> */</span>
00632 
00633 <span class="keywordtype">void</span>
00634 CXMLTextEncoderStream::put_u1 (
00635   llrp_u1_t                     Value,
00636   <span class="keyword">const</span> CFieldDescriptor *      pFieldDescriptor)
00637 {
00638     <span class="keyword">const</span> <span class="keywordtype">char</span> *                pFieldName = pFieldDescriptor-&gt;m_pName;
00639 
00640     appendOpenTag(pFieldName);
00641     <span class="keywordflow">switch</span>(pFieldDescriptor-&gt;m_eFieldFormat)
00642     {
00643     <span class="keywordflow">case</span> CFieldDescriptor::FMT_NORMAL:
00644     <span class="keywordflow">default</span>:
00645         appendFormat(<span class="stringliteral">"%s"</span>, (Value &amp; 1) ? <span class="stringliteral">"true"</span> : <span class="stringliteral">"false"</span>);
00646         <span class="keywordflow">break</span>;
00647 
00648     <span class="keywordflow">case</span> CFieldDescriptor::FMT_DEC:
00649     <span class="keywordflow">case</span> CFieldDescriptor::FMT_HEX:
00650         appendFormat(<span class="stringliteral">"%d"</span>, Value &amp; 1);
00651         <span class="keywordflow">break</span>;
00652     }
00653     appendCloseTag(pFieldName);
00654 }
00655 
00656 <span class="keywordtype">void</span>
00657 CXMLTextEncoderStream::put_u1v (
00658   llrp_u1v_t                    Value,
00659   <span class="keyword">const</span> CFieldDescriptor *      pFieldDescriptor)
00660 {
00661     <span class="keyword">const</span> <span class="keywordtype">char</span> *                pFieldName = pFieldDescriptor-&gt;m_pName;
00662     <span class="keywordtype">int</span>                         nByte;
00663 
00664     nByte = (Value.m_nBit + 7u) / 8u;
00665 
00666     indent();
00667     appendFormat(<span class="stringliteral">"&lt;"</span>);
00668     appendPrefixedTagName(pFieldName);
00669     appendFormat(<span class="stringliteral">" Count='%d'&gt;"</span>, Value.m_nBit);
00670 
00671     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; nByte; i++)
00672     {
00673         appendFormat(<span class="stringliteral">"%02X"</span>, Value.m_pValue[i]);
00674     }
00675 
00676     appendCloseTag(pFieldName);
00677 }
00678 
00679 <span class="keywordtype">void</span>
00680 CXMLTextEncoderStream::put_u2 (
00681   llrp_u2_t                     Value,
00682   <span class="keyword">const</span> CFieldDescriptor *      pFieldDescriptor)
00683 {
00684     <span class="keyword">const</span> <span class="keywordtype">char</span> *                pFieldName = pFieldDescriptor-&gt;m_pName;
00685 
00686     appendOpenTag(pFieldName);
00687     appendFormat(<span class="stringliteral">"%d"</span>, Value &amp; 3);
00688     appendCloseTag(pFieldName);
00689 }
00690 
00691 <span class="keywordtype">void</span>
00692 CXMLTextEncoderStream::put_u96 (
00693   llrp_u96_t                    Value,
00694   <span class="keyword">const</span> CFieldDescriptor *      pFieldDescriptor)
00695 {
00696     <span class="keyword">const</span> <span class="keywordtype">char</span> *                pFieldName = pFieldDescriptor-&gt;m_pName;
00697 
00698     appendOpenTag(pFieldName);
00699     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; 12; i++)
00700     {
00701         appendFormat(<span class="stringliteral">"%02X"</span>, Value.m_aValue[i]);
00702     }
00703     appendCloseTag(pFieldName);
00704 }
00705 
00706 <span class="keywordtype">void</span>
00707 CXMLTextEncoderStream::put_utf8v (
00708   llrp_utf8v_t                  Value,
00709   <span class="keyword">const</span> CFieldDescriptor *      pFieldDescriptor)
00710 {
00711     <span class="keyword">const</span> <span class="keywordtype">char</span> *                pFieldName = pFieldDescriptor-&gt;m_pName;
00712 
00713     appendOpenTag(pFieldName);
00714     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; Value.m_nValue; i++)
00715     {
00716         <span class="keywordtype">int</span>         c = Value.m_pValue[i];
00717 
00718         <span class="keywordflow">if</span>(0 == c &amp;&amp; i+1 == Value.m_nValue)
00719         {
00720             <span class="keywordflow">continue</span>;
00721         }
00722         <span class="keywordflow">if</span>(<span class="charliteral">' '</span> &lt;= c &amp;&amp; c &lt; 0x7F)
00723         {
00724             appendFormat(<span class="stringliteral">"%c"</span>, c);
00725         }
00726         <span class="keywordflow">else</span>
00727         {
00728             appendFormat(<span class="stringliteral">"\\%03o"</span>, c);
00729         }
00730     }
00731     appendCloseTag(pFieldName);
00732 }
00733 
00734 <span class="keywordtype">void</span>
00735 CXMLTextEncoderStream::put_bytesToEnd (
00736   llrp_bytesToEnd_t             Value,
00737   <span class="keyword">const</span> CFieldDescriptor *      pFieldDescriptor)
00738 {
00739     <span class="keyword">const</span> <span class="keywordtype">char</span> *                pFieldName = pFieldDescriptor-&gt;m_pName;
00740 
00741     appendOpenTag(pFieldName);
00742     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; Value.m_nValue; i++)
00743     {
00744         appendFormat(<span class="stringliteral">"%02X"</span>, Value.m_pValue[i]);
00745     }
00746     appendCloseTag(pFieldName);
00747 }
00748 
00749 <span class="comment">/*</span>
00750 <span class="comment"> * Enumerated types of various sizes</span>
00751 <span class="comment"> */</span>
00752 
00753 <span class="keywordtype">void</span>
00754 CXMLTextEncoderStream::put_e1 (
00755   <span class="keywordtype">int</span>                           eValue,
00756   <span class="keyword">const</span> CFieldDescriptor *      pFieldDescriptor)
00757 {
00758     put_enum(eValue, pFieldDescriptor);
00759 }
00760 
00761 <span class="keywordtype">void</span>
00762 CXMLTextEncoderStream::put_e2 (
00763   <span class="keywordtype">int</span>                           eValue,
00764   <span class="keyword">const</span> CFieldDescriptor *      pFieldDescriptor)
00765 {
00766     put_enum(eValue, pFieldDescriptor);
00767 }
00768 
00769 <span class="keywordtype">void</span>
00770 CXMLTextEncoderStream::put_e8 (
00771   <span class="keywordtype">int</span>                           eValue,
00772   <span class="keyword">const</span> CFieldDescriptor *      pFieldDescriptor)
00773 {
00774     put_enum(eValue, pFieldDescriptor);
00775 }
00776 
00777 <span class="keywordtype">void</span>
00778 CXMLTextEncoderStream::put_e16 (
00779   <span class="keywordtype">int</span>                           eValue,
00780   <span class="keyword">const</span> CFieldDescriptor *      pFieldDescriptor)
00781 {
00782     put_enum(eValue, pFieldDescriptor);
00783 }
00784 
00785 <span class="keywordtype">void</span>
00786 CXMLTextEncoderStream::put_e32 (
00787   <span class="keywordtype">int</span>                           eValue,
00788   <span class="keyword">const</span> CFieldDescriptor *      pFieldDescriptor)
00789 {
00790     put_enum(eValue, pFieldDescriptor);
00791 }
00792 
00793 <span class="keywordtype">void</span>
00794 CXMLTextEncoderStream::put_e8v (
00795   llrp_u8v_t                    Value,
00796   <span class="keyword">const</span> CFieldDescriptor *      pFieldDescriptor)
00797 {
00798     <span class="keyword">const</span> <span class="keywordtype">char</span> *                pFieldName = pFieldDescriptor-&gt;m_pName;
00799 
00800     appendOpenTag(pFieldName);
00801     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; Value.m_nValue; i++)
00802     {
00803         <span class="keywordtype">int</span>                     eValue = Value.m_pValue[i];
00804         <span class="keyword">const</span> SEnumTableEntry * pEntry;
00805 
00806         <span class="keywordflow">for</span>(pEntry = pFieldDescriptor-&gt;m_pEnumTable;
00807             NULL != pEntry-&gt;pName;
00808             pEntry++)
00809         {
00810             <span class="keywordflow">if</span>(pEntry-&gt;Value == eValue)
00811             {
00812                 <span class="keywordflow">break</span>;
00813             }
00814         }
00815 
00816         <span class="keywordflow">if</span>(0 &lt; i)
00817         {
00818             appendFormat(<span class="stringliteral">" "</span>);
00819         }
00820 
00821         <span class="keywordflow">if</span>(NULL != pEntry-&gt;pName)
00822         {
00823             appendFormat(<span class="stringliteral">"%s"</span>, pEntry-&gt;pName);
00824         }
00825         <span class="keywordflow">else</span>
00826         {
00827             appendFormat(<span class="stringliteral">"%d"</span>, eValue);
00828         }
00829     }
00830     appendCloseTag(pFieldName);
00831 }
00832 
00833 <span class="comment">/*</span>
00834 <span class="comment"> * Reserved types are some number of bits</span>
00835 <span class="comment"> */</span>
00836 
00837 <span class="keywordtype">void</span>
00838 CXMLTextEncoderStream::put_reserved (
00839   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>                  nBits)
00840 {
00841     indent();
00842     appendFormat(<span class="stringliteral">"&lt;!-- reserved %d bits --&gt;\n"</span>, nBits);
00843 }
00844 
00845 
00846 CXMLTextEncoderStream::CXMLTextEncoderStream (
00847   CXMLTextEncoder *               pEncoder)
00848 {
00849     m_pEncoder                  = pEncoder;
00850     m_pEnclosingEncoderStream   = NULL;
00851     m_pRefType                  = NULL;
00852     m_nDepth                    = 1;
00853 }
00854 
00855 CXMLTextEncoderStream::CXMLTextEncoderStream (
00856   CXMLTextEncoderStream *         pEnclosingEncoderStream)
00857 {
00858     m_pEncoder                  = pEnclosingEncoderStream-&gt;m_pEncoder;
00859     m_pEnclosingEncoderStream   = pEnclosingEncoderStream;
00860     m_pRefType                  = NULL;
00861     m_nDepth                    = pEnclosingEncoderStream-&gt;m_nDepth+1;
00862 }
00863 
00864 <span class="keywordtype">void</span>
00865 CXMLTextEncoderStream::putElement (
00866   <span class="keyword">const</span> CElement *              pElement)
00867 {
00868     m_pRefType = pElement-&gt;m_pType;
00869 
00870     indent(-1);
00871     appendFormat(<span class="stringliteral">"&lt;"</span>);
00872     appendPrefixedTagName(m_pRefType-&gt;m_pName);
00873     <span class="keywordflow">if</span>(m_pRefType-&gt;m_bIsMessage)
00874     {
00875         appendFormat(<span class="stringliteral">" MessageID='%u'"</span>,
00876             ((<span class="keyword">const</span> CMessage *)pElement)-&gt;getMessageID());
00877     }
00878 
00879     <span class="keywordflow">if</span>(NULL == m_pEnclosingEncoderStream)
00880     {
00881         tNamespaceList          NamespaceList;
00882         <span class="keyword">const</span> CNamespaceDescriptor *pNamespaceDescriptor;
00883         <span class="keywordtype">int</span>                     iNSD;
00884 
00885         memset(&amp;NamespaceList, 0, <span class="keyword">sizeof</span> NamespaceList);
00886 
00887         pElement-&gt;walk(discoverNamespaces, (<span class="keywordtype">void</span>*)&amp;NamespaceList,
00888             0, 12);
00889 
00890         <span class="comment">/* Emit the namespace cookie for each */</span>
00891         <span class="keywordflow">for</span>(iNSD = 0; iNSD &lt; NamespaceList.nNamespaceDescriptor; iNSD++)
00892         {
00893             pNamespaceDescriptor = NamespaceList.apNamespaceDescriptor[iNSD];
00894 
00895             appendFormat(<span class="stringliteral">"\n"</span>);
00896             indent(0);
00897             appendFormat(<span class="stringliteral">"xmlns:%s='%s'"</span>,
00898                 pNamespaceDescriptor-&gt;m_pPrefix,
00899                 pNamespaceDescriptor-&gt;m_pURI);
00900             <span class="comment">/*</span>
00901 <span class="comment">             * If this is the default namespace then emit the assigment.</span>
00902 <span class="comment">             */</span>
00903             <span class="keywordflow">if</span>(0 == strcmp(pNamespaceDescriptor-&gt;m_pPrefix, <span class="stringliteral">"llrp"</span>))
00904             {
00905                 appendFormat(<span class="stringliteral">"\n"</span>);
00906                 indent(0);
00907                 appendFormat(<span class="stringliteral">"xmlns='%s'"</span>, pNamespaceDescriptor-&gt;m_pURI);
00908             }
00909         }
00910     }
00911     appendFormat(<span class="stringliteral">"&gt;\n"</span>);
00912 
00913     pElement-&gt;encode(<span class="keyword">this</span>);
00914 
00915     indent(-1);
00916     appendCloseTag(m_pRefType-&gt;m_pName);
00917 }
00918 
00919 <span class="keyword">static</span> <span class="keywordtype">int</span>
00920 discoverNamespaces (
00921   <span class="keyword">const</span> CElement *              pElement,
00922   <span class="keywordtype">void</span> *                        pArg)
00923 {
00924     tNamespaceList *            pNSL = (tNamespaceList *) pArg;
00925     <span class="keyword">const</span> CNamespaceDescriptor *pNamespaceDescriptor;
00926     <span class="keywordtype">int</span>                         iNSD;
00927 
00928     pNamespaceDescriptor = pElement-&gt;m_pType-&gt;m_pNamespaceDescriptor;
00929 
00930     <span class="keywordflow">for</span>(iNSD = 0; iNSD &lt; pNSL-&gt;nNamespaceDescriptor; iNSD++)
00931     {
00932         <span class="keywordflow">if</span>(pNSL-&gt;apNamespaceDescriptor[iNSD] == pNamespaceDescriptor)
00933         {
00934             <span class="comment">/* Already have it */</span>
00935             <span class="keywordflow">return</span> 0;
00936         }
00937     }
00938 
00939     <span class="comment">/* if we get here this namespace isn't already in the list */</span>
00940     <span class="keywordflow">if</span>(MAX_NS &gt; pNSL-&gt;nNamespaceDescriptor)
00941     {
00942         iNSD = pNSL-&gt;nNamespaceDescriptor++;
00943         pNSL-&gt;apNamespaceDescriptor[iNSD] = pNamespaceDescriptor;
00944     }
00945 
00946     <span class="keywordflow">return</span> 0;
00947 }
00948 
00949 
00950 <span class="keywordtype">void</span>
00951 CXMLTextEncoderStream::put_enum (
00952   <span class="keywordtype">int</span>                           eValue,
00953   <span class="keyword">const</span> CFieldDescriptor *      pFieldDescriptor)
00954 {
00955     <span class="keyword">const</span> <span class="keywordtype">char</span> *                pFieldName = pFieldDescriptor-&gt;m_pName;
00956     <span class="keyword">const</span> SEnumTableEntry *     pEntry;
00957 
00958     appendOpenTag(pFieldName);
00959 
00960     <span class="keywordflow">for</span>(pEntry = pFieldDescriptor-&gt;m_pEnumTable;
00961         NULL != pEntry-&gt;pName;
00962         pEntry++)
00963     {
00964         <span class="keywordflow">if</span>(pEntry-&gt;Value == eValue)
00965         {
00966             <span class="keywordflow">break</span>;
00967         }
00968     }
00969 
00970     <span class="keywordflow">if</span>(NULL != pEntry-&gt;pName)
00971     {
00972         appendFormat(<span class="stringliteral">"%s"</span>, pEntry-&gt;pName);
00973     }
00974     <span class="keywordflow">else</span>
00975     {
00976         appendFormat(<span class="stringliteral">"%d"</span>, eValue);
00977     }
00978 
00979     appendCloseTag(pFieldName);
00980 }
00981 
00982 <span class="keywordtype">void</span>
00983 CXMLTextEncoderStream::indent (
00984   <span class="keywordtype">int</span>                           adjust)
00985 {
00986     <span class="keywordtype">int</span>                         n = m_nDepth + adjust;
00987 
00988     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; n; i++)
00989     {
00990         appendFormat(<span class="stringliteral">"  "</span>);
00991     }
00992 }
00993 
00994 <span class="keywordtype">void</span>
00995 CXMLTextEncoderStream::appendOpenTag (
00996   <span class="keyword">const</span> <span class="keywordtype">char</span> *                  pName)
00997 {
00998     indent(0);
00999     appendFormat(<span class="stringliteral">"&lt;"</span>);
01000     appendPrefixedTagName(pName);
01001     appendFormat(<span class="stringliteral">"&gt;"</span>);
01002 }
01003 
01004 <span class="keywordtype">void</span>
01005 CXMLTextEncoderStream::appendCloseTag (
01006   <span class="keyword">const</span> <span class="keywordtype">char</span> *                  pName)
01007 {
01008     appendFormat(<span class="stringliteral">"&lt;/"</span>);
01009     appendPrefixedTagName(pName);
01010     appendFormat(<span class="stringliteral">"&gt;\n"</span>);
01011 }
01012 
01013 <span class="keywordtype">void</span>
01014 CXMLTextEncoderStream::appendPrefixedTagName (
01015   <span class="keyword">const</span> <span class="keywordtype">char</span> *                  pName)
01016 {
01017     <span class="keyword">const</span> CTypeDescriptor *     pRefType = m_pRefType;
01018     <span class="keyword">const</span> <span class="keywordtype">char</span> *                pPrefix =
01019                                   pRefType-&gt;m_pNamespaceDescriptor-&gt;m_pPrefix;
01020 
01021     <span class="keywordflow">if</span>(0 != strcmp(<span class="stringliteral">"llrp"</span>, pPrefix))
01022     {
01023         appendFormat(<span class="stringliteral">"%s:%s"</span>, pPrefix, pName);
01024     }
01025     <span class="keywordflow">else</span>
01026     {
01027         appendFormat(<span class="stringliteral">"%s"</span>, pName);
01028     }
01029 }
01030 
01031 <span class="keywordtype">void</span>
01032 CXMLTextEncoderStream::appendFormat (
01033   <span class="keywordtype">char</span> *                        pFmtStr,
01034                                 ...)
01035 {
01036     <span class="keywordtype">char</span>                        aHoldBuf[256u];
01037     <span class="keywordtype">int</span>                         nHoldBuf;
01038     va_list                     ap;
01039 
01040     <span class="comment">/* If overflow already detected, bail */</span>
01041     <span class="keywordflow">if</span>(m_pEncoder-&gt;m_bOverflow)
01042     {
01043         <span class="keywordflow">return</span>;
01044     }
01045 
01046     va_start(ap, pFmtStr);
01047 <span class="preprocessor">#ifdef WIN32</span>
01048 <span class="preprocessor"></span>    _vsnprintf(aHoldBuf, <span class="keyword">sizeof</span> aHoldBuf, pFmtStr, ap);
01049 <span class="preprocessor">#else</span>
01050 <span class="preprocessor"></span>    vsnprintf(aHoldBuf, <span class="keyword">sizeof</span> aHoldBuf, pFmtStr, ap);
01051 <span class="preprocessor">#endif</span>
01052 <span class="preprocessor"></span>    va_end(ap);
01053 
01054     nHoldBuf = (int)strlen(aHoldBuf);
01055 
01056     <span class="keywordflow">if</span>(m_pEncoder-&gt;m_iNext + nHoldBuf &gt;= m_pEncoder-&gt;m_nBuffer)
01057     {
01058         m_pEncoder-&gt;m_bOverflow = 1;
01059         <span class="keywordflow">return</span>;
01060     }
01061 
01062     strcpy(&amp;m_pEncoder-&gt;m_pBuffer[m_pEncoder-&gt;m_iNext], aHoldBuf);
01063 
01064     m_pEncoder-&gt;m_iNext += nHoldBuf;
01065 }
01066 
01067 
01084 <a class="code" href="namespaceLLRP.html#a333">EResultCode</a>
<a name="l01085"></a><a class="code" href="classLLRP_1_1CElement.html#a6">01085</a> CElement::toXMLString (
01086   <span class="keywordtype">char</span> *                        pBuffer,
01087   <span class="keywordtype">int</span>                           nBuffer)
01088 {
01089     <span class="keywordflow">return</span> LLRP::toXMLString(<span class="keyword">this</span>, pBuffer, nBuffer);
01090 }
01091 
01092 <a class="code" href="namespaceLLRP.html#a333">EResultCode</a>
01093 toXMLString (
01094   <span class="keyword">const</span> <a class="code" href="classLLRP_1_1CElement.html">CElement</a> *              pElement,
01095   <span class="keywordtype">char</span> *                        pBuffer,
01096   <span class="keywordtype">int</span>                           nBuffer)
01097 {
01098     CXMLTextEncoder *           pXMLEncoder;
01099     <span class="keyword">const</span> <a class="code" href="classLLRP_1_1CErrorDetails.html">CErrorDetails</a> *       pError;
01100 
01101     <span class="comment">/*</span>
01102 <span class="comment">     * Make sure the element is not NULL.</span>
01103 <span class="comment">     */</span>
01104     <span class="keywordflow">if</span>(NULL == pElement)
01105     {
01106         strcpy(pBuffer, <span class="stringliteral">"ERROR: NULL pMessage to printXMLMessage\n"</span>);
01107         <span class="keywordflow">return</span> RC_MiscError;
01108     }
01109 
01110     <span class="comment">/*</span>
01111 <span class="comment">     * Construct an XML encoder</span>
01112 <span class="comment">     */</span>
01113     pXMLEncoder = <span class="keyword">new</span> CXMLTextEncoder(pBuffer, nBuffer);
01114     <span class="keywordflow">if</span>(NULL == pXMLEncoder)
01115     {
01116         printf(<span class="stringliteral">"ERROR: XMLTextEncoder_construct failed\n"</span>);
01117         <span class="keywordflow">return</span> RC_MiscError;
01118     }
01119 
01120     <span class="comment">/*</span>
01121 <span class="comment">     * Now let the encoding mechanism do its thing.</span>
01122 <span class="comment">     */</span>
01123     pXMLEncoder-&gt;encodeElement(pElement);
01124 
01125     <span class="comment">/*</span>
01126 <span class="comment">     * Check the outcome in the error details.</span>
01127 <span class="comment">     * If there is a problem, return the error rather</span>
01128 <span class="comment">     * than the assumed to be useless string.</span>
01129 <span class="comment">     */</span>
01130     pError = &amp;pXMLEncoder-&gt;m_ErrorDetails;
01131 
01132     <span class="keywordflow">if</span>(<a class="code" href="namespaceLLRP.html#a333a251">RC_OK</a> != pError-&gt;<a class="code" href="classLLRP_1_1CErrorDetails.html#o0">m_eResultCode</a>)
01133     {
01134         sprintf(pBuffer, <span class="stringliteral">"ERROR: %s XML text failed, %s\n"</span>,
01135             pElement-&gt;<a class="code" href="classLLRP_1_1CElement.html#o0">m_pType</a>-&gt;<a class="code" href="classLLRP_1_1CTypeDescriptor.html#o1">m_pName</a>,
01136             pError-&gt;<a class="code" href="classLLRP_1_1CErrorDetails.html#o1">m_pWhatStr</a> ? pError-&gt;<a class="code" href="classLLRP_1_1CErrorDetails.html#o1">m_pWhatStr</a> : <span class="stringliteral">"no reason given"</span>);
01137 
01138         <span class="keyword">delete</span> pXMLEncoder;
01139 
01140         <span class="keywordflow">return</span> pError-&gt;<a class="code" href="classLLRP_1_1CErrorDetails.html#o0">m_eResultCode</a>;
01141     }
01142 
01143     <span class="comment">/*</span>
01144 <span class="comment">     * Check if the XML fit in the buffer.</span>
01145 <span class="comment">     */</span>
01146     <span class="keywordflow">if</span>(pXMLEncoder-&gt;m_bOverflow)
01147     {
01148         strcpy(pBuffer, <span class="stringliteral">"ERROR: Buffer overflow\n"</span>);
01149         <span class="keyword">delete</span> pXMLEncoder;
01150         <span class="keywordflow">return</span> RC_MiscError;
01151     }
01152 
01153     <span class="comment">/*</span>
01154 <span class="comment">     * Done with the XML encoder.</span>
01155 <span class="comment">     */</span>
01156     <span class="keyword">delete</span> pXMLEncoder;
01157 
01158     <span class="keywordflow">return</span> RC_OK;
01159 }
01160 
01161 
01162 }; <span class="comment">/* namespace LLRP */</span>
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Wed Feb 24 09:16:21 2010 for LTKCPP-- LLRP Toolkit C Plus Plus Library by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.3.9.1 </small></address>
</body>
</html>
