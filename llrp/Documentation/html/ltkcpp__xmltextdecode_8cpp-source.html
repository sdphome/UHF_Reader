<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>LTKCPP-- LLRP Toolkit C Plus Plus Library: ltkcpp_xmltextdecode.cpp Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.9.1 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="namespacemembers.html">Namespace&nbsp;Members</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a></div>
<div class="nav">
<a class="el" href="dir_000002.html">Library</a></div>
<h1>ltkcpp_xmltextdecode.cpp</h1><a href="ltkcpp__xmltextdecode_8cpp.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment">00001 
00002 <span class="comment">/*</span>
00003 <span class="comment"> ***************************************************************************</span>
00004 <span class="comment"> *  Copyright 2007,2010 Impinj, Inc.</span>
00005 <span class="comment"> *</span>
00006 <span class="comment"> *  Licensed under the Apache License, Version 2.0 (the "License");</span>
00007 <span class="comment"> *  you may not use this file except in compliance with the License.</span>
00008 <span class="comment"> *  You may obtain a copy of the License at</span>
00009 <span class="comment"> *</span>
00010 <span class="comment"> *      http://www.apache.org/licenses/LICENSE-2.0</span>
00011 <span class="comment"> *</span>
00012 <span class="comment"> *  Unless required by applicable law or agreed to in writing, software</span>
00013 <span class="comment"> *  distributed under the License is distributed on an "AS IS" BASIS,</span>
00014 <span class="comment"> *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
00015 <span class="comment"> *  See the License for the specific language governing permissions and</span>
00016 <span class="comment"> *  limitations under the License.</span>
00017 <span class="comment"> *</span>
00018 <span class="comment"> ***************************************************************************</span>
00019 <span class="comment"> */</span>
00032 <span class="preprocessor">#include &lt;assert.h&gt;</span>
00033 <span class="preprocessor">#include &lt;ctype.h&gt;</span>
00034 <span class="preprocessor">#include &lt;string.h&gt;</span>
00035 <span class="preprocessor">#include &lt;time.h&gt;</span>
00036 <span class="preprocessor">#include &lt;stdio.h&gt;</span>
00037 
00038 <span class="preprocessor">#include "<a class="code" href="ltkcpp__platform_8h.html">ltkcpp_platform.h</a>"</span>
00039 <span class="preprocessor">#include "<a class="code" href="ltkcpp__base_8h.html">ltkcpp_base.h</a>"</span>
00040 
00041 <span class="preprocessor">#include "libxml/parser.h"</span>
00042 <span class="preprocessor">#include "libxml/tree.h"</span>
00043 
00044 <span class="preprocessor">#include "<a class="code" href="ltkcpp__xmltext_8h.html">ltkcpp_xmltext.h</a>"</span>
00045 
00046 
00047 <span class="keyword">namespace </span>LLRP
00048 {
00049 
00050 CXMLTextDecoder::CXMLTextDecoder (
00051   <span class="keyword">const</span> CTypeRegistry *         pTypeRegistry,
00052   <span class="keywordtype">char</span> *                        pBuffer,
00053   <span class="keywordtype">int</span>                           nBuffer) : CDecoder(pTypeRegistry)
00054 
00055 {
00056     <span class="comment">/* set the line numbers for error reporting */</span>
00057     xmlLineNumbersDefault(1);
00058 
00059     <span class="comment">/* Read in the XML from the buffer into the XML Reader */</span>
00060     m_pDoc = xmlReadMemory((<span class="keywordtype">char</span>*) pBuffer, nBuffer, <span class="stringliteral">"noName.xml"</span>, NULL, 
00061                                   XML_PARSE_COMPACT | XML_PARSE_NONET);
00062 
00063     <span class="keywordflow">if</span>(NULL != m_pDoc)
00064     {
00065         <span class="comment">/* Initialize the other decoder state variables */</span>
00066         m_pxmlNodeTree = xmlDocGetRootElement(m_pDoc);
00067     }
00068     <span class="keywordflow">else</span>
00069     {
00070         fprintf(stderr, <span class="stringliteral">"could not parse XML memory buffer"</span>);
00071     }
00072 }
00073 
00074 CXMLTextDecoder::CXMLTextDecoder (
00075   <span class="keyword">const</span> CTypeRegistry *         pTypeRegistry,
00076   <span class="keyword">struct</span> _xmlNode *             pNodeTree) : CDecoder(pTypeRegistry)
00077 {
00078     <span class="comment">/* set the line numbers for error reporting */</span>
00079     xmlLineNumbersDefault(1);
00080 
00081     <span class="comment">/* Read in the XML from the buffer into the XML Reader */</span>
00082     m_pDoc = NULL; 
00083     <span class="comment">/* Initialize the other decoder state variables */</span>
00084     m_pxmlNodeTree = pNodeTree;
00085 }
00086 
00087 CXMLTextDecoder::CXMLTextDecoder (
00088   <span class="keyword">const</span> CTypeRegistry *         pTypeRegistry,
00089   <span class="keywordtype">char</span> *                        fname) : CDecoder(pTypeRegistry)
00090 {
00091     <span class="comment">/* set the line numbers for error reporting */</span>
00092     xmlLineNumbersDefault(1);
00093 
00094     <span class="comment">/* Read in the XML from the file into the XML Reader */</span>
00095     m_pDoc = xmlReadFile(fname, 
00096                          NULL, 
00097                          XML_PARSE_COMPACT | XML_PARSE_NONET);
00098 
00099     <span class="keywordflow">if</span>(NULL != m_pDoc)
00100     {
00101         <span class="comment">/* Initialize the other decoder state variables */</span>
00102         m_pxmlNodeTree = xmlDocGetRootElement(m_pDoc);
00103     }
00104     <span class="keywordflow">else</span>
00105     {
00106         fprintf(stderr, <span class="stringliteral">"could not parse XML file"</span>);
00107     }
00108 }
00109 
00110 CXMLTextDecoder::~CXMLTextDecoder (<span class="keywordtype">void</span>)
00111 {
00112     <span class="keywordflow">if</span>(NULL != m_pDoc)
00113     {
00114         xmlFreeDoc(m_pDoc);    
00115         m_pDoc = NULL;
00116     }
00117     m_pxmlNodeTree = NULL;
00118 }
00119 
00120 CMessage *
00121 CXMLTextDecoder::decodeMessage (<span class="keywordtype">void</span>)
00122 {
00123     CMessage *                  pMessage;
00124     CXMLTextDecoderStream       DecoderStream(<span class="keyword">this</span>);
00125     CErrorDetails              *pError = &amp;m_ErrorDetails;
00126   
00127     <span class="keywordflow">if</span>(NULL == m_pxmlNodeTree)
00128     {
00129         pError-&gt;m_eResultCode = RC_MiscError;
00130         pError-&gt;m_pWhatStr    = <span class="stringliteral">"Unable to Extract XML Node Tree"</span>;
00131         pError-&gt;m_pRefType    = NULL;
00132         pError-&gt;m_pRefField   = NULL;
00133         pError-&gt;m_OtherDetail = (int) 0;
00134         <span class="keywordflow">return</span> NULL;
00135     }
00136     pMessage = (CMessage *) DecoderStream.decodeElement(TRUE, TRUE);
00137 
00138     <span class="keywordflow">return</span> pMessage;
00139 }
00140 
00141 CXMLTextDecoderStream::CXMLTextDecoderStream (
00142   CXMLTextDecoder *             pDecoder)
00143 {
00144 
00145     m_pDecoder                = pDecoder;
00146     m_pEnclosingDecoderStream = NULL;
00147     m_pRefType                = NULL;
00148     m_pTargetNode             = pDecoder-&gt;m_pxmlNodeTree;
00149     m_pCurrentChildNode       = NULL;
00150 }
00151 
00152 CXMLTextDecoderStream::CXMLTextDecoderStream (
00153   CXMLTextDecoderStream *       pEnclosingDecoderStream)
00154 {
00155     m_pDecoder                = pEnclosingDecoderStream-&gt;m_pDecoder;
00156     m_pEnclosingDecoderStream = pEnclosingDecoderStream;
00157     m_pRefType                = pEnclosingDecoderStream-&gt;m_pRefType;
00158     m_pTargetNode             = pEnclosingDecoderStream-&gt;m_pCurrentChildNode; 
00159     m_pCurrentChildNode       = NULL;
00160 }
00161 
00162 CElement *
00163 CXMLTextDecoderStream::decodeElement (
00164   <span class="keywordtype">int</span>                           bAllowMessage,
00165   <span class="keywordtype">int</span>                           bSkipBlanks)
00166 {
00167     CErrorDetails              *pError = &amp;m_pDecoder-&gt;m_ErrorDetails;
00168     <span class="keyword">const</span> CTypeDescriptor*      pTypeDescriptor;
00169     llrp_u32_t                  MessageID = 0;
00170     CElement *                  pElement;
00171 
00172     <span class="keywordflow">if</span>(<a class="code" href="namespaceLLRP.html#a333a251">RC_OK</a> != pError-&gt;m_eResultCode)
00173     {
00174         <span class="keywordflow">return</span> NULL;
00175     }
00176 
00177     <span class="comment">/* get the first interesting node as the target node */</span>
00178     <span class="keywordflow">if</span>(bSkipBlanks)
00179     {
00180         <span class="keywordflow">while</span> ((NULL != m_pTargetNode) &amp;&amp;
00181                ( isInsignificantNode(m_pTargetNode) || 
00182                  xmlIsBlankNode(m_pTargetNode)))
00183         {
00184             m_pTargetNode = m_pTargetNode-&gt;next;
00185         }
00186     }
00187 
00188     <span class="comment">/* no interestig target node found. THis is OK as its an empty decode */</span>
00189     <span class="keywordflow">if</span>(NULL == m_pTargetNode)
00190     {
00191         <span class="keywordflow">return</span> NULL;
00192     }
00193 
00194     <span class="comment">/* first interesting node had better be an element */</span>
00195     <span class="keywordflow">if</span>(m_pTargetNode-&gt;type != XML_ELEMENT_NODE)
00196     {
00197         pError-&gt;m_eResultCode = RC_XMLInvalidNodeType;
00198         pError-&gt;m_pWhatStr    = <span class="stringliteral">"unexpected XML node type"</span>;
00199         pError-&gt;m_pRefType    = m_pRefType;
00200         pError-&gt;m_pRefField   = NULL;
00201         pError-&gt;m_OtherDetail = (int) m_pTargetNode-&gt;line;
00202         <span class="keywordflow">return</span> NULL;
00203     }
00204 
00205     <span class="comment">/* look up the type descriptor*/</span>
00206     pTypeDescriptor = m_pDecoder-&gt;m_pRegistry-&gt;lookupByName(
00207                                            (<span class="keywordtype">char</span>*) m_pTargetNode-&gt;name);
00208 
00209     <span class="keywordflow">if</span>(NULL == pTypeDescriptor)
00210     {
00211         pError-&gt;m_eResultCode = RC_UnknownParameterType;
00212         pError-&gt;m_pWhatStr    = <span class="stringliteral">"unknown message or parameter type"</span>;
00213         pError-&gt;m_pRefType    = m_pRefType;
00214         pError-&gt;m_pRefField   = NULL;
00215         pError-&gt;m_OtherDetail = (int) m_pTargetNode-&gt;line;
00216         <span class="keywordflow">return</span> NULL;
00217     }
00218 
00219     m_pRefType = pTypeDescriptor;
00220 
00221     <span class="comment">/* process messages a bit specially */</span>
00222     <span class="keywordflow">if</span>(pTypeDescriptor-&gt;m_bIsMessage)
00223     {
00224         xmlChar *               pMessageIDStr;
00225 
00226         <span class="keywordflow">if</span>(!bAllowMessage)
00227         {
00228             pError-&gt;m_eResultCode = RC_MiscError;
00229             pError-&gt;m_pWhatStr    = <span class="stringliteral">"message as subparameter"</span>;
00230             pError-&gt;m_pRefType    = m_pRefType;
00231             pError-&gt;m_pRefField   = NULL;
00232             pError-&gt;m_OtherDetail = (int) m_pTargetNode-&gt;line;
00233             <span class="keywordflow">return</span> NULL;
00234         }
00235 
00236         <span class="comment">/* get the messageID Attribute */</span>
00237         pMessageIDStr = xmlGetProp(m_pTargetNode, 
00238                                    (xmlChar*) <span class="stringliteral">"MessageID"</span>);
00239         <span class="keywordflow">if</span>(NULL != pMessageIDStr)
00240         {
00241             <span class="keywordtype">char</span> *                  pArg = (<span class="keywordtype">char</span> *) pMessageIDStr;
00242             <span class="keywordtype">char</span> *                  pTail = pArg + strlen((<span class="keywordtype">char</span>*) pMessageIDStr);
00243             <span class="keywordtype">char</span> *                  pTmp;
00244             cleanString((<span class="keyword">const</span> llrp_u8_t **) &amp;pArg, (<span class="keyword">const</span> llrp_u8_t **) &amp;pTail);
00245             MessageID = strtoul(pArg, &amp;pTmp, 10);
00246             xmlFree(pMessageIDStr);
00247 
00248             <span class="keywordflow">if</span>(pTail != pTmp)
00249             {
00250                 <span class="comment">/* malformed */</span>
00251                 pError-&gt;m_eResultCode = RC_MiscError;
00252                 pError-&gt;m_pWhatStr    = <span class="stringliteral">"malformed MessageID"</span>;
00253                 pError-&gt;m_pRefType    = m_pRefType;
00254                 pError-&gt;m_pRefField   = NULL;
00255                 pError-&gt;m_OtherDetail = (int) m_pTargetNode-&gt;line;
00256                 <span class="keywordflow">return</span> NULL;
00257             }
00258         }
00259     }
00260 
00261     <span class="comment">/* create our element to hold the information */</span>
00262     pElement = pTypeDescriptor-&gt;constructElement();
00263 
00264     <span class="keywordflow">if</span>(NULL == pElement)
00265     {
00266         pError-&gt;m_eResultCode = RC_MessageAllocationFailed;
00267         pError-&gt;m_pWhatStr    = <span class="stringliteral">"element allocation failed"</span>;
00268         pError-&gt;m_pRefType    = m_pRefType;
00269         pError-&gt;m_pRefField   = NULL;
00270         pError-&gt;m_OtherDetail = (int) m_pTargetNode-&gt;line;
00271         <span class="keywordflow">return</span> NULL;
00272     }
00273 
00274     <span class="comment">/* only write the message ID for messages */</span>
00275     <span class="keywordflow">if</span>(pTypeDescriptor-&gt;m_bIsMessage)
00276     {
00277         ((CMessage *) pElement)-&gt;setMessageID(MessageID);
00278     }
00279 
00280     <span class="comment">/* now switch to decode the children which are the</span>
00281 <span class="comment">     * fields and sub-parameters of this element */</span>
00282     m_pCurrentChildNode = m_pTargetNode-&gt;children;
00283 
00284     <span class="comment">/* decode the fields first */</span>
00285     pTypeDescriptor-&gt;m_pfDecodeFields(<span class="keyword">this</span>, pElement);
00286 
00287     <span class="keywordflow">if</span>(<a class="code" href="namespaceLLRP.html#a333a251">RC_OK</a> != pError-&gt;m_eResultCode)
00288     {
00289         <span class="keyword">delete</span> pElement;
00290         <span class="keywordflow">return</span> NULL;
00291     }
00292 
00293     <span class="comment">/*</span>
00294 <span class="comment">     * Subparameters.</span>
00295 <span class="comment">     *</span>
00296 <span class="comment">     * loop through all the remaining children of the target node and try to find sub-parameters.</span>
00297 <span class="comment">     * We are done when we don't have any more or error</span>
00298 <span class="comment">     */</span>
00299     <span class="keywordflow">for</span>(; m_pCurrentChildNode != NULL; 
00300             m_pCurrentChildNode = m_pCurrentChildNode-&gt;next)
00301     {
00302         CElement *              pSubElement;
00303         CParameter *            pParameter;
00304 
00305         <span class="keywordflow">if</span>(isInsignificantNode(m_pCurrentChildNode))
00306         {
00307                 <span class="keywordflow">continue</span>;
00308         }
00309 
00310         <span class="keywordflow">if</span>(xmlIsBlankNode(m_pCurrentChildNode))
00311         {
00312                 <span class="keywordflow">continue</span>;
00313         }
00314 
00315         CXMLTextDecoderStream   NestStream(<span class="keyword">this</span>);
00316 
00317         pSubElement = NestStream.decodeElement(FALSE, FALSE);
00318 
00319         <span class="comment">/* nothing more to decode as a sub-element or failure */</span>
00320         <span class="keywordflow">if</span>(NULL == pSubElement)
00321         {
00322             <span class="keywordflow">break</span>;
00323         }
00324 
00325         pParameter = (CParameter *) pSubElement;
00326 
00327         pParameter-&gt;m_pParent = pElement;
00328         pElement-&gt;addSubParameterToAllList(pParameter);
00329     }
00330 
00331     <span class="keywordflow">if</span>(<a class="code" href="namespaceLLRP.html#a333a251">RC_OK</a> != pError-&gt;m_eResultCode)
00332     {
00333         <span class="keyword">delete</span> pElement;
00334         <span class="keywordflow">return</span> NULL;
00335     }
00336 
00337     pElement-&gt;assimilateSubParameters(pError);
00338 
00339     <span class="keywordflow">if</span>(<a class="code" href="namespaceLLRP.html#a333a251">RC_OK</a> != pError-&gt;m_eResultCode)
00340     {
00341         <span class="keyword">delete</span> pElement;
00342         <span class="keywordflow">return</span> NULL;
00343     }
00344 
00345     <span class="keywordflow">return</span> pElement;
00346 }
00347 
00349 llrp_u8_t
00350 CXMLTextDecoderStream::get_u8 (
00351   <span class="keyword">const</span> CFieldDescriptor *      pFieldDesc)
00352 {
00353     llrp_u8_t Value;
00354     Value = (llrp_u8_t) getIntegerField(pFieldDesc, MIN_U8, MAX_U8);
00355     <span class="keywordflow">return</span> Value;
00356 }
00357 
00359 llrp_s8_t
00360 CXMLTextDecoderStream::get_s8 (
00361   <span class="keyword">const</span> CFieldDescriptor *      pFieldDesc)
00362 {
00363     llrp_s8_t Value;
00364     Value = (llrp_s8_t) getIntegerField(pFieldDesc, MIN_S8, MAX_S8);
00365     <span class="keywordflow">return</span> Value;
00366 }
00367 
00369 llrp_u8v_t
00370 CXMLTextDecoderStream::get_u8v (
00371   <span class="keyword">const</span> CFieldDescriptor *      pFieldDesc)
00372 {
00373     CErrorDetails *             pError;
00374     llrp_u8v_t                  Value;
00375     llrp_s64v_t                 Tmp;
00376 
00377     pError = &amp;m_pDecoder-&gt;m_ErrorDetails;
00378 
00379     <span class="keywordflow">switch</span>(pFieldDesc-&gt;m_eFieldFormat)
00380     {
00381         <span class="comment">/* assume normal format here is decimal */</span>
00382         <span class="keywordflow">case</span> CFieldDescriptor::FMT_NORMAL:
00383         <span class="keywordflow">case</span> CFieldDescriptor::FMT_DEC:
00384         Tmp = getSpacedVectorField(pFieldDesc, MIN_U8, MAX_U8);
00385         <span class="keywordflow">break</span>;
00386         <span class="keywordflow">case</span> CFieldDescriptor::FMT_HEX:
00387         Tmp = getFixedVectorField(pFieldDesc, 2, MIN_U8, MAX_U8);       
00388         <span class="keywordflow">break</span>;
00389         <span class="keywordflow">default</span>:
00390         <span class="keywordflow">case</span> CFieldDescriptor::FMT_UTF8:
00391         <span class="keywordflow">case</span> CFieldDescriptor::FMT_DATETIME:
00392             <span class="keywordflow">if</span>(NULL != pError)
00393             {
00394                 pError-&gt;m_eResultCode = RC_MiscError;
00395                 pError-&gt;m_pWhatStr    = <span class="stringliteral">"Format type not support for field"</span>;
00396                 pError-&gt;m_pRefType    = m_pRefType;
00397                 pError-&gt;m_pRefField   = pFieldDesc;
00398                 pError-&gt;m_OtherDetail = (int) m_pCurrentChildNode-&gt;line;
00399             }       
00400         <span class="keywordflow">break</span>;
00401     }    
00402 
00403     <span class="keywordflow">if</span>(Tmp.m_nValue)
00404     {
00405         llrp_u16_t              nValue;
00406 
00407         nValue = Tmp.m_nValue;
00408         Value = llrp_u8v_t(nValue);
00409         <span class="keywordflow">if</span>(verifyVectorAllocation(Value.m_pValue, pFieldDesc))
00410         {
00411             <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>    Ix;
00412 
00413             <span class="keywordflow">for</span>(Ix = 0; Ix &lt; nValue; Ix++)
00414             {
00415                 Value.m_pValue[Ix] = (llrp_u8_t) Tmp.m_pValue[Ix];
00416             }
00417         }
00418     }
00419 
00420     <span class="keywordflow">return</span> Value;
00421 }
00422 
00424 llrp_s8v_t
00425 CXMLTextDecoderStream::get_s8v (
00426   <span class="keyword">const</span> CFieldDescriptor *      pFieldDesc)
00427 {
00428     CErrorDetails *             pError;
00429     llrp_s8v_t                  Value;
00430     llrp_s64v_t                 Tmp;
00431 
00432     pError = &amp;m_pDecoder-&gt;m_ErrorDetails;
00433 
00434     <span class="keywordflow">switch</span>(pFieldDesc-&gt;m_eFieldFormat)
00435     {
00436         <span class="comment">/* assume normal format here is decimal */</span>
00437         <span class="keywordflow">case</span> CFieldDescriptor::FMT_NORMAL:
00438         <span class="keywordflow">case</span> CFieldDescriptor::FMT_DEC:
00439         Tmp = getSpacedVectorField(pFieldDesc, MIN_S8, MAX_S8);
00440         <span class="keywordflow">break</span>;
00441         <span class="keywordflow">case</span> CFieldDescriptor::FMT_HEX:
00442         Tmp = getFixedVectorField(pFieldDesc, 2, MIN_S8, MAX_S8);       
00443         <span class="keywordflow">break</span>;
00444         <span class="keywordflow">default</span>:
00445         <span class="keywordflow">case</span> CFieldDescriptor::FMT_UTF8:
00446         <span class="keywordflow">case</span> CFieldDescriptor::FMT_DATETIME:
00447             <span class="keywordflow">if</span>(NULL != pError)
00448             {
00449                 pError-&gt;m_eResultCode = RC_MiscError;
00450                 pError-&gt;m_pWhatStr    = <span class="stringliteral">"Format type not support for field"</span>;
00451                 pError-&gt;m_pRefType    = m_pRefType;
00452                 pError-&gt;m_pRefField   = pFieldDesc;
00453                 pError-&gt;m_OtherDetail = (int) m_pCurrentChildNode-&gt;line;
00454             }       
00455         <span class="keywordflow">break</span>;
00456     }    
00457 
00458     <span class="keywordflow">if</span>(Tmp.m_nValue)
00459     {
00460         llrp_u16_t              nValue;
00461 
00462         nValue = Tmp.m_nValue;
00463         Value = llrp_s8v_t(nValue);
00464         <span class="keywordflow">if</span>(verifyVectorAllocation(Value.m_pValue, pFieldDesc))
00465         {
00466             <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>    Ix;
00467 
00468             <span class="keywordflow">for</span>(Ix = 0; Ix &lt; nValue; Ix++)
00469             {
00470                 Value.m_pValue[Ix] = (llrp_s8_t) Tmp.m_pValue[Ix];
00471             }
00472         }
00473     }
00474 
00475     <span class="keywordflow">return</span> Value;
00476 }
00477 
00478 <span class="comment">/*</span>
00479 <span class="comment"> * 16-bit types</span>
00480 <span class="comment"> */</span>
00481 
00483 llrp_u16_t
00484 CXMLTextDecoderStream::get_u16 (
00485   <span class="keyword">const</span> CFieldDescriptor *      pFieldDesc)
00486 {
00487     llrp_u16_t Value;
00488     Value = (llrp_u16_t) getIntegerField(pFieldDesc, MIN_U16, MAX_U16);
00489     <span class="keywordflow">return</span> Value;
00490 }
00491 
00493 llrp_s16_t
00494 CXMLTextDecoderStream::get_s16 (
00495   <span class="keyword">const</span> CFieldDescriptor *      pFieldDesc)
00496 {
00497     llrp_s16_t Value;
00498     Value = (llrp_s16_t) getIntegerField(pFieldDesc, MIN_S16, MAX_S16);
00499     <span class="keywordflow">return</span> Value;
00500 }
00501 
00503 llrp_u16v_t
00504 CXMLTextDecoderStream::get_u16v (
00505   <span class="keyword">const</span> CFieldDescriptor *      pFieldDesc)
00506 {
00507     CErrorDetails *             pError;
00508     llrp_u16v_t                  Value;
00509     llrp_s64v_t                 Tmp;
00510 
00511     pError = &amp;m_pDecoder-&gt;m_ErrorDetails;
00512 
00513     <span class="keywordflow">switch</span>(pFieldDesc-&gt;m_eFieldFormat)
00514     {
00515         <span class="comment">/* assume normal format here is decimal */</span>
00516         <span class="keywordflow">case</span> CFieldDescriptor::FMT_NORMAL:
00517         <span class="keywordflow">case</span> CFieldDescriptor::FMT_DEC:
00518         <span class="keywordflow">case</span> CFieldDescriptor::FMT_HEX:
00519             Tmp = getSpacedVectorField(pFieldDesc, MIN_U16, MAX_U16);
00520             <span class="keywordflow">break</span>;
00521         <span class="keywordflow">default</span>:
00522         <span class="keywordflow">case</span> CFieldDescriptor::FMT_UTF8:
00523         <span class="keywordflow">case</span> CFieldDescriptor::FMT_DATETIME:
00524             <span class="keywordflow">if</span>(NULL != pError)
00525             {
00526                 pError-&gt;m_eResultCode = RC_MiscError;
00527                 pError-&gt;m_pWhatStr    = <span class="stringliteral">"Format type not support for field"</span>;
00528                 pError-&gt;m_pRefType    = m_pRefType;
00529                 pError-&gt;m_pRefField   = pFieldDesc;
00530                 pError-&gt;m_OtherDetail = (int) m_pCurrentChildNode-&gt;line;
00531             }       
00532         <span class="keywordflow">break</span>;
00533     }    
00534 
00535     <span class="keywordflow">if</span>(Tmp.m_nValue)
00536     {
00537         llrp_u16_t              nValue;
00538 
00539         nValue = Tmp.m_nValue;
00540         Value = llrp_u16v_t(nValue);
00541         <span class="keywordflow">if</span>(verifyVectorAllocation(Value.m_pValue, pFieldDesc))
00542         {
00543             <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>    Ix;
00544 
00545             <span class="keywordflow">for</span>(Ix = 0; Ix &lt; nValue; Ix++)
00546             {
00547                 Value.m_pValue[Ix] = (llrp_u16_t) Tmp.m_pValue[Ix];
00548             }
00549         }
00550     }
00551     <span class="keywordflow">return</span> Value;
00552 }
00553 
00555 llrp_s16v_t
00556 CXMLTextDecoderStream::get_s16v (
00557   <span class="keyword">const</span> CFieldDescriptor *      pFieldDesc)
00558 {
00559     CErrorDetails *             pError;
00560     llrp_s16v_t                  Value;
00561     llrp_s64v_t                 Tmp;
00562 
00563     pError = &amp;m_pDecoder-&gt;m_ErrorDetails;
00564 
00565     <span class="keywordflow">switch</span>(pFieldDesc-&gt;m_eFieldFormat)
00566     {
00567         <span class="comment">/* assume normal format here is decimal */</span>
00568         <span class="keywordflow">case</span> CFieldDescriptor::FMT_NORMAL:
00569         <span class="keywordflow">case</span> CFieldDescriptor::FMT_DEC:
00570         <span class="keywordflow">case</span> CFieldDescriptor::FMT_HEX:
00571             Tmp = getSpacedVectorField(pFieldDesc, MIN_S16, MAX_S16);
00572             <span class="keywordflow">break</span>;
00573         <span class="keywordflow">default</span>:
00574         <span class="keywordflow">case</span> CFieldDescriptor::FMT_UTF8:
00575         <span class="keywordflow">case</span> CFieldDescriptor::FMT_DATETIME:
00576             <span class="keywordflow">if</span>(NULL != pError)
00577             {
00578                 pError-&gt;m_eResultCode = RC_MiscError;
00579                 pError-&gt;m_pWhatStr    = <span class="stringliteral">"Format type not support for field"</span>;
00580                 pError-&gt;m_pRefType    = m_pRefType;
00581                 pError-&gt;m_pRefField   = pFieldDesc;
00582                 pError-&gt;m_OtherDetail = (int) m_pCurrentChildNode-&gt;line;
00583             }       
00584         <span class="keywordflow">break</span>;
00585     }    
00586 
00587     <span class="keywordflow">if</span>(Tmp.m_nValue)
00588     {
00589         llrp_u16_t              nValue;
00590 
00591         nValue = Tmp.m_nValue;
00592         Value = llrp_s16v_t(nValue);
00593         <span class="keywordflow">if</span>(verifyVectorAllocation(Value.m_pValue, pFieldDesc))
00594         {
00595             <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>    Ix;
00596 
00597             <span class="keywordflow">for</span>(Ix = 0; Ix &lt; nValue; Ix++)
00598             {
00599                 Value.m_pValue[Ix] = (llrp_s16_t) Tmp.m_pValue[Ix];
00600             }
00601         }
00602     }
00603     <span class="keywordflow">return</span> Value;
00604 }
00605 
00606 <span class="comment">/*</span>
00607 <span class="comment"> * 32-bit types</span>
00608 <span class="comment"> */</span>
00609 
00611 llrp_u32_t
00612 CXMLTextDecoderStream::get_u32 (
00613   <span class="keyword">const</span> CFieldDescriptor *      pFieldDesc)
00614 {
00615     llrp_u32_t Value;
00616     Value = (llrp_u32_t) getIntegerField(pFieldDesc, MIN_U32, MAX_U32);
00617     <span class="keywordflow">return</span> Value;
00618 }
00619 
00621 llrp_s32_t
00622 CXMLTextDecoderStream::get_s32 (
00623   <span class="keyword">const</span> CFieldDescriptor *      pFieldDesc)
00624 {
00625     llrp_s32_t Value;
00626     Value = (llrp_s32_t) getIntegerField(pFieldDesc, MIN_S32, MAX_S32);
00627     <span class="keywordflow">return</span> Value;
00628 }
00629 
00631 llrp_u32v_t
00632 CXMLTextDecoderStream::get_u32v (
00633   <span class="keyword">const</span> CFieldDescriptor *      pFieldDesc)
00634 {
00635     CErrorDetails *             pError;
00636     llrp_u32v_t                 Value;
00637     llrp_s64v_t                 Tmp;
00638 
00639     pError = &amp;m_pDecoder-&gt;m_ErrorDetails;
00640 
00641     <span class="keywordflow">switch</span>(pFieldDesc-&gt;m_eFieldFormat)
00642     {
00643         <span class="comment">/* assume normal format here is decimal */</span>
00644         <span class="keywordflow">case</span> CFieldDescriptor::FMT_NORMAL:
00645         <span class="keywordflow">case</span> CFieldDescriptor::FMT_DEC:
00646         <span class="keywordflow">case</span> CFieldDescriptor::FMT_HEX:
00647             Tmp = getSpacedVectorField(pFieldDesc, MIN_U32, MAX_U32);
00648             <span class="keywordflow">break</span>;
00649         <span class="keywordflow">default</span>:
00650         <span class="keywordflow">case</span> CFieldDescriptor::FMT_UTF8:
00651         <span class="keywordflow">case</span> CFieldDescriptor::FMT_DATETIME:
00652             <span class="keywordflow">if</span>(NULL != pError)
00653             {
00654                 pError-&gt;m_eResultCode = RC_MiscError;
00655                 pError-&gt;m_pWhatStr    = <span class="stringliteral">"Format type not support for field"</span>;
00656                 pError-&gt;m_pRefType    = m_pRefType;
00657                 pError-&gt;m_pRefField   = pFieldDesc;
00658                 pError-&gt;m_OtherDetail = (int) m_pCurrentChildNode-&gt;line;
00659             }       
00660         <span class="keywordflow">break</span>;
00661     }    
00662 
00663     <span class="keywordflow">if</span>(Tmp.m_nValue)
00664     {
00665         llrp_u16_t              nValue;
00666 
00667         nValue = Tmp.m_nValue;
00668         Value = llrp_u32v_t(nValue);
00669         <span class="keywordflow">if</span>(verifyVectorAllocation(Value.m_pValue, pFieldDesc))
00670         {
00671             <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>    Ix;
00672 
00673             <span class="keywordflow">for</span>(Ix = 0; Ix &lt; nValue; Ix++)
00674             {
00675                 Value.m_pValue[Ix] = (llrp_u32_t) Tmp.m_pValue[Ix];
00676             }
00677         }
00678     }
00679     <span class="keywordflow">return</span> Value;
00680 }
00681 
00683 llrp_s32v_t
00684 CXMLTextDecoderStream::get_s32v (
00685   <span class="keyword">const</span> CFieldDescriptor *      pFieldDesc)
00686 {
00687     CErrorDetails *             pError;
00688     llrp_s32v_t                 Value;
00689     llrp_s64v_t                 Tmp;
00690 
00691     pError = &amp;m_pDecoder-&gt;m_ErrorDetails;
00692 
00693     <span class="keywordflow">switch</span>(pFieldDesc-&gt;m_eFieldFormat)
00694     {
00695         <span class="comment">/* assume normal format here is decimal */</span>
00696         <span class="keywordflow">case</span> CFieldDescriptor::FMT_NORMAL:
00697         <span class="keywordflow">case</span> CFieldDescriptor::FMT_DEC:
00698         <span class="keywordflow">case</span> CFieldDescriptor::FMT_HEX:
00699             Tmp = getSpacedVectorField(pFieldDesc, MIN_S32, MAX_S32);
00700             <span class="keywordflow">break</span>;
00701         <span class="keywordflow">default</span>:
00702         <span class="keywordflow">case</span> CFieldDescriptor::FMT_UTF8:
00703         <span class="keywordflow">case</span> CFieldDescriptor::FMT_DATETIME:
00704             <span class="keywordflow">if</span>(NULL != pError)
00705             {
00706                 pError-&gt;m_eResultCode = RC_MiscError;
00707                 pError-&gt;m_pWhatStr    = <span class="stringliteral">"Format type not support for field"</span>;
00708                 pError-&gt;m_pRefType    = m_pRefType;
00709                 pError-&gt;m_pRefField   = pFieldDesc;
00710                 pError-&gt;m_OtherDetail = (int) m_pCurrentChildNode-&gt;line;
00711             }       
00712         <span class="keywordflow">break</span>;
00713     }    
00714 
00715     <span class="keywordflow">if</span>(Tmp.m_nValue)
00716     {
00717         llrp_u16_t              nValue;
00718 
00719         nValue = Tmp.m_nValue;
00720         Value = llrp_s32v_t(nValue);
00721         <span class="keywordflow">if</span>(verifyVectorAllocation(Value.m_pValue, pFieldDesc))
00722         {
00723             <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>    Ix;
00724 
00725             <span class="keywordflow">for</span>(Ix = 0; Ix &lt; nValue; Ix++)
00726             {
00727                 Value.m_pValue[Ix] = (llrp_s32_t) Tmp.m_pValue[Ix];
00728             }
00729         }
00730     }
00731     <span class="keywordflow">return</span> Value;
00732 }
00733 
00734 <span class="comment">/*</span>
00735 <span class="comment"> * 64-bit types</span>
00736 <span class="comment"> */</span>
00737 
00739 llrp_u64_t
00740 CXMLTextDecoderStream::get_u64 (
00741   <span class="keyword">const</span> CFieldDescriptor *      pFieldDesc)
00742 {
00743     llrp_u64_t Value;
00744     Value = (llrp_u64_t) getIntegerField(pFieldDesc, MIN_U64, MAX_U64);
00745     <span class="keywordflow">return</span> Value;
00746 }
00747 
00749 llrp_s64_t
00750 CXMLTextDecoderStream::get_s64 (
00751   <span class="keyword">const</span> CFieldDescriptor *      pFieldDesc)
00752 {
00753     llrp_s64_t Value;
00754     Value = (llrp_s64_t) getIntegerField(pFieldDesc, MIN_S64, MAX_S64);
00755     <span class="keywordflow">return</span> Value;
00756 }
00757 
00759 llrp_u64v_t
00760 CXMLTextDecoderStream::get_u64v (
00761   <span class="keyword">const</span> CFieldDescriptor *      pFieldDesc)
00762 {
00763     CErrorDetails *             pError;
00764     llrp_u64v_t                 Value;
00765     llrp_s64v_t                 Tmp;
00766 
00767     pError = &amp;m_pDecoder-&gt;m_ErrorDetails;
00768 
00769     <span class="keywordflow">switch</span>(pFieldDesc-&gt;m_eFieldFormat)
00770     {
00771         <span class="comment">/* assume normal format here is decimal */</span>
00772         <span class="keywordflow">case</span> CFieldDescriptor::FMT_NORMAL:
00773         <span class="keywordflow">case</span> CFieldDescriptor::FMT_DEC:
00774         <span class="keywordflow">case</span> CFieldDescriptor::FMT_HEX:
00775         <span class="keywordflow">case</span> CFieldDescriptor::FMT_DATETIME:
00776             Tmp = getSpacedVectorField(pFieldDesc, MIN_U64, MAX_U64);
00777             <span class="keywordflow">break</span>;
00778         <span class="keywordflow">default</span>:
00779         <span class="keywordflow">case</span> CFieldDescriptor::FMT_UTF8:
00780             <span class="keywordflow">if</span>(NULL != pError)
00781             {
00782                 pError-&gt;m_eResultCode = RC_MiscError;
00783                 pError-&gt;m_pWhatStr    = <span class="stringliteral">"Format type not support for field"</span>;
00784                 pError-&gt;m_pRefType    = m_pRefType;
00785                 pError-&gt;m_pRefField   = pFieldDesc;
00786                 pError-&gt;m_OtherDetail = (int) m_pCurrentChildNode-&gt;line;
00787             }       
00788         <span class="keywordflow">break</span>;
00789     }    
00790 
00791     <span class="keywordflow">if</span>(Tmp.m_nValue)
00792     {
00793         llrp_u16_t              nValue;
00794 
00795         nValue = Tmp.m_nValue;
00796         Value = llrp_u64v_t(nValue);
00797         <span class="keywordflow">if</span>(verifyVectorAllocation(Value.m_pValue, pFieldDesc))
00798         {
00799             <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>    Ix;
00800 
00801             <span class="keywordflow">for</span>(Ix = 0; Ix &lt; nValue; Ix++)
00802             {
00803                 Value.m_pValue[Ix] = (llrp_u64_t) Tmp.m_pValue[Ix];
00804             }
00805         }
00806     }
00807     <span class="keywordflow">return</span> Value;
00808 }
00809 
00811 llrp_s64v_t
00812 CXMLTextDecoderStream::get_s64v (
00813   <span class="keyword">const</span> CFieldDescriptor *      pFieldDesc)
00814 {
00815     llrp_s64v_t Value;
00816     Value = getSpacedVectorField(pFieldDesc, MIN_S64, MAX_S64); 
00817     <span class="keywordflow">return</span> Value;
00818 }
00819 
00820 <span class="comment">/*</span>
00821 <span class="comment"> * Special types</span>
00822 <span class="comment"> */</span>
00823 
00825 llrp_u1_t
00826 CXMLTextDecoderStream::get_u1 (
00827   <span class="keyword">const</span> CFieldDescriptor *      pFieldDesc)
00828 {
00829     llrp_u1_t Value;
00830     Value = (llrp_u1_t) getIntegerField(pFieldDesc, 0, 1);
00831     <span class="keywordflow">return</span> Value;
00832 }
00833 
00835 llrp_u1v_t
00836 CXMLTextDecoderStream::get_u1v (
00837   <span class="keyword">const</span> CFieldDescriptor *      pFieldDesc)
00838 {
00839     CErrorDetails *             pError;
00840     llrp_u1v_t                  Value;
00841     llrp_s64v_t                 Tmp;
00842 
00843     pError = &amp;m_pDecoder-&gt;m_ErrorDetails;
00844     Tmp = getFixedVectorField(pFieldDesc, 2, 0, 255);
00845 
00846     <span class="keywordflow">if</span>(Tmp.m_nValue)
00847     {
00848         llrp_u16_t              nValue;
00849 
00850         nValue = Tmp.m_nValue;
00851         Value = llrp_u1v_t(nValue*8);
00852         <span class="keywordflow">if</span>(verifyVectorAllocation(Value.m_pValue, pFieldDesc))
00853         {
00854             <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>        Ix;
00855             xmlChar *           pCountStr;
00856 
00857             <span class="keywordflow">for</span>(Ix = 0; Ix &lt; nValue; Ix++)
00858             {
00859                 Value.m_pValue[Ix] = (llrp_u1_t) Tmp.m_pValue[Ix];
00860             }
00861             <span class="comment">/* bit length could be shorter than this. Use this if there</span>
00862 <span class="comment">             * is no attribute */</span>
00863             Value.m_nBit = Tmp.m_nValue * 8;
00864 
00865             <span class="comment">/* find the XML attribute for Count and fix the array */</span>
00866             <span class="keywordflow">if</span>(NULL != m_pLastFieldNode)
00867             {
00868                 pCountStr = xmlGetProp(m_pLastFieldNode, 
00869                                        (xmlChar*) <span class="stringliteral">"Count"</span>);
00870                 <span class="keywordflow">if</span>(NULL != pCountStr)
00871                 {
00872                     <span class="keywordtype">char</span> *      pArg = (<span class="keywordtype">char</span> *) pCountStr;
00873                     <span class="keywordtype">char</span> *      pTail = pArg + strlen((<span class="keywordtype">char</span>*) pCountStr);
00874                     llrp_u16_t  nBits;
00875 
00876                     nBits = (llrp_u16_t) strtoul(pArg, &amp;pTail, 10);
00877                     <span class="keywordflow">if</span>( (*pTail != 0) ||
00878                         (nBits &gt; (Tmp.m_nValue * 8)))
00879                     {
00880                         <span class="comment">/* malformed */</span>
00881                         pError-&gt;m_eResultCode = RC_MiscError;
00882                         pError-&gt;m_pWhatStr    = <span class="stringliteral">"malformed Count Attribute"</span>;
00883                         pError-&gt;m_pRefType    = m_pRefType;
00884                         pError-&gt;m_pRefField   = pFieldDesc;
00885                         pError-&gt;m_OtherDetail = (int) m_pLastFieldNode-&gt;line;
00886                     }                
00887                     <span class="keywordflow">else</span>
00888                     {
00889                         llrp_u16_t lastByteBits;
00890                         llrp_u8_t  lastByteMask;
00891                                     
00892                         Value.m_nBit = nBits;           
00893 
00894                         <span class="comment">/* zero off the last bits if they were non-zero */</span>
00895                         lastByteBits = nBits % 8;           
00896                         <span class="keywordflow">if</span>(lastByteBits)
00897                         {
00898                             <span class="comment">/* convert the bit position to a mask */</span>
00899                             lastByteBits = 8 - lastByteBits;
00900                             lastByteMask = (1 &lt;&lt; lastByteBits) - 1;
00901                             <span class="comment">/* invert mask */</span>
00902                             lastByteMask = ~lastByteMask;
00903                             <span class="comment">/* clear bits */</span>
00904                             Value.m_pValue[Ix] &amp;= lastByteMask;
00905                         }
00906                     }
00907                     xmlFree(pCountStr);
00908                 }
00909             }
00910         }
00911     }
00912     <span class="keywordflow">return</span> Value;
00913 }
00914 
00916 llrp_u2_t
00917 CXMLTextDecoderStream::get_u2 (
00918   <span class="keyword">const</span> CFieldDescriptor *      pFieldDesc)
00919 {
00920     llrp_u2_t Value;
00921     Value = (llrp_u2_t) getIntegerField(pFieldDesc, 0, 3);
00922     <span class="keywordflow">return</span> Value;
00923 }
00924 
00926 llrp_u96_t
00927 CXMLTextDecoderStream::get_u96 (
00928   <span class="keyword">const</span> CFieldDescriptor *      pFieldDesc)
00929 {
00930     CErrorDetails *             pError; 
00931     llrp_u96_t                  Value;
00932     llrp_s64v_t                 Tmp;
00933     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>    Ix;
00934 
00935     pError = &amp;m_pDecoder-&gt;m_ErrorDetails;
00936 
00937     Tmp = getFixedVectorField( pFieldDesc, 2, 0, 255);
00938 
00939     <span class="keywordflow">if</span>((<a class="code" href="namespaceLLRP.html#a333a251">RC_OK</a> != pError-&gt;m_eResultCode) &amp;&amp; (Tmp.m_nValue != 12))
00940     {
00941         <span class="keywordflow">if</span>(NULL != pError)
00942         {
00943             pError-&gt;m_eResultCode = RC_MiscError;
00944             pError-&gt;m_pWhatStr    = <span class="stringliteral">"Illegal length u96 field"</span>;
00945             pError-&gt;m_pRefType    = m_pRefType;
00946             pError-&gt;m_pRefField   = pFieldDesc;
00947             pError-&gt;m_OtherDetail = (int) m_pCurrentChildNode-&gt;line;
00948         }
00949         <span class="keywordflow">return</span> Value;    
00950     }
00951 
00952     <span class="comment">/* convert to this type */</span>
00953     <span class="keywordflow">for</span>(Ix = 0; Ix &lt; Tmp.m_nValue; Ix++)
00954     {
00955         Value.m_aValue[Ix] = (llrp_u8_t) Tmp.m_pValue[Ix];
00956     }
00957   
00958     <span class="keywordflow">return</span> Value;
00959 }
00960 
00962 llrp_utf8v_t
00963 CXMLTextDecoderStream::get_utf8v (
00964   <span class="keyword">const</span> CFieldDescriptor *      pFieldDesc)
00965 {
00966     llrp_utf8v_t                Value;
00967     llrp_u16_t                  nValue;
00968     <span class="keyword">const</span> llrp_u8_t *           pbuf;
00969     <span class="keyword">const</span> llrp_u8_t *           pend;
00970 
00971     <span class="keywordflow">if</span>(getFieldStringPtr(pFieldDesc, &amp;pbuf, &amp;pend))
00972     {
00973         nValue = (llrp_u16_t) strlen((<span class="keywordtype">char</span>*) pbuf);
00974         Value = llrp_utf8v_t(nValue);
00975 
00976         <span class="keywordflow">if</span>(verifyVectorAllocation(Value.m_pValue, pFieldDesc))
00977         {
00978             <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>    Ix;
00979 
00980             <span class="keywordflow">for</span>(Ix = 0; Ix &lt; nValue; Ix++)
00981             {
00982                 Value.m_pValue[Ix] = pbuf[Ix];
00983             }
00984         }    
00985     }
00986     <span class="keywordflow">else</span>
00987     {
00988         <span class="comment">/* its valid for UTF8 strings to be empty */</span>
00989         Value.m_nValue=0;
00990         Value.m_pValue=NULL;
00991     }
00992     <span class="keywordflow">return</span> Value;
00993 }
00994 
00996 llrp_bytesToEnd_t
00997 CXMLTextDecoderStream::get_bytesToEnd (
00998   <span class="keyword">const</span> CFieldDescriptor *      pFieldDesc)
00999 {
01000     llrp_bytesToEnd_t           Value;
01001     llrp_s64v_t                 Tmp;
01002     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>                Ix;
01003 
01004     Tmp = getFixedVectorField( pFieldDesc, 2, 0, 255);
01005 
01006     <span class="keywordflow">if</span>(verifyVectorAllocation(Tmp.m_pValue, pFieldDesc))
01007     {
01008         <span class="comment">/* build and convert */</span>
01009         Value = llrp_bytesToEnd_t(Tmp.m_nValue);
01010         <span class="keywordflow">if</span>(verifyVectorAllocation(Tmp.m_pValue, pFieldDesc))
01011         {
01012             <span class="comment">/* convert to this type */</span>
01013             <span class="keywordflow">for</span>(Ix = 0; Ix &lt; Tmp.m_nValue; Ix++)
01014             {
01015                 Value.m_pValue[Ix] = (llrp_byte_t) Tmp.m_pValue[Ix];
01016             }
01017             Value.m_nValue = Tmp.m_nValue;
01018         }
01019     }
01020     <span class="keywordflow">return</span> Value;
01021 }
01022 
01023 <span class="comment">/*</span>
01024 <span class="comment"> * Enumerated types of various sizes</span>
01025 <span class="comment"> */</span>
01026 
01028 <span class="keywordtype">int</span>
01029 CXMLTextDecoderStream::get_e1 (
01030   <span class="keyword">const</span> CFieldDescriptor *      pFieldDesc)
01031 {
01032     <span class="keywordtype">int</span>                         Value;
01033     Value = (int) getIntegerField(pFieldDesc, 0, 1);
01034     <span class="keywordflow">return</span> Value;
01035 }
01036 
01038 <span class="keywordtype">int</span>
01039 CXMLTextDecoderStream::get_e2 (
01040   <span class="keyword">const</span> CFieldDescriptor *      pFieldDesc)
01041 {
01042     <span class="keywordtype">int</span>                         Value;
01043     Value = (int) getIntegerField(pFieldDesc, 0, 3);
01044     <span class="keywordflow">return</span> Value;
01045 }
01046 
01048 <span class="keywordtype">int</span>
01049 CXMLTextDecoderStream::get_e8 (
01050   <span class="keyword">const</span> CFieldDescriptor *      pFieldDesc)
01051 {
01052     <span class="keywordtype">int</span>                         Value;
01053     Value = (int) getIntegerField(pFieldDesc, MIN_U8, MAX_U8);
01054     <span class="keywordflow">return</span> Value;
01055 }
01056 
01058 <span class="keywordtype">int</span>
01059 CXMLTextDecoderStream::get_e16 (
01060   <span class="keyword">const</span> CFieldDescriptor *      pFieldDesc)
01061 {
01062     <span class="keywordtype">int</span>                         Value;
01063     Value = (int) getIntegerField(pFieldDesc, MIN_U16, MAX_U16);
01064     <span class="keywordflow">return</span> Value;
01065 }
01066 
01068 <span class="keywordtype">int</span>
01069 CXMLTextDecoderStream::get_e32 (
01070   <span class="keyword">const</span> CFieldDescriptor *      pFieldDesc)
01071 {
01072     <span class="keywordtype">int</span>                         Value;
01073     Value = (int) getIntegerField(pFieldDesc, MIN_U32, MAX_U32);
01074     <span class="keywordflow">return</span> Value;
01075 }
01076 
01078 llrp_u8v_t
01079 CXMLTextDecoderStream::get_e8v (
01080   <span class="keyword">const</span> CFieldDescriptor *      pFieldDesc)
01081 {
01082     llrp_u8v_t                  Value;
01083     llrp_s64v_t                 Tmp;
01084 
01085     Tmp = getSpacedVectorField( pFieldDesc, MIN_U8, MAX_U8);
01086     <span class="keywordflow">if</span>(Tmp.m_nValue)
01087     {
01088         llrp_u16_t              nValue;
01089 
01090         nValue = Tmp.m_nValue;
01091         Value = llrp_u8v_t(nValue);
01092         <span class="keywordflow">if</span>(verifyVectorAllocation(Value.m_pValue,pFieldDesc))
01093         {
01094             <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>    Ix;
01095 
01096             <span class="keywordflow">for</span>(Ix = 0; Ix &lt; nValue; Ix++)
01097             {
01098                 Value.m_pValue[Ix] = (llrp_u8_t) Tmp.m_pValue[Ix];
01099             }
01100         }
01101     }
01102     <span class="keywordflow">return</span> Value;
01103 }
01104 
01105 <span class="comment">/* @brief skips a number of reserved bits and discards during the encode/decode process */</span>
01106 <span class="keywordtype">void</span>
01107 CXMLTextDecoderStream::get_reserved (
01108   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>                  nBits)
01109 {
01110     <span class="keywordflow">return</span>;
01111 }
01112 
01113 llrp_bool_t
01114 CXMLTextDecoderStream::verifyVectorAllocation (
01115   <span class="keyword">const</span> <span class="keywordtype">void</span> *                  pValue,
01116   <span class="keyword">const</span> CFieldDescriptor *      pFieldDescriptor)
01117 {
01118     <span class="keywordflow">if</span>(NULL == pValue)
01119     {
01120         CErrorDetails *         pError = &amp;m_pDecoder-&gt;m_ErrorDetails;
01121 
01122         pError-&gt;m_eResultCode = RC_FieldAllocationFailed;
01123         pError-&gt;m_pWhatStr    = <span class="stringliteral">"field allocation failed"</span>;
01124         pError-&gt;m_pRefType    = m_pRefType;
01125         pError-&gt;m_pRefField   = pFieldDescriptor;
01126         pError-&gt;m_OtherDetail = (int) m_pCurrentChildNode-&gt;line;
01127 
01128         <span class="keywordflow">return</span> FALSE;
01129     }
01130     <span class="keywordflow">else</span>
01131     {
01132         <span class="keywordflow">return</span> TRUE;
01133     }
01134 }
01135 
01136 <span class="keywordtype">int</span>
01137 CXMLTextDecoderStream::isInsignificantNode (
01138   <span class="keyword">struct</span> _xmlNode *             pnode)
01139 {
01140     <span class="keywordflow">switch</span>(pnode-&gt;type)
01141     {
01142         <span class="comment">/* don't process comments or notations */</span>
01143         <span class="keywordflow">case</span> XML_COMMENT_NODE:
01144         <span class="keywordflow">case</span> XML_NOTATION_NODE:
01145         <span class="comment">/* ignore includes */</span>
01146         <span class="keywordflow">case</span> XML_XINCLUDE_START:
01147        <span class="keywordflow">case</span> XML_XINCLUDE_END:       
01148        <span class="comment">/* don't read processing instructions */</span>
01149         <span class="keywordflow">case</span> XML_PI_NODE:
01150         <span class="keywordflow">return</span> 1;
01151 
01152         <span class="comment">/* hopefully we only see these type of nodes */</span>
01153         <span class="keywordflow">case</span> XML_ELEMENT_NODE:
01154         <span class="keywordflow">case</span> XML_ATTRIBUTE_NODE:
01155         <span class="keywordflow">case</span> XML_TEXT_NODE:
01156 
01157         <span class="comment">/* we should error if we see a cdata  */</span>
01158         <span class="keywordflow">case</span> XML_CDATA_SECTION_NODE:
01159 
01160         <span class="comment">/* we don't understand entities, so we should error */</span>
01161         <span class="keywordflow">case</span> XML_ENTITY_REF_NODE:
01162         <span class="keywordflow">case</span> XML_ENTITY_NODE:
01163         <span class="keywordflow">case</span> XML_ENTITY_DECL:
01164 
01165         <span class="comment">/* we should have already gotten the doc node , but should error out on these*/</span>
01166         <span class="keywordflow">case</span> XML_DOCUMENT_NODE:
01167         <span class="keywordflow">case</span> XML_DOCUMENT_TYPE_NODE:
01168         <span class="keywordflow">case</span> XML_DOCUMENT_FRAG_NODE:
01169         <span class="keywordflow">case</span> XML_HTML_DOCUMENT_NODE:
01170         <span class="keywordflow">case</span> XML_DTD_NODE:
01171 
01172         <span class="comment">/* not sure yet about these, but I think they are irellevant */</span>
01173         <span class="keywordflow">case</span> XML_ELEMENT_DECL:
01174         <span class="keywordflow">case</span> XML_ATTRIBUTE_DECL:
01175         <span class="keywordflow">case</span> XML_NAMESPACE_DECL:
01176 
01177         <span class="comment">/* anything new we should error */</span>
01178         <span class="keywordflow">default</span>:
01179             <span class="keywordflow">return</span> 0;
01180     }
01181 }
01182 
01183 <span class="comment">/* some class member field helpers */</span>
01184 <span class="keywordtype">int</span> 
01185 CXMLTextDecoderStream::getFieldStringPtr(
01186   <span class="keyword">const</span> CFieldDescriptor *      pFieldDescriptor,
01187   <span class="keyword">const</span> llrp_u8_t **            pbuf,
01188   <span class="keyword">const</span> llrp_u8_t **            pend)
01189 {
01190     CErrorDetails *             pError = &amp;m_pDecoder-&gt;m_ErrorDetails;
01191     xmlNode *                   pSave;
01192 
01193     *pbuf = NULL;
01194     *pend = NULL;
01195 
01196     <span class="comment">/* clear this out as its not valid anymore */</span>
01197     m_pLastFieldNode = NULL;
01198 
01199     <span class="keywordflow">if</span>(<a class="code" href="namespaceLLRP.html#a333a251">RC_OK</a> != pError-&gt;m_eResultCode)
01200     {
01201         <span class="keywordflow">return</span> 0;
01202     }
01203 
01204    <span class="comment">/* get the first interesting node */</span>
01205     <span class="keywordflow">while</span> ((NULL != m_pCurrentChildNode) &amp;&amp;
01206            (isInsignificantNode(m_pCurrentChildNode) || 
01207             xmlIsBlankNode(m_pCurrentChildNode)))
01208     {
01209         m_pCurrentChildNode = m_pCurrentChildNode-&gt;next;
01210     }    
01211 
01212     <span class="keywordflow">if</span>(NULL == m_pCurrentChildNode)
01213     {
01214         pError-&gt;m_eResultCode = RC_FieldUnderrun;
01215         pError-&gt;m_pWhatStr    = <span class="stringliteral">"underrun at field"</span>;
01216         pError-&gt;m_pRefType    = m_pRefType;
01217         pError-&gt;m_pRefField   = pFieldDescriptor;
01218         pError-&gt;m_OtherDetail = (int) m_pCurrentChildNode-&gt;line;
01219         <span class="keywordflow">return</span> 0;
01220     }
01221 
01222     <span class="comment">/* first interesting node had better be an element */</span>
01223     <span class="keywordflow">if</span>(m_pCurrentChildNode-&gt;type != XML_ELEMENT_NODE)
01224     {
01225         pError-&gt;m_eResultCode = RC_XMLInvalidNodeType;
01226         pError-&gt;m_pWhatStr    = <span class="stringliteral">"unexpected field value"</span>;
01227         pError-&gt;m_pRefType    = m_pRefType;
01228         pError-&gt;m_pRefField   = pFieldDescriptor;
01229         pError-&gt;m_OtherDetail = (int) m_pCurrentChildNode-&gt;line;        
01230         <span class="keywordflow">return</span> 0;
01231     }
01232 
01233     <span class="comment">/* better match our field value */</span>
01234     <span class="keywordflow">if</span>(0 != strcmp((<span class="keywordtype">char</span>*) m_pCurrentChildNode-&gt;name, 
01235                     pFieldDescriptor-&gt;m_pName))
01236     {
01237         pError-&gt;m_eResultCode = RC_XMLMissingField;
01238         pError-&gt;m_pWhatStr    = <span class="stringliteral">"missing field value"</span>;
01239         pError-&gt;m_pRefType    = m_pRefType;
01240         pError-&gt;m_pRefField   = pFieldDescriptor;
01241         pError-&gt;m_OtherDetail = (int) m_pCurrentChildNode-&gt;line;        
01242         <span class="keywordflow">return</span> 0;
01243     }
01244 
01245     <span class="comment">/* save this in case someone wants to explore attributes */</span>
01246     m_pLastFieldNode = m_pCurrentChildNode;
01247 
01248     <span class="comment">/* use this to decode the field values */</span>
01249     pSave = m_pCurrentChildNode-&gt;children;
01250 
01251     <span class="comment">/* advance to the next one for the next field */</span>
01252     m_pCurrentChildNode = m_pCurrentChildNode-&gt;next;
01253 
01254    <span class="comment">/* get the first interesting node */</span>
01255     <span class="keywordflow">while</span> ((NULL !=pSave) &amp;&amp;
01256            (isInsignificantNode(pSave) ||
01257          xmlIsBlankNode(pSave)))
01258     {
01259         pSave = pSave-&gt;next;
01260     }    
01261 
01262     <span class="keywordflow">if</span>(NULL == pSave)
01263     {
01264         <span class="comment">/* its possible that this is an empty field value, which is</span>
01265 <span class="comment">         * allowed in many cases in LLRP-XML. Let the condition</span>
01266 <span class="comment">         * percolate and error out specifically where it is not</span>
01267 <span class="comment">         * allowed */</span>
01268         <span class="keywordflow">return</span> 0;   
01269     }
01270 
01271     <span class="keywordflow">if</span>(XML_TEXT_NODE != pSave-&gt;type)
01272     {
01273         pError-&gt;m_eResultCode = RC_XMLInvalidNodeType;
01274         pError-&gt;m_pWhatStr    = <span class="stringliteral">"invalid XML Node found during field decode"</span>;
01275         pError-&gt;m_pRefType    = m_pRefType;
01276         pError-&gt;m_pRefField   = pFieldDescriptor;
01277         pError-&gt;m_OtherDetail = (int) pSave-&gt;line;
01278         <span class="keywordflow">return</span> 0;           
01279     }
01280 
01281     *pbuf = pSave-&gt;content;
01282 
01283     <span class="comment">/* make sure there are no more interesting nodes */</span>
01284     pSave = pSave-&gt;next;
01285     <span class="keywordflow">while</span> ((NULL !=pSave) &amp;&amp;
01286            (isInsignificantNode(pSave) ||
01287             xmlIsBlankNode(pSave)))
01288     {
01289         pSave = pSave-&gt;next;
01290     }   
01291 
01292     <span class="keywordflow">if</span>(pSave != NULL)
01293     {
01294         pError-&gt;m_eResultCode = RC_XMLExtraNode;
01295         pError-&gt;m_pWhatStr    = <span class="stringliteral">"extra XML node found"</span>;
01296         pError-&gt;m_pRefType    = m_pRefType;
01297         pError-&gt;m_pRefField   = pFieldDescriptor;
01298         pError-&gt;m_OtherDetail = (int) pSave-&gt;line;
01299         <span class="keywordflow">return</span> 0;    
01300     }
01301 
01302     *pend = *pbuf + strlen((<span class="keywordtype">char</span>*) *pbuf);
01303     <span class="keywordflow">return</span> 1;
01304 }
01305 
01306 llrp_s64v_t
01307 CXMLTextDecoderStream::getSpacedVectorField (
01308   <span class="keyword">const</span> CFieldDescriptor *      pFieldDescriptor,
01309   llrp_s64_t                    minValue,
01310   llrp_s64_t                    maxValue)
01311 {
01312     CErrorDetails *             pError = &amp;m_pDecoder-&gt;m_ErrorDetails;
01313     <span class="keyword">const</span> llrp_u8_t *           pTok;
01314     <span class="keyword">const</span> llrp_u8_t *           pEnd;    
01315     <span class="keyword">const</span> llrp_u8_t *           pTokEnd;    
01316     llrp_u16_t                  length;
01317     llrp_u16_t                  elementCount;
01318     llrp_s64v_t                 Value;
01319     llrp_u16_t                  count;
01320 
01321     <span class="keywordflow">if</span>(<a class="code" href="namespaceLLRP.html#a333a251">RC_OK</a> != pError-&gt;m_eResultCode)
01322     {
01323     <span class="comment">/* already errd */</span>
01324         <span class="keywordflow">return</span> Value;
01325     }
01326 
01327     <span class="comment">/* get the NULL terminates string from XML */</span>
01328     <span class="keywordflow">if</span>(!getFieldStringPtr(pFieldDescriptor, &amp;pTok, &amp;pEnd))
01329     {
01330       <span class="comment">/* many of these (e.g. ReadData) are allowed to be empty */</span>
01331        <span class="keywordflow">return</span> Value;
01332     }
01333 
01334     length = cleanString(&amp;pTok, &amp;pEnd);
01335     elementCount = countElements((<span class="keywordtype">char</span> *) pTok, length);
01336 
01337     <span class="comment">/* create the final storage entity */</span> 
01338     Value = llrp_s64v_t(elementCount);
01339 
01340     <span class="keywordflow">for</span>(count = 0;count &lt;elementCount ; count++)
01341     {
01342     <span class="comment">/* find the next starting token */</span>
01343         <span class="keywordflow">while</span>(isspace(*pTok) &amp;&amp; (pTok &lt; pEnd))
01344         {
01345             pTok++;
01346         }
01347 
01348         <span class="comment">/* find the next ending token */</span>
01349         <span class="keywordflow">for</span>(pTokEnd = pTok; (!isspace(*pTokEnd)) &amp;&amp; (*pTokEnd != <span class="charliteral">'\0'</span>); pTokEnd++)
01350         {
01351            <span class="comment">/* nothing */</span>
01352         } 
01353 
01354         <span class="comment">/* get a single integer */</span>
01355         Value.m_pValue[count] = getInteger(pFieldDescriptor, 
01356                                            pTok, 
01357                                            pTokEnd, 
01358                                            pError, 
01359                                            minValue, 
01360                                            maxValue);
01361         <span class="keywordflow">if</span>(<a class="code" href="namespaceLLRP.html#a333a251">RC_OK</a> != pError-&gt;m_eResultCode)
01362         {
01363             <span class="keywordflow">break</span>;
01364         }
01365         <span class="comment">/* get the next value */</span>
01366         pTok = pTokEnd;
01367     }
01368 
01369     <span class="comment">/* mark the length */</span>
01370     Value.m_nValue = count;
01371 
01372     <span class="keywordflow">return</span> Value;
01373 }
01374 
01375 llrp_s64v_t
01376 CXMLTextDecoderStream::getFixedVectorField (
01377   <span class="keyword">const</span> CFieldDescriptor *      pFieldDescriptor,
01378   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>                  vectorSize,
01379   llrp_s64_t                    minValue,
01380   llrp_s64_t                    maxValue)
01381 {
01382     CErrorDetails *             pError = &amp;m_pDecoder-&gt;m_ErrorDetails;
01383     <span class="keyword">const</span> llrp_u8_t *           pTok;
01384     <span class="keyword">const</span> llrp_u8_t *           pEnd;    
01385     llrp_u16_t                  length;
01386     llrp_u16_t                  elementCount;
01387     llrp_s64v_t                 Value;
01388     llrp_u16_t                  count;
01389 
01390     <span class="keywordflow">if</span>(<a class="code" href="namespaceLLRP.html#a333a251">RC_OK</a> != pError-&gt;m_eResultCode)
01391     {
01392     <span class="comment">/* already errd */</span>
01393         <span class="keywordflow">return</span> Value;
01394     }
01395 
01396     <span class="keywordflow">if</span>(!getFieldStringPtr(pFieldDescriptor, &amp;pTok, &amp;pEnd))
01397     {
01398         <span class="comment">/* these values are allowed to be empty */</span>
01399         Value.m_nValue = 0;
01400         Value.m_pValue = NULL;
01401         <span class="keywordflow">return</span> Value;
01402     }
01403 
01404     length = cleanString(&amp;pTok, &amp;pEnd);
01405 
01406     <span class="comment">/* size should match exactly */</span>
01407     <span class="keywordflow">if</span> (length % vectorSize)
01408     {
01409         pError-&gt;m_eResultCode = RC_FieldAllocationFailed;
01410         pError-&gt;m_pWhatStr    = <span class="stringliteral">"field size must be multiple of basic type"</span>;
01411         pError-&gt;m_pRefType    = m_pRefType;
01412         pError-&gt;m_pRefField   = pFieldDescriptor;
01413         pError-&gt;m_OtherDetail = (int) m_pCurrentChildNode-&gt;line;
01414         <span class="keywordflow">return</span> Value;
01415     }
01416 
01417     <span class="comment">/* round up for element count */</span>
01418     elementCount = (length +  vectorSize - 1)/vectorSize;
01419 
01420     <span class="comment">/* create the final storage entity */</span> 
01421     Value = llrp_s64v_t(elementCount);
01422 
01423     <span class="keywordflow">for</span>(count = 0;count &lt;elementCount ; count++, pTok += vectorSize)
01424     {
01425         pEnd = pTok + vectorSize;
01426 
01427         <span class="comment">/* get a single integer */</span>
01428         Value.m_pValue[count] = getInteger(pFieldDescriptor, 
01429                                            pTok, 
01430                                            pEnd, 
01431                                            pError, 
01432                                            minValue, 
01433                                            maxValue);
01434 
01435         <span class="keywordflow">if</span>(<a class="code" href="namespaceLLRP.html#a333a251">RC_OK</a> != pError-&gt;m_eResultCode)
01436         {
01437             <span class="keywordflow">break</span>;
01438         }
01439     }
01440 
01441     <span class="comment">/* mark the length */</span>
01442     Value.m_nValue = count;
01443 
01444     <span class="keywordflow">return</span> Value;
01445 }
01446 
01447 
01448 llrp_s64_t
01449 CXMLTextDecoderStream::getIntegerField (
01450   <span class="keyword">const</span> CFieldDescriptor *      pFieldDescriptor,
01451   llrp_s64_t                    minValue,
01452   llrp_s64_t                    maxValue)
01453 {
01454     CErrorDetails *             pError = &amp;m_pDecoder-&gt;m_ErrorDetails;
01455     <span class="keyword">const</span> llrp_u8_t *           pbuf;
01456     <span class="keyword">const</span> llrp_u8_t *           pend;
01457     llrp_s64_t                  Value;
01458 
01459     memset(&amp;Value, 0x00, <span class="keyword">sizeof</span>(Value));
01460 
01461     <span class="keywordflow">if</span>(<a class="code" href="namespaceLLRP.html#a333a251">RC_OK</a> != pError-&gt;m_eResultCode)
01462     {
01463         <span class="comment">/* already errd */</span>
01464         <span class="keywordflow">return</span> Value;
01465     }
01466 
01467     <span class="keywordflow">if</span>(getFieldStringPtr(pFieldDescriptor, &amp;pbuf, &amp;pend))
01468     {
01469         cleanString(&amp;pbuf, &amp;pend);
01470         Value = getInteger(pFieldDescriptor, 
01471                            pbuf, 
01472                            pend, 
01473                            pError, 
01474                            minValue, 
01475                            maxValue);
01476     }
01477     <span class="keywordflow">else</span>
01478     {
01479         pError-&gt;m_eResultCode = RC_FieldUnderrun;
01480         pError-&gt;m_pWhatStr    = <span class="stringliteral">"underrun at field no characters"</span>;
01481         pError-&gt;m_pRefType    = m_pRefType;
01482         pError-&gt;m_pRefField   = pFieldDescriptor;
01483         pError-&gt;m_OtherDetail = (int) m_pCurrentChildNode-&gt;line; 
01484         <span class="keywordflow">return</span> 0;   
01485     }
01486 
01487     <span class="keywordflow">return</span> Value;
01488 }
01489 
01490 
01491 llrp_s64_t CXMLTextDecoderStream::getInteger(
01492   <span class="keyword">const</span> CFieldDescriptor *      pFieldDescriptor,
01493   <span class="keyword">const</span> llrp_u8_t *             pbuf,
01494   <span class="keyword">const</span> llrp_u8_t *             pend,
01495   CErrorDetails *               pError,
01496   llrp_s64_t                    minValue,
01497   llrp_s64_t                    maxValue)
01498 {
01499     llrp_s64_t                  Value;
01500     <span class="keyword">const</span> llrp_u8_t           * endPtr = NULL;
01501 
01502 
01503     <span class="keywordflow">if</span>(pFieldDescriptor-&gt;m_eFieldType == CFieldDescriptor::FT_U1)
01504     <span class="comment">/* special case for U1 types as they can be</span>
01505 <span class="comment">     * 'true' and 'false' strings */</span>
01506     {
01507         endPtr = getSingleU1(pbuf, pend, &amp;Value);
01508     }
01509     <span class="keywordflow">else</span> <span class="keywordflow">if</span>((pFieldDescriptor-&gt;m_eFieldType == CFieldDescriptor::FT_E1 ) || 
01510             (pFieldDescriptor-&gt;m_eFieldType == CFieldDescriptor::FT_E2 ) ||
01511             (pFieldDescriptor-&gt;m_eFieldType == CFieldDescriptor::FT_E8 ) || 
01512             (pFieldDescriptor-&gt;m_eFieldType == CFieldDescriptor::FT_E16 ) || 
01513             (pFieldDescriptor-&gt;m_eFieldType == CFieldDescriptor::FT_E32 ) ||
01514             (pFieldDescriptor-&gt;m_eFieldType == CFieldDescriptor::FT_E8V ) )
01515     <span class="comment">/* special case for enumerated fields as they are strings in XML*/</span>
01516     {
01517         endPtr = getSingleEnum(pFieldDescriptor, pbuf, pend, &amp;Value);  
01518     }
01519     <span class="keywordflow">else</span> <span class="keywordflow">switch</span>(pFieldDescriptor-&gt;m_eFieldFormat)
01520     {
01521         <span class="comment">/* assume default is decimal for new formats */</span>
01522         <span class="keywordflow">default</span>:
01523         <span class="keywordflow">case</span> CFieldDescriptor::FMT_NORMAL:
01524         <span class="keywordflow">case</span> CFieldDescriptor::FMT_DEC:
01525             endPtr = getSingleDecimal(pbuf, pend, &amp;Value);
01526         <span class="keywordflow">break</span>;
01527         <span class="keywordflow">case</span> CFieldDescriptor::FMT_HEX:
01528             endPtr = getSingleHexidecimal(pbuf, pend, &amp;Value);
01529         <span class="keywordflow">break</span>;
01530         <span class="keywordflow">case</span> CFieldDescriptor::FMT_UTF8:
01531         {
01532             <span class="keyword">const</span> llrp_u8_t  *ptr;
01533             <span class="comment">/* not sure what to do for UTF 8 encoding as integer */</span>
01534             <span class="keywordflow">for</span>(ptr = pbuf; ptr &lt; pend; ptr++)
01535             {
01536                 Value = 256*Value + *ptr;
01537             } 
01538         }
01539         <span class="keywordflow">break</span>;
01540         <span class="keywordflow">case</span> CFieldDescriptor::FMT_DATETIME:
01541             endPtr = getSingleTimestamp(pbuf, pend, &amp;Value);
01542         <span class="keywordflow">break</span>;
01543     }    
01544 
01545     <span class="keywordflow">if</span>(endPtr == pbuf)
01546     <span class="comment">/* if we didn't get any thing, it means there are illegal characters</span>
01547 <span class="comment">     * and we could not import a field value */</span>
01548     {
01549         pError-&gt;m_eResultCode = RC_XMLInvalidFieldCharacters;
01550         pError-&gt;m_pWhatStr    = <span class="stringliteral">"Illegal field value"</span>;
01551         pError-&gt;m_pRefType    = m_pRefType;
01552         pError-&gt;m_pRefField   = pFieldDescriptor;
01553         pError-&gt;m_OtherDetail = (int) m_pCurrentChildNode-&gt;line; 
01554         Value = 0;      
01555     }
01556     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (endPtr != pend)
01557     <span class="comment">/* if these don't match, there is still extra stuff</span>
01558 <span class="comment">     * at the end.  This is always an error */</span>
01559     {
01560         pError-&gt;m_eResultCode = RC_FieldOverrun;
01561         pError-&gt;m_pWhatStr    = <span class="stringliteral">"overrun at field extra characters"</span>;
01562         pError-&gt;m_pRefType    = m_pRefType;
01563         pError-&gt;m_pRefField   = pFieldDescriptor;
01564         pError-&gt;m_OtherDetail = (int) m_pCurrentChildNode-&gt;line;
01565         Value = 0;      
01566     }
01567     <span class="comment">/* make sure the value is in range */</span> 
01568     <span class="keywordflow">else</span> <span class="keywordflow">if</span>((Value &gt; maxValue) || (Value &lt; minValue))
01569     <span class="comment">/* we have an out of range value. This is always an error */</span>
01570     {
01571         pError-&gt;m_eResultCode = RC_XMLOutOfRange;
01572         pError-&gt;m_pWhatStr    = <span class="stringliteral">"out of range value"</span>;
01573         pError-&gt;m_pRefType    = m_pRefType;
01574         pError-&gt;m_pRefField   = pFieldDescriptor;
01575         pError-&gt;m_OtherDetail = (int) m_pCurrentChildNode-&gt;line;
01576         Value = 0;
01577     }    
01578     <span class="keywordflow">return</span> Value;
01579 }
01580 
01581 <span class="comment">/* static string helpers */</span>
01582 
01583 <span class="keyword">const</span> llrp_u8_t *
01584 CXMLTextDecoderStream::getSingleU1(
01585   <span class="keyword">const</span> llrp_u8_t *             pbuf,
01586   <span class="keyword">const</span> llrp_u8_t *             pend,
01587   llrp_s64_t *                  pValue)
01588 {
01589     <span class="keyword">const</span> llrp_u8_t *           endPtr = pbuf;
01590     <span class="keyword">const</span> <span class="keywordtype">int</span>                   len = (int) (pend - pbuf);
01591 
01592     <span class="keywordflow">if</span>((len &gt;= 4) &amp;&amp; (0 == strncasecmp(<span class="stringliteral">"true"</span>, (<span class="keywordtype">char</span>*) pbuf, 4)))
01593     {
01594         *pValue = 1;
01595         endPtr = pbuf + 4; 
01596     }
01597     <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((len &gt;= 5) &amp;&amp; (0 == strncasecmp(<span class="stringliteral">"false"</span>, (<span class="keywordtype">char</span>*) pbuf, 5)))
01598     {
01599         *pValue = 0;
01600         endPtr = pbuf + 5; 
01601     } 
01602     <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((len &gt;= 1) &amp;&amp; (*pbuf == <span class="charliteral">'0'</span>))
01603     {
01604         *pValue = 0;
01605         endPtr = pbuf + 1;
01606     }
01607     <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((len &gt;= 1) &amp;&amp; (*pbuf == <span class="charliteral">'1'</span>))
01608     {
01609         *pValue = 0;
01610         endPtr = pbuf + 1;
01611     }
01612     <span class="keywordflow">return</span> endPtr;  
01613 }
01614 
01615 <span class="keyword">const</span> llrp_u8_t *
01616 CXMLTextDecoderStream::getSingleEnum(
01617   <span class="keyword">const</span> CFieldDescriptor *      pFieldDescriptor,
01618   <span class="keyword">const</span> llrp_u8_t *             pbuf,
01619   <span class="keyword">const</span> llrp_u8_t *             pend,
01620   llrp_s64_t *                  pValue)
01621 {
01622     <span class="keyword">const</span> llrp_u8_t *           endPtr = pbuf;
01623     <span class="keyword">const</span> <span class="keywordtype">int</span>                   length = (int) (pend - pbuf);
01624     <span class="keyword">const</span> SEnumTableEntry *     pEntry;    
01625 
01626     *pValue = 0;
01627 
01628     <span class="keywordflow">for</span>(
01629         pEntry = pFieldDescriptor-&gt;m_pEnumTable;
01630         NULL != pEntry-&gt;pName;
01631         pEntry++)
01632     {
01633         <span class="keywordtype">int</span> len = (int) strlen(pEntry-&gt;pName);
01634         <span class="keywordflow">if</span>((len == length) &amp;&amp; 
01635            (memcmp(pbuf, pEntry-&gt;pName, len) == 0))
01636         {
01637             <span class="keywordflow">break</span>;
01638         }
01639     }
01640 
01641     <span class="keywordflow">if</span>(NULL == pEntry-&gt;pName)
01642     {
01643         <span class="keywordflow">return</span> pbuf;
01644     }
01645    
01646     *pValue = pEntry-&gt;Value;
01647     endPtr = pbuf + length;     
01648     <span class="keywordflow">return</span> endPtr;
01649 }
01650 
01651 <span class="keyword">const</span> llrp_u8_t *
01652 CXMLTextDecoderStream::getSingleDecimal(
01653   <span class="keyword">const</span> llrp_u8_t *             pbuf,
01654   <span class="keyword">const</span> llrp_u8_t *             pend,
01655   llrp_s64_t *                  pValue)
01656 {
01657     <span class="keywordtype">int</span> bNeg = 0;
01658     <span class="keyword">const</span> llrp_u8_t *           endPtr;
01659 
01660     *pValue = 0;
01661 
01662     <span class="keywordflow">for</span>(endPtr = pbuf; endPtr &lt; pend; endPtr++)
01663     {
01664         <span class="keywordflow">if</span>(*endPtr == <span class="charliteral">'-'</span>)
01665         {
01666            bNeg = 1;
01667         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (isdigit(*endPtr))
01668         {
01669            *pValue = 10 * *pValue + (*endPtr - <span class="charliteral">'0'</span>);
01670         }
01671         <span class="keywordflow">else</span>
01672         {
01673            <span class="comment">/* a character not allowed in a decimal integer */</span>
01674            <span class="keywordflow">break</span>;        
01675         }
01676     }
01677     <span class="keywordflow">if</span>(bNeg)
01678     {
01679         *pValue *= -1;
01680     }
01681 
01682     <span class="keywordflow">return</span> endPtr;
01683 }
01684 
01685 
01686 <span class="keyword">const</span> llrp_u8_t *
01687 CXMLTextDecoderStream::getSingleHexidecimal(
01688   <span class="keyword">const</span> llrp_u8_t *             pbuf,
01689   <span class="keyword">const</span> llrp_u8_t *             pend,
01690   llrp_s64_t *                  pValue)
01691 {
01692     <span class="keyword">const</span> llrp_u8_t *           endPtr;
01693 
01694     *pValue = 0;
01695     <span class="keywordflow">for</span>(endPtr = pbuf; endPtr &lt; pend; endPtr++)
01696     {
01697         <span class="keywordflow">if</span>(isdigit(*endPtr))
01698         {
01699            *pValue = 16 * *pValue + (*endPtr - <span class="charliteral">'0'</span>);
01700         }
01701         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (*endPtr &gt;= <span class="charliteral">'A'</span> &amp;&amp; *endPtr &lt;= <span class="charliteral">'F'</span>)
01702         {
01703             *pValue = 16 * *pValue + (*endPtr - <span class="charliteral">'A'</span> + 10);
01704         }
01705         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (*endPtr &gt;= <span class="charliteral">'a'</span> &amp;&amp; *endPtr &lt;= <span class="charliteral">'f'</span>)
01706         {
01707             *pValue = 16 * *pValue + (*endPtr - <span class="charliteral">'a'</span> + 10);
01708         }
01709         <span class="keywordflow">else</span> 
01710         {
01711            <span class="comment">/* a character not allowed in a decimal integer */</span>
01712            <span class="keywordflow">break</span>;         
01713         }
01714     }
01715     <span class="keywordflow">return</span> endPtr;
01716 }
01717 
01718 
01719 <span class="keywordtype">int</span>
01720 CXMLTextDecoderStream::cleanString(
01721   <span class="keyword">const</span> llrp_u8_t **            ppbuf,
01722   <span class="keyword">const</span> llrp_u8_t **            ppend)
01723 {
01724     <span class="comment">/* skip leading spaces */</span>
01725     <span class="keywordflow">while</span>( isspace(**ppbuf) &amp;&amp; (*ppbuf &lt;= *ppend))
01726     {
01727       (*ppbuf)++;
01728     }
01729     <span class="comment">/* skip trailing spaces except last separator */</span>
01730     <span class="comment">/* last separator could be space or NULL. */</span>
01731     <span class="keywordflow">while</span>((*ppend &gt; *ppbuf) &amp;&amp; (isspace(*(*ppend-1)) || (*(*ppend-1) == <span class="charliteral">'\0'</span>)))
01732     {
01733        (*ppend)--;
01734     }
01735     <span class="keywordflow">return</span> (int) (*ppend - *ppbuf);
01736 }
01737 
01738 
01739 <span class="keyword">const</span> llrp_u8_t *
01740 CXMLTextDecoderStream::getSingleTimestamp(
01741   <span class="keyword">const</span> llrp_u8_t *             pbuf,
01742   <span class="keyword">const</span> llrp_u8_t *             pend,
01743   llrp_s64_t *                  pValue)
01744 {
01745     <span class="keyword">const</span> llrp_u8_t *           endPtr;
01746     <span class="keyword">struct </span>tm importTime;
01747     llrp_s64_t micros = 0;
01748     <span class="keyword">const</span> llrp_u8_t *pMicro;
01749 
01750     memset(&amp;importTime, 0x00, <span class="keyword">sizeof</span>(importTime));
01751 
01752     endPtr = (llrp_u8_t*) strptime((<span class="keywordtype">char</span>*) pbuf, <span class="stringliteral">"%Y-%m-%dT%T"</span>, &amp;importTime);
01753     <span class="comment">/* are there microseconds */</span>
01754     <span class="keywordflow">if</span>(endPtr != NULL)
01755     {
01756         <span class="comment">/* convert time time_t */</span>
01757         time_t tt;
01758            
01759         <span class="comment">/* There may or may not be microseconds. Live with either */</span>
01760         <span class="keywordflow">if</span>(*endPtr == <span class="charliteral">'.'</span>)
01761         {
01762             <span class="keywordtype">int</span> length;
01763             pMicro = endPtr + 1;
01764             length = (int) (pend - pMicro);
01765             endPtr = getSingleDecimal(pMicro, pend, &amp;micros);
01766 
01767             <span class="comment">/* may not contain 6 decimal places */</span>
01768             <span class="keywordflow">while</span>(length &lt; 6)
01769             {
01770                     micros *= 10;
01771             length++;
01772             }
01773         }
01774 
01775         <span class="comment">/* make this into time since epoch at GMT (UTC) */</span>
01776         tt = timegm(&amp;importTime);
01777         <span class="keywordflow">if</span>(tt != (time_t) -1)
01778         {
01779             <span class="comment">/* LLRP format is 64-bit microseconds. Conver  */</span>
01780             *pValue = 1000000ll * (llrp_s64_t) tt + micros;
01781         }
01782         <span class="keywordflow">else</span>
01783         {
01784             <span class="comment">/* catch the error later. We cannot import time */</span>
01785             endPtr = pbuf;
01786         }
01787     }
01788     <span class="keywordflow">else</span>
01789     {
01790         endPtr = pbuf;
01791     }
01792     <span class="keywordflow">return</span> endPtr;
01793 }
01794 
01795 
01796 llrp_u16_t 
01797 CXMLTextDecoderStream::countElements(
01798   <span class="keyword">const</span> <span class="keywordtype">char</span> *                  pval, 
01799   <span class="keywordtype">int</span>                           nval)
01800 {
01801     <span class="keyword">const</span> llrp_u8_t *           pTok;
01802     <span class="keyword">const</span> llrp_u8_t *           pEnd;
01803     llrp_u8_t                   lastChar;
01804     llrp_u16_t                  elements = 0;
01805 
01806     <span class="comment">/* find out how many possible tokens there are.</span>
01807 <span class="comment">     * This should limit our size of array we need */</span>
01808 
01809     pTok = (llrp_u8_t*) &amp;pval[0];
01810     pEnd = pTok + nval;
01811 
01812     <span class="comment">/* skip leading spaces */</span>
01813     <span class="keywordflow">for</span>(lastChar = <span class="charliteral">' '</span>; pTok &lt; pEnd; pTok++)
01814     {
01815         <span class="keywordflow">if</span>((!isspace(*pTok)) &amp;&amp; (isspace(lastChar)))
01816         {
01817             elements++;
01818         }
01819         lastChar = *pTok;
01820     } 
01821 
01822     <span class="keywordflow">return</span> elements;
01823 }
01824 
01825 };
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Wed Feb 24 09:16:21 2010 for LTKCPP-- LLRP Toolkit C Plus Plus Library by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.3.9.1 </small></address>
</body>
</html>
