<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>LTKCPP-- LLRP Toolkit C Plus Plus Library: ltkcpp_connection.cpp Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.9.1 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="namespacemembers.html">Namespace&nbsp;Members</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a></div>
<div class="nav">
<a class="el" href="dir_000002.html">Library</a></div>
<h1>ltkcpp_connection.cpp</h1><a href="ltkcpp__connection_8cpp.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment">00001 
00002 <span class="comment">/*</span>
00003 <span class="comment"> ***************************************************************************</span>
00004 <span class="comment"> *  Copyright 2007,2008 Impinj, Inc.</span>
00005 <span class="comment"> *</span>
00006 <span class="comment"> *  Licensed under the Apache License, Version 2.0 (the "License");</span>
00007 <span class="comment"> *  you may not use this file except in compliance with the License.</span>
00008 <span class="comment"> *  You may obtain a copy of the License at</span>
00009 <span class="comment"> *</span>
00010 <span class="comment"> *      http://www.apache.org/licenses/LICENSE-2.0</span>
00011 <span class="comment"> *</span>
00012 <span class="comment"> *  Unless required by applicable law or agreed to in writing, software</span>
00013 <span class="comment"> *  distributed under the License is distributed on an "AS IS" BASIS,</span>
00014 <span class="comment"> *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
00015 <span class="comment"> *  See the License for the specific language governing permissions and</span>
00016 <span class="comment"> *  limitations under the License.</span>
00017 <span class="comment"> *</span>
00018 <span class="comment"> ***************************************************************************</span>
00019 <span class="comment"> */</span>
00020 
00039 <span class="preprocessor">#include &lt;assert.h&gt;</span>
00040 
00041 
00042 <span class="preprocessor">#ifdef linux</span>
00043 <span class="preprocessor"></span><span class="preprocessor">#include &lt;poll.h&gt;</span>
00044 <span class="preprocessor">#include &lt;unistd.h&gt;</span>
00045 <span class="preprocessor">#include &lt;errno.h&gt;</span>
00046 <span class="preprocessor">#include &lt;sys/types.h&gt;</span>
00047 <span class="preprocessor">#include &lt;sys/socket.h&gt;</span>
00048 <span class="preprocessor">#include &lt;netinet/in.h&gt;</span>
00049 <span class="preprocessor">#include &lt;netinet/tcp.h&gt;</span>
00050 <span class="preprocessor">#include &lt;arpa/inet.h&gt;</span>
00051 <span class="preprocessor">#include &lt;unistd.h&gt;</span>
00052 <span class="preprocessor">#include &lt;netdb.h&gt;</span>
00053 <span class="preprocessor">#include &lt;fcntl.h&gt;</span>
00054 <span class="preprocessor">#include &lt;time.h&gt;</span>
00055 <span class="preprocessor">#endif</span>
00056 <span class="preprocessor"></span><span class="preprocessor">#ifdef WIN32</span>
00057 <span class="preprocessor"></span><span class="preprocessor">#define WIN32_LEAN_AND_MEAN</span>
00058 <span class="preprocessor"></span><span class="preprocessor">#include &lt;windows.h&gt;</span>
00059 <span class="preprocessor">#include &lt;winsock2.h&gt;</span>
00060 <span class="preprocessor">#include &lt;ws2tcpip.h&gt;</span>
00061 <span class="preprocessor">#include &lt;time.h&gt;</span>
00062 <span class="preprocessor">#endif</span>
00063 <span class="preprocessor"></span>
00064 <span class="preprocessor">#include "<a class="code" href="ltkcpp__platform_8h.html">ltkcpp_platform.h</a>"</span>
00065 <span class="preprocessor">#include "<a class="code" href="ltkcpp__base_8h.html">ltkcpp_base.h</a>"</span>
00066 <span class="preprocessor">#include "<a class="code" href="ltkcpp__frame_8h.html">ltkcpp_frame.h</a>"</span>
00067 <span class="preprocessor">#include "<a class="code" href="ltkcpp__connection_8h.html">ltkcpp_connection.h</a>"</span>
00068 
00069 
00070 <span class="preprocessor">#define LLRP1_TCP_PORT   (5084u)</span>
00071 <span class="preprocessor"></span>
00072 
00073 <span class="keyword">namespace </span>LLRP
00074 {
00075 
00076 <span class="comment">/*</span>
00077 <span class="comment"> * On Linux a socket is a simple type (int). On Windows it</span>
00078 <span class="comment"> * is a pointer to a specific type defined in a WinSock</span>
00079 <span class="comment"> * header (.h) file. Rather than make that header file a</span>
00080 <span class="comment"> * prerequisite to every source file that includes this header</span>
00081 <span class="comment"> * file (ltkcpp_connection.h), the following CPlatformSocket</span>
00082 <span class="comment"> * class opaquely wraps the platform-specific socket.</span>
00083 <span class="comment"> *</span>
00084 <span class="comment"> * The CConnection class references it by pointer only.</span>
00085 <span class="comment"> * The content of the CPlatformSocket is only known</span>
00086 <span class="comment"> * within the implementation of CConnection.</span>
00087 <span class="comment"> */</span>
00088 <span class="preprocessor">#ifdef linux</span>
00089 <span class="preprocessor"></span><span class="keyword">class </span>CPlatformSocket
00090 {
00091   <span class="keyword">public</span>:
00092     <span class="keywordtype">int</span>                         m_sock;
00093 
00094     CPlatformSocket(<span class="keywordtype">int</span> sock);
00095 };
00096 
00097 CPlatformSocket::CPlatformSocket (<span class="keywordtype">int</span> sock)
00098 {
00099     m_sock = sock;
00100 }
00101 
00102 <span class="preprocessor">#endif</span>
00103 <span class="preprocessor"></span><span class="preprocessor">#ifdef WIN32</span>
00104 <span class="preprocessor"></span><span class="keyword">class </span>CPlatformSocket
00105 {
00106   <span class="keyword">public</span>:
00107     SOCKET                      m_sock;
00108 
00109     CPlatformSocket(SOCKET sock);
00110 };
00111 
00112 CPlatformSocket::CPlatformSocket (SOCKET sock)
00113 {
00114     m_sock = sock;
00115 }
00116 
00117 <span class="preprocessor">#endif</span>
00118 <span class="preprocessor"></span>
00119 
<a name="l00138"></a><a class="code" href="classLLRP_1_1CConnection.html#a0">00138</a> CConnection::CConnection (
00139   <span class="keyword">const</span> <a class="code" href="classLLRP_1_1CTypeRegistry.html">CTypeRegistry</a> *         pTypeRegistry,
00140   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>                  nBufferSize)
00141 {
00142     <span class="comment">/*</span>
00143 <span class="comment">     * Apply default buffer size</span>
00144 <span class="comment">     */</span>
00145     <span class="keywordflow">if</span>(0 == nBufferSize)
00146     {
00147         nBufferSize = 128u*1024u;
00148     }
00149 
00150     <span class="comment">/*</span>
00151 <span class="comment">     * Make sure the buffer size is sane. This is arbitrary.</span>
00152 <span class="comment">     * The smallest message is 10 bytes, but it ain't anything</span>
00153 <span class="comment">     * useful. 1024u covers a surprising number of messages.</span>
00154 <span class="comment">     */</span>
00155     <span class="keywordflow">if</span>(1024u &gt; nBufferSize || 1u*1024u*1024u &lt; nBufferSize)
00156     {
00157         <span class="keywordflow">throw</span> <span class="stringliteral">"Insane buffer size"</span>;
00158     }
00159 
00160     <span class="comment">/*</span>
00161 <span class="comment">     * Capture variables. m_pPlatformSocket=NULL indicates there</span>
00162 <span class="comment">     * is no connection yet.</span>
00163 <span class="comment">     */</span>
00164     m_pPlatformSocket = NULL;
00165     m_pTypeRegistry = pTypeRegistry;
00166     m_nBufferSize = nBufferSize;
00167 
00168     memset(&amp;m_Recv, 0, <span class="keyword">sizeof</span> m_Recv);
00169     memset(&amp;m_Send, 0, <span class="keyword">sizeof</span> m_Send);
00170 
00171     <span class="comment">/*</span>
00172 <span class="comment">     * Allocate and check each the recv and send buffers.</span>
00173 <span class="comment">     */</span>
00174     m_Recv.pBuffer = <span class="keyword">new</span> llrp_byte_t[nBufferSize];
00175     m_Send.pBuffer = <span class="keyword">new</span> llrp_byte_t[nBufferSize];
00176 
00177     <span class="comment">/*</span>
00178 <span class="comment">     * Zero-fill buffers just so debugger printing is tidy</span>
00179 <span class="comment">     */</span>
00180     memset(m_Recv.pBuffer, 0, nBufferSize);
00181     memset(m_Send.pBuffer, 0, nBufferSize);
00182 
00183 <span class="preprocessor">#ifdef WIN32</span>
00184 <span class="preprocessor"></span>    <span class="comment">/*</span>
00185 <span class="comment">     * On Windows have to enable the WinSock library</span>
00186 <span class="comment">     */</span>
00187     {
00188         WSADATA SocketLibraryInitData;
00189         WSAStartup(0xFFFF, &amp;SocketLibraryInitData);
00190     }
00191 <span class="preprocessor">#endif</span>
00192 <span class="preprocessor"></span>
00193     <span class="comment">/*</span>
00194 <span class="comment">     * Victory</span>
00195 <span class="comment">     */</span>
00196 }
00197 
00198 
<a name="l00206"></a><a class="code" href="classLLRP_1_1CConnection.html#a1">00206</a> CConnection::~CConnection (<span class="keywordtype">void</span>)
00207 {
00208     <span class="comment">/*</span>
00209 <span class="comment">     * Close the connection, if one</span>
00210 <span class="comment">     */</span>
00211     <a class="code" href="classLLRP_1_1CConnection.html#a4">closeConnectionToReader</a>();
00212 
00213     <span class="comment">/*</span>
00214 <span class="comment">     * Destruct any messages on the input queue</span>
00215 <span class="comment">     */</span>
00216     <span class="keywordflow">for</span> (
00217         std::list&lt;CMessage *&gt;::iterator msg = m_listInputQueue.begin();
00218         msg != m_listInputQueue.end();
00219         msg++)
00220     {
00221         <span class="keyword">delete</span> *msg;
00222     }
00223 
00224     <span class="comment">/*</span>
00225 <span class="comment">     * free each the receive and send bufers</span>
00226 <span class="comment">     */</span>
00227     <span class="keyword">delete</span>[] m_Recv.pBuffer;
00228     <span class="keyword">delete</span>[] m_Send.pBuffer;
00229 
00230 <span class="preprocessor">#ifdef WIN32</span>
00231 <span class="preprocessor"></span>    <span class="comment">/*</span>
00232 <span class="comment">     * On Windows have to disable (dereference) the WinSock library</span>
00233 <span class="comment">     */</span>
00234     {
00235         WSACleanup();
00236     }
00237 <span class="preprocessor">#endif</span>
00238 <span class="preprocessor"></span>
00239 }
00240 
00241 
00260 <span class="keywordtype">int</span>
<a name="l00261"></a><a class="code" href="classLLRP_1_1CConnection.html#a2">00261</a> CConnection::openConnectionToReader (
00262   <span class="keyword">const</span> <span class="keywordtype">char</span> *                  pReaderHostName)
00263 {
00264 <span class="preprocessor">#ifdef linux</span>
00265 <span class="preprocessor"></span>    <span class="keywordtype">int</span>                         Sock;
00266 <span class="preprocessor">#endif</span>
00267 <span class="preprocessor"></span><span class="preprocessor">#ifdef WIN32</span>
00268 <span class="preprocessor"></span>    SOCKET                      Sock;
00269 <span class="preprocessor">#endif</span>
00270 <span class="preprocessor"></span>    <span class="keyword">struct </span>addrinfo             aiHints;
00271     <span class="keyword">struct </span>addrinfo *           aiList;
00272     <span class="keywordtype">int</span>                         Flag;
00273     <span class="keyword">struct </span>sockaddr_in          Sin;
00274     <span class="keywordtype">int</span>                         rc;
00275 
00276     <span class="comment">/*</span>
00277 <span class="comment">     * Clear the connect error string</span>
00278 <span class="comment">     */</span>
00279     m_pConnectErrorStr = NULL;
00280 
00281     <span class="comment">/*</span>
00282 <span class="comment">     * Make sure there isn't already a connection.</span>
00283 <span class="comment">     */</span>
00284     <span class="keywordflow">if</span>(NULL != m_pPlatformSocket)
00285     {
00286         m_pConnectErrorStr = <span class="stringliteral">"already connected"</span>;
00287         <span class="keywordflow">return</span> -1;
00288     }
00289 
00290     <span class="comment">/*</span>
00291 <span class="comment">     * Look up host using getaddrinfo().</span>
00292 <span class="comment">     * This could be configured a lot of different ways.</span>
00293 <span class="comment">     * There is /etc/hosts, DNS, NIS, etc, etc.</span>
00294 <span class="comment">     * Suffice to say it is big, bulky, and susceptible to stall.</span>
00295 <span class="comment">     */</span>
00296     memset(&amp;aiHints, 0, <span class="keyword">sizeof</span>(aiHints));
00297     aiHints.ai_family = AF_INET;
00298     aiList = NULL;
00299 
00300     rc = getaddrinfo(pReaderHostName, NULL, &amp;aiHints, &amp;aiList);
00301     <span class="keywordflow">if</span>(0 != rc)
00302     {
00303         m_pConnectErrorStr = <span class="stringliteral">"host lookup failed"</span>;
00304         <span class="keywordflow">return</span> -1;
00305     }
00306 
00307     <span class="comment">/*</span>
00308 <span class="comment">     * Convert the address to sockaddr_in format</span>
00309 <span class="comment">     */</span>
00310     memset(&amp;Sin, 0, <span class="keyword">sizeof</span> Sin);
00311     Sin.sin_family = AF_INET;
00312     Sin.sin_addr = ((<span class="keyword">struct </span>sockaddr_in *)(aiList-&gt;ai_addr))-&gt;sin_addr;
00313     Sin.sin_port = htons(LLRP1_TCP_PORT);
00314 
00315     <span class="comment">/*</span>
00316 <span class="comment">     * Done withe the host addrinfo</span>
00317 <span class="comment">     */</span>
00318     freeaddrinfo(aiList);
00319 
00320     <span class="comment">/*</span>
00321 <span class="comment">     * Create the socket.</span>
00322 <span class="comment">     */</span>
00323     Sock = socket(AF_INET, SOCK_STREAM, 0);
00324 <span class="preprocessor">#ifdef linux</span>
00325 <span class="preprocessor"></span>    <span class="keywordflow">if</span>(0 &gt; Sock)
00326 <span class="preprocessor">#endif </span><span class="comment">/* linux */</span>
00327 <span class="preprocessor">#ifdef WIN32</span>
00328 <span class="preprocessor"></span>    <span class="keywordflow">if</span>(NULL == Sock)
00329 <span class="preprocessor">#endif </span><span class="comment">/* WIN32 */</span>
00330     {
00331         m_pConnectErrorStr = <span class="stringliteral">"socket() failed"</span>;
00332         <span class="keywordflow">return</span> -3;
00333     }
00334 
00335     <span class="comment">/*</span>
00336 <span class="comment">     * Connect the socket to reader. This can stall.</span>
00337 <span class="comment">     */</span>
00338     rc = connect(Sock, (<span class="keyword">struct</span> sockaddr *)&amp;Sin, <span class="keyword">sizeof</span> Sin);
00339     <span class="keywordflow">if</span>(0 &gt; rc)
00340     {
00341         <span class="comment">/* Connect failed */</span>
00342         m_pConnectErrorStr = <span class="stringliteral">"connection failed"</span>;
00343 <span class="preprocessor">#ifdef linux</span>
00344 <span class="preprocessor"></span>        close(Sock);
00345 <span class="preprocessor">#endif</span>
00346 <span class="preprocessor"></span><span class="preprocessor">#ifdef WIN32</span>
00347 <span class="preprocessor"></span>        closesocket(Sock);
00348 <span class="preprocessor">#endif</span>
00349 <span class="preprocessor"></span>        <span class="keywordflow">return</span> -4;
00350     }
00351 
00352     <span class="comment">/*</span>
00353 <span class="comment">     * Best effort to set no delay. If this doesn't work</span>
00354 <span class="comment">     * (no reason it shouldn't) we do not declare defeat.</span>
00355 <span class="comment">     */</span>
00356     Flag = 1;
00357 
00358 <span class="preprocessor">#ifdef linux</span>
00359 <span class="preprocessor"></span>    setsockopt(Sock, IPPROTO_TCP, TCP_NODELAY, (<span class="keywordtype">void</span>*)&amp;Flag, <span class="keyword">sizeof</span> Flag);
00360 <span class="preprocessor">#endif</span>
00361 <span class="preprocessor"></span><span class="preprocessor">#ifdef WIN32</span>
00362 <span class="preprocessor"></span>    setsockopt(Sock, IPPROTO_TCP, TCP_NODELAY, (<span class="keywordtype">char</span>*)&amp;Flag, <span class="keyword">sizeof</span> Flag);
00363 <span class="preprocessor">#endif</span>
00364 <span class="preprocessor"></span>
00365     <span class="comment">/*</span>
00366 <span class="comment">     * Wrap the platform-specific socket in the platform-specific class.</span>
00367 <span class="comment">     */</span>
00368     m_pPlatformSocket = <span class="keyword">new</span> CPlatformSocket(Sock);
00369 
00370     <span class="comment">/*</span>
00371 <span class="comment">     * Victory</span>
00372 <span class="comment">     */</span>
00373     <span class="keywordflow">return</span> 0;
00374 }
00375 
00376 
00387 <span class="keyword">const</span> <span class="keywordtype">char</span> *
<a name="l00388"></a><a class="code" href="classLLRP_1_1CConnection.html#a3">00388</a> CConnection::getConnectError (<span class="keywordtype">void</span>)
00389 {
00390     <span class="keywordflow">return</span> m_pConnectErrorStr;
00391 }
00392 
00393 
00404 <span class="keywordtype">int</span>
<a name="l00405"></a><a class="code" href="classLLRP_1_1CConnection.html#a4">00405</a> CConnection::closeConnectionToReader (<span class="keywordtype">void</span>)
00406 {
00407     <span class="keywordflow">if</span>(NULL == m_pPlatformSocket)
00408     {
00409         m_pConnectErrorStr = <span class="stringliteral">"not connected"</span>;
00410         <span class="keywordflow">return</span> -1;
00411     }
00412 
00413 <span class="preprocessor">#ifdef linux</span>
00414 <span class="preprocessor"></span>    shutdown(m_pPlatformSocket-&gt;m_sock, SHUT_RDWR);
00415     close(m_pPlatformSocket-&gt;m_sock);
00416     m_pPlatformSocket-&gt;m_sock = -1;
00417 <span class="preprocessor">#endif</span>
00418 <span class="preprocessor"></span><span class="preprocessor">#ifdef WIN32</span>
00419 <span class="preprocessor"></span>    closesocket(m_pPlatformSocket-&gt;m_sock);
00420     m_pPlatformSocket-&gt;m_sock = NULL;
00421 <span class="preprocessor">#endif</span>
00422 <span class="preprocessor"></span>
00423     <span class="keyword">delete</span> m_pPlatformSocket;
00424     m_pPlatformSocket = NULL;
00425     <span class="keywordflow">return</span> 0;
00426 }
00427 
00428 
00451 <a class="code" href="classLLRP_1_1CMessage.html">CMessage</a> *
<a name="l00452"></a><a class="code" href="classLLRP_1_1CConnection.html#a5">00452</a> CConnection::transact (
00453   <a class="code" href="classLLRP_1_1CMessage.html">CMessage</a> *                    pSendMessage,
00454   <span class="keywordtype">int</span>                           nMaxMS)
00455 {
00456     <span class="keyword">const</span> <a class="code" href="classLLRP_1_1CTypeDescriptor.html">CTypeDescriptor</a> *     pResponseType;
00457     <a class="code" href="namespaceLLRP.html#a333">EResultCode</a>                 lrc;
00458     <a class="code" href="classLLRP_1_1CMessage.html">CMessage</a> *                  pResponseMessage;
00459 
00460     <span class="comment">/*</span>
00461 <span class="comment">     * Determine the response type. The type descriptor</span>
00462 <span class="comment">     * of the outgoing request message points to the</span>
00463 <span class="comment">     * type descriptor of the response. Since we are</span>
00464 <span class="comment">     * totally dependent upon it, fail if there</span>
00465 <span class="comment">     * is no response type pointer value.</span>
00466 <span class="comment">     */</span>
00467     pResponseType = pSendMessage-&gt;<a class="code" href="classLLRP_1_1CElement.html#o0">m_pType</a>-&gt;<a class="code" href="classLLRP_1_1CTypeDescriptor.html#o5">m_pResponseType</a>;
00468     <span class="keywordflow">if</span>(NULL == pResponseType)
00469     {
00470         <a class="code" href="classLLRP_1_1CErrorDetails.html">CErrorDetails</a> *         pError = &amp;m_Send.ErrorDetails;
00471 
00472         pError-&gt;<a class="code" href="classLLRP_1_1CErrorDetails.html#a1">clear</a>();
00473         pError-&gt;<a class="code" href="classLLRP_1_1CErrorDetails.html#a4">resultCodeAndWhatStr</a>(<a class="code" href="namespaceLLRP.html#a333a261">RC_MissingResponseType</a>,
00474             <span class="stringliteral">"send message has no response type"</span>);
00475         <span class="keywordflow">return</span> NULL;
00476     }
00477 
00478     <span class="comment">/*</span>
00479 <span class="comment">     * Send the request</span>
00480 <span class="comment">     */</span>
00481     lrc = <a class="code" href="classLLRP_1_1CConnection.html#a7">sendMessage</a>(pSendMessage);
00482     <span class="keywordflow">if</span>(<a class="code" href="namespaceLLRP.html#a333a251">RC_OK</a> != lrc)
00483     {
00484         <span class="keywordflow">return</span> NULL;
00485     }
00486 
00487     <span class="comment">/*</span>
00488 <span class="comment">     * Receive the response subject to timeout</span>
00489 <span class="comment">     */</span>
00490     pResponseMessage = <a class="code" href="classLLRP_1_1CConnection.html#a10">recvResponse</a>(nMaxMS,
00491                             pResponseType, pSendMessage-&gt;<a class="code" href="classLLRP_1_1CMessage.html#a2">getMessageID</a>());
00492 
00493     <span class="comment">/*</span>
00494 <span class="comment">     * Whatever recvResponse() returned is the result.</span>
00495 <span class="comment">     */</span>
00496     <span class="keywordflow">return</span> pResponseMessage;
00497 }
00498 
00499 
00514 <span class="keyword">const</span> <a class="code" href="classLLRP_1_1CErrorDetails.html">CErrorDetails</a> *
<a name="l00515"></a><a class="code" href="classLLRP_1_1CConnection.html#a6">00515</a> CConnection::getTransactError (<span class="keywordtype">void</span>)
00516 {
00517     <span class="keyword">const</span> <a class="code" href="classLLRP_1_1CErrorDetails.html">CErrorDetails</a> *       pError;
00518 
00519     pError = <a class="code" href="classLLRP_1_1CConnection.html#a8">getSendError</a>();
00520     <span class="keywordflow">if</span>(<a class="code" href="namespaceLLRP.html#a333a251">RC_OK</a> == pError-&gt;<a class="code" href="classLLRP_1_1CErrorDetails.html#o0">m_eResultCode</a>)
00521     {
00522         pError = <a class="code" href="classLLRP_1_1CConnection.html#a11">getRecvError</a>();
00523     }
00524 
00525     <span class="keywordflow">return</span> pError;
00526 }
00527 
00528 
00544 <a class="code" href="namespaceLLRP.html#a333">EResultCode</a>
<a name="l00545"></a><a class="code" href="classLLRP_1_1CConnection.html#a7">00545</a> CConnection::sendMessage (
00546   <a class="code" href="classLLRP_1_1CMessage.html">CMessage</a> *                    pMessage)
00547 {
00548     <a class="code" href="classLLRP_1_1CErrorDetails.html">CErrorDetails</a> *             pError = &amp;m_Send.ErrorDetails;
00549     CFrameEncoder *             pEncoder;
00550 
00551     <span class="comment">/*</span>
00552 <span class="comment">     * Clear the error details in the send state.</span>
00553 <span class="comment">     */</span>
00554     pError-&gt;<a class="code" href="classLLRP_1_1CErrorDetails.html#a1">clear</a>();
00555 
00556     <span class="comment">/*</span>
00557 <span class="comment">     * Make sure the socket is open.</span>
00558 <span class="comment">     */</span>
00559     <span class="keywordflow">if</span>(NULL == m_pPlatformSocket)
00560     {
00561         pError-&gt;<a class="code" href="classLLRP_1_1CErrorDetails.html#a4">resultCodeAndWhatStr</a>(<a class="code" href="namespaceLLRP.html#a333a252">RC_MiscError</a>, <span class="stringliteral">"not connected"</span>);
00562         <span class="keywordflow">return</span> pError-&gt;<a class="code" href="classLLRP_1_1CErrorDetails.html#o0">m_eResultCode</a>;
00563     }
00564 
00565     <span class="comment">/*</span>
00566 <span class="comment">     * Construct a frame encoder. It needs to know the buffer</span>
00567 <span class="comment">     * base and maximum size.</span>
00568 <span class="comment">     */</span>
00569     pEncoder = <span class="keyword">new</span> CFrameEncoder(m_Send.pBuffer, m_nBufferSize);
00570 
00571     <span class="comment">/*</span>
00572 <span class="comment">     * Check that the encoder actually got created.</span>
00573 <span class="comment">     */</span>
00574     <span class="keywordflow">if</span>(NULL == pEncoder)
00575     {
00576         pError-&gt;<a class="code" href="classLLRP_1_1CErrorDetails.html#a4">resultCodeAndWhatStr</a>(<a class="code" href="namespaceLLRP.html#a333a252">RC_MiscError</a>,
00577                 <span class="stringliteral">"encoder constructor failed"</span>);
00578         <span class="keywordflow">return</span> pError-&gt;<a class="code" href="classLLRP_1_1CErrorDetails.html#o0">m_eResultCode</a>;
00579     }
00580 
00581     <span class="comment">/*</span>
00582 <span class="comment">     * Encode the message. Return value is ignored.</span>
00583 <span class="comment">     * We check the encoder's ErrorDetails for results.</span>
00584 <span class="comment">     */</span>
00585     pEncoder-&gt;encodeElement(pMessage);
00586 
00587     <span class="comment">/*</span>
00588 <span class="comment">     * Regardless of what happened capture the error details</span>
00589 <span class="comment">     * and the number of bytes placed in the buffer.</span>
00590 <span class="comment">     */</span>
00591     m_Send.ErrorDetails = pEncoder-&gt;m_ErrorDetails;
00592     m_Send.nBuffer = pEncoder-&gt;getLength();
00593 
00594     <span class="comment">/*</span>
00595 <span class="comment">     * Bye bye li'l encoder.</span>
00596 <span class="comment">     */</span>
00597     <span class="keyword">delete</span> pEncoder;
00598 
00599     <span class="comment">/*</span>
00600 <span class="comment">     * If the encoding appears complete write the frame</span>
00601 <span class="comment">     * to the connection. NB: this is not ready for</span>
00602 <span class="comment">     * non-blocking I/O (EWOULDBLOCK).</span>
00603 <span class="comment">     */</span>
00604     <span class="keywordflow">if</span>(<a class="code" href="namespaceLLRP.html#a333a251">RC_OK</a> == pError-&gt;<a class="code" href="classLLRP_1_1CErrorDetails.html#o0">m_eResultCode</a>)
00605     {
00606         <span class="keywordtype">int</span>             rc;
00607 
00608         rc = send(m_pPlatformSocket-&gt;m_sock, (<span class="keywordtype">char</span>*)m_Send.pBuffer,
00609             m_Send.nBuffer, 0);
00610         <span class="keywordflow">if</span>(rc != (int)m_Send.nBuffer)
00611         {
00612             <span class="comment">/* Yikes! */</span>
00613             pError-&gt;<a class="code" href="classLLRP_1_1CErrorDetails.html#a4">resultCodeAndWhatStr</a>(<a class="code" href="namespaceLLRP.html#a333a254">RC_SendIOError</a>, <span class="stringliteral">"send IO error"</span>);
00614         }
00615     }
00616 
00617     <span class="comment">/*</span>
00618 <span class="comment">     * Done.</span>
00619 <span class="comment">     */</span>
00620     <span class="keywordflow">return</span> pError-&gt;<a class="code" href="classLLRP_1_1CErrorDetails.html#o0">m_eResultCode</a>;
00621 }
00622 
00623 
00633 <span class="keyword">const</span> <a class="code" href="classLLRP_1_1CErrorDetails.html">CErrorDetails</a> *
<a name="l00634"></a><a class="code" href="classLLRP_1_1CConnection.html#a8">00634</a> CConnection::getSendError (<span class="keywordtype">void</span>)
00635 {
00636     <span class="keywordflow">return</span> &amp;m_Send.ErrorDetails;
00637 }
00638 
00639 
00660 <a class="code" href="classLLRP_1_1CMessage.html">CMessage</a> *
<a name="l00661"></a><a class="code" href="classLLRP_1_1CConnection.html#a9">00661</a> CConnection::recvMessage (
00662   <span class="keywordtype">int</span>                           nMaxMS)
00663 {
00664     time_t                      timeLimit = calculateTimeLimit(nMaxMS);
00665     <a class="code" href="namespaceLLRP.html#a333">EResultCode</a>                 lrc;
00666     <a class="code" href="classLLRP_1_1CMessage.html">CMessage</a> *                  pMessage;
00667 
00668     <span class="comment">/*</span>
00669 <span class="comment">     * Make sure the socket is open.</span>
00670 <span class="comment">     */</span>
00671     <span class="keywordflow">if</span>(NULL == m_pPlatformSocket)
00672     {
00673         <a class="code" href="classLLRP_1_1CErrorDetails.html">CErrorDetails</a> *         pError = &amp;m_Recv.ErrorDetails;
00674 
00675         pError-&gt;<a class="code" href="classLLRP_1_1CErrorDetails.html#a4">resultCodeAndWhatStr</a>(<a class="code" href="namespaceLLRP.html#a333a252">RC_MiscError</a>, <span class="stringliteral">"not connected"</span>);
00676         <span class="keywordflow">return</span> NULL;
00677     }
00678 
00679     <span class="comment">/*</span>
00680 <span class="comment">     * Loop until victory or some sort of exception happens</span>
00681 <span class="comment">     */</span>
00682     <span class="keywordflow">for</span>(;;)
00683     {
00684         <span class="comment">/*</span>
00685 <span class="comment">         * Check the input queue to see if there is already</span>
00686 <span class="comment">         * a message pending.</span>
00687 <span class="comment">         */</span>
00688         <span class="keywordflow">if</span>(!m_listInputQueue.empty())
00689         {
00690             pMessage = m_listInputQueue.front();
00691             m_listInputQueue.pop_front();
00692             <span class="keywordflow">return</span> pMessage;
00693         }
00694 
00695         <span class="comment">/*</span>
00696 <span class="comment">         * No message available. Advance the receiver state</span>
00697 <span class="comment">         * and see if a message is produced.</span>
00698 <span class="comment">         */</span>
00699         lrc = recvAdvance(nMaxMS, timeLimit);
00700         <span class="keywordflow">if</span>(lrc != RC_OK)
00701         {
00702             <span class="keywordflow">return</span> NULL;
00703         }
00704     }
00705 }
00706 
00707 
00718 <span class="keyword">const</span> <a class="code" href="classLLRP_1_1CErrorDetails.html">CErrorDetails</a> *
<a name="l00719"></a><a class="code" href="classLLRP_1_1CConnection.html#a11">00719</a> CConnection::getRecvError (<span class="keywordtype">void</span>)
00720 {
00721     <span class="keywordflow">return</span> &amp;m_Recv.ErrorDetails;
00722 }
00723 
00724 
00771 <a class="code" href="classLLRP_1_1CMessage.html">CMessage</a> *
<a name="l00772"></a><a class="code" href="classLLRP_1_1CConnection.html#a10">00772</a> CConnection::recvResponse (
00773   <span class="keywordtype">int</span>                           nMaxMS,
00774   <span class="keyword">const</span> <a class="code" href="classLLRP_1_1CTypeDescriptor.html">CTypeDescriptor</a> *       pResponseType,
00775   llrp_u32_t                    ResponseMessageID)
00776 {
00777     time_t                      timeLimit = calculateTimeLimit(nMaxMS);
00778     <span class="keyword">const</span> <a class="code" href="classLLRP_1_1CTypeDescriptor.html">CTypeDescriptor</a> *     pErrorMsgType;
00779     <a class="code" href="namespaceLLRP.html#a333">EResultCode</a>                 lrc;
00780     <a class="code" href="classLLRP_1_1CMessage.html">CMessage</a> *                  pMessage;
00781 
00782     <span class="comment">/*</span>
00783 <span class="comment">     * Make sure the socket is open.</span>
00784 <span class="comment">     */</span>
00785     <span class="keywordflow">if</span>(NULL == m_pPlatformSocket)
00786     {
00787         <a class="code" href="classLLRP_1_1CErrorDetails.html">CErrorDetails</a> *         pError = &amp;m_Recv.ErrorDetails;
00788 
00789         pError-&gt;<a class="code" href="classLLRP_1_1CErrorDetails.html#a4">resultCodeAndWhatStr</a>(<a class="code" href="namespaceLLRP.html#a333a252">RC_MiscError</a>, <span class="stringliteral">"not connected"</span>);
00790         <span class="keywordflow">return</span> NULL;
00791     }
00792 
00793     <span class="comment">/*</span>
00794 <span class="comment">     * Look up the ERROR_MESSAGE type descriptor now.</span>
00795 <span class="comment">     */</span>
00796     pErrorMsgType = m_pTypeRegistry-&gt;<a class="code" href="classLLRP_1_1CTypeRegistry.html#a3">lookupMessage</a>(100u);
00797 
00798     <span class="comment">/*</span>
00799 <span class="comment">     * Loop until victory or some sort of exception happens</span>
00800 <span class="comment">     */</span>
00801     <span class="keywordflow">for</span>(;;)
00802     {
00803         <span class="comment">/*</span>
00804 <span class="comment">         * Check the input queue to see if the sought</span>
00805 <span class="comment">         * message is present.</span>
00806 <span class="comment">         */</span>
00807         <span class="keywordflow">for</span> (
00808             std::list&lt;CMessage *&gt;::iterator msg = m_listInputQueue.begin();
00809             msg != m_listInputQueue.end();
00810             msg++)
00811         {
00812             pMessage = *msg;
00813 
00814             <span class="comment">/*</span>
00815 <span class="comment">             * Are we looking for a particular message type?</span>
00816 <span class="comment">             */</span>
00817             <span class="keywordflow">if</span>(NULL != pResponseType)
00818             {
00819                 <span class="comment">/*</span>
00820 <span class="comment">                 * See if it is the sought response type or</span>
00821 <span class="comment">                 * an ERROR_MESSAGE.</span>
00822 <span class="comment">                 */</span>
00823                 <span class="keywordflow">if</span>(pMessage-&gt;<a class="code" href="classLLRP_1_1CElement.html#o0">m_pType</a> != pResponseType &amp;&amp;
00824                    pMessage-&gt;<a class="code" href="classLLRP_1_1CElement.html#o0">m_pType</a> != pErrorMsgType)
00825                 {
00826                     <span class="comment">/* Type does not match. Keep looking. */</span>
00827                     <span class="keywordflow">continue</span>;
00828                 }
00829             }
00830 
00831             <span class="comment">/*</span>
00832 <span class="comment">             * Are we looking for a particular message ID?</span>
00833 <span class="comment">             */</span>
00834             <span class="keywordflow">if</span>(0 != ResponseMessageID)
00835             {
00836                 <span class="keywordflow">if</span>(pMessage-&gt;<a class="code" href="classLLRP_1_1CMessage.html#a2">getMessageID</a>() != ResponseMessageID)
00837                 {
00838                     <span class="comment">/* Message ID does not match. Keep looking. */</span>
00839                     <span class="keywordflow">continue</span>;
00840                 }
00841             }
00842 
00843             <span class="comment">/*</span>
00844 <span class="comment">             * Found it. Unlink it from the queue and return it.</span>
00845 <span class="comment">             */</span>
00846             m_listInputQueue.remove(pMessage);
00847             <span class="keywordflow">return</span> pMessage;
00848         }
00849 
00850         <span class="comment">/*</span>
00851 <span class="comment">         * Sought message is not in the queue. Advance the</span>
00852 <span class="comment">         * receiver state and see if the message is produced.</span>
00853 <span class="comment">         */</span>
00854         lrc = recvAdvance(nMaxMS, timeLimit);
00855         <span class="keywordflow">if</span>(lrc != RC_OK)
00856         {
00857             <span class="keywordflow">return</span> NULL;
00858         }
00859 
00860         <span class="comment">/*</span>
00861 <span class="comment">         * Loop to the top and try again.</span>
00862 <span class="comment">         */</span>
00863     }
00864 }
00865 
00866 
00901 <a class="code" href="namespaceLLRP.html#a333">EResultCode</a>
00902 CConnection::recvAdvance (
00903   <span class="keywordtype">int</span>                           nMaxMS,
00904   time_t                        timeLimit)
00905 {
00906     <a class="code" href="classLLRP_1_1CErrorDetails.html">CErrorDetails</a> *             pError = &amp;m_Recv.ErrorDetails;
00907 
00908     <span class="comment">/*</span>
00909 <span class="comment">     * Clear the error details in the receiver state.</span>
00910 <span class="comment">     */</span>
00911     pError-&gt;<a class="code" href="classLLRP_1_1CErrorDetails.html#a1">clear</a>();
00912 
00913     <span class="comment">/*</span>
00914 <span class="comment">     * Loop until victory or some sort of exception happens</span>
00915 <span class="comment">     */</span>
00916     <span class="keywordflow">for</span>(;;)
00917     {
00918         <span class="keywordtype">int</span>                     rc;
00919 
00920         <span class="comment">/*</span>
00921 <span class="comment">         * Note that the frame is in progress.</span>
00922 <span class="comment">         * Existing buffer content, if any, is deemed</span>
00923 <span class="comment">         * invalid or incomplete.</span>
00924 <span class="comment">         */</span>
00925         m_Recv.bFrameValid = FALSE;
00926 
00927         <span class="comment">/*</span>
00928 <span class="comment">         * Check to see if we have a frame in the buffer.</span>
00929 <span class="comment">         * If not, how many more bytes do we need?</span>
00930 <span class="comment">         *</span>
00931 <span class="comment">         * LLRP_FrameExtract() status</span>
00932 <span class="comment">         *</span>
00933 <span class="comment">         * FRAME_ERROR          Impossible situation, like message</span>
00934 <span class="comment">         *                      length too small or the like.</span>
00935 <span class="comment">         *                      Recovery in this situation is</span>
00936 <span class="comment">         *                      unlikely and probably the app</span>
00937 <span class="comment">         *                      should drop the connection.</span>
00938 <span class="comment">         *</span>
00939 <span class="comment">         * FRAME_READY          Frame is complete. Details are</span>
00940 <span class="comment">         *                      available for pre-decode decisions.</span>
00941 <span class="comment">         *</span>
00942 <span class="comment">         * FRAME_NEED_MORE      Need more input bytes to finish the frame.</span>
00943 <span class="comment">         *                      The m_nBytesNeeded field is how many more.</span>
00944 <span class="comment">         */</span>
00945         m_Recv.FrameExtract = CFrameExtract(m_Recv.pBuffer, m_Recv.nBuffer);
00946 
00947         <span class="comment">/*</span>
00948 <span class="comment">         * Framing error?</span>
00949 <span class="comment">         */</span>
00950         <span class="keywordflow">if</span>(CFrameExtract::FRAME_ERROR == m_Recv.FrameExtract.m_eStatus)
00951         {
00952             pError-&gt;<a class="code" href="classLLRP_1_1CErrorDetails.html#a4">resultCodeAndWhatStr</a>(RC_RecvFramingError,
00953                     <span class="stringliteral">"framing error in message stream"</span>);
00954             <span class="keywordflow">break</span>;
00955         }
00956 
00957         <span class="comment">/*</span>
00958 <span class="comment">         * Need more bytes? extractRc&gt;0 means we do and extractRc is the</span>
00959 <span class="comment">         * number of bytes immediately required.</span>
00960 <span class="comment">         */</span>
00961         <span class="keywordflow">if</span>(CFrameExtract::NEED_MORE == m_Recv.FrameExtract.m_eStatus)
00962         {
00963             <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>        nRead = m_Recv.FrameExtract.m_nBytesNeeded;
00964             <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *     pBufPos = &amp;m_Recv.pBuffer[m_Recv.nBuffer];
00965 
00966             <span class="comment">/*</span>
00967 <span class="comment">             * Before we do anything that might block,</span>
00968 <span class="comment">             * check to see if the time limit is exceeded.</span>
00969 <span class="comment">             */</span>
00970             <span class="keywordflow">if</span>(0 != timeLimit)
00971             {
00972                 <span class="keywordflow">if</span>(time(NULL) &gt; timeLimit)
00973                 {
00974                     <span class="comment">/* Timeout */</span>
00975                     pError-&gt;<a class="code" href="classLLRP_1_1CErrorDetails.html#a4">resultCodeAndWhatStr</a>(RC_RecvTimeout,
00976                             <span class="stringliteral">"timeout"</span>);
00977                     <span class="keywordflow">break</span>;
00978                 }
00979             }
00980 
00981             <span class="comment">/*</span>
00982 <span class="comment">             * The frame extractor needs more data, make sure the</span>
00983 <span class="comment">             * frame size fits in the receive buffer.</span>
00984 <span class="comment">             */</span>
00985             <span class="keywordflow">if</span>(m_Recv.nBuffer + nRead &gt; m_nBufferSize)
00986             {
00987                 pError-&gt;<a class="code" href="classLLRP_1_1CErrorDetails.html#a4">resultCodeAndWhatStr</a>(RC_RecvBufferOverflow,
00988                         <span class="stringliteral">"buffer overflow"</span>);
00989                 <span class="keywordflow">break</span>;
00990             }
00991 
00992             <span class="comment">/*</span>
00993 <span class="comment">             * If this is not a block indefinitely request use poll()</span>
00994 <span class="comment">             * to see if there is data in time.</span>
00995 <span class="comment">             */</span>
00996             <span class="keywordflow">if</span>(nMaxMS &gt;= 0)
00997             {
00998 <span class="preprocessor">#ifdef linux</span>
00999 <span class="preprocessor"></span>                <span class="keyword">struct </span>pollfd   pfd;
01000 
01001                 pfd.fd = m_pPlatformSocket-&gt;m_sock;
01002                 pfd.events = POLLIN;
01003                 pfd.revents = 0;
01004 
01005                 rc = poll(&amp;pfd, 1, nMaxMS);
01006 <span class="preprocessor">#endif </span><span class="comment">/* linux */</span>
01007 <span class="preprocessor">#ifdef WIN32</span>
01008 <span class="preprocessor"></span>                fd_set          readfds;
01009                 <span class="keyword">struct </span>timeval  timeout;
01010 
01011                 timeout.tv_sec = nMaxMS / 1000u;
01012                 timeout.tv_usec = (nMaxMS % 1000u) * 1000u;
01013 
01014                 FD_ZERO(&amp;readfds);
01015                 FD_SET(m_pPlatformSocket-&gt;m_sock, &amp;readfds);
01016                 rc = select(-1, &amp;readfds, NULL, NULL, &amp;timeout);
01017 
01018 <span class="preprocessor">#endif </span><span class="comment">/* WIN32 */</span>
01019                 <span class="keywordflow">if</span>(0 &gt; rc)
01020                 {
01021                     <span class="comment">/* Error */</span>
01022                     pError-&gt;<a class="code" href="classLLRP_1_1CErrorDetails.html#a4">resultCodeAndWhatStr</a>(RC_RecvIOError,
01023                             <span class="stringliteral">"poll failed"</span>);
01024                     <span class="keywordflow">break</span>;
01025                 }
01026                 <span class="keywordflow">if</span>(0 == rc)
01027                 {
01028                     <span class="comment">/* Timeout */</span>
01029                     pError-&gt;<a class="code" href="classLLRP_1_1CErrorDetails.html#a4">resultCodeAndWhatStr</a>(RC_RecvTimeout,
01030                             <span class="stringliteral">"timeout"</span>);
01031                     <span class="keywordflow">break</span>;
01032                 }
01033             }
01034 
01035             <span class="comment">/*</span>
01036 <span class="comment">             * Read (recv) some number of bytes from the socket.</span>
01037 <span class="comment">             */</span>
01038             rc = recv(m_pPlatformSocket-&gt;m_sock, (<span class="keywordtype">char</span>*)pBufPos, nRead, 0);
01039             <span class="keywordflow">if</span>(0 &gt; rc)
01040             {
01041                 <span class="comment">/*</span>
01042 <span class="comment">                 * Error. Note this could be EWOULDBLOCK if the</span>
01043 <span class="comment">                 * file descriptor is using non-blocking I/O.</span>
01044 <span class="comment">                 * So we return the error but do not tear-up</span>
01045 <span class="comment">                 * the receiver state.</span>
01046 <span class="comment">                 */</span>
01047                 pError-&gt;<a class="code" href="classLLRP_1_1CErrorDetails.html#a4">resultCodeAndWhatStr</a>(RC_RecvIOError,
01048                         <span class="stringliteral">"recv IO error"</span>);
01049                 <span class="keywordflow">break</span>;
01050             }
01051 
01052             <span class="keywordflow">if</span>(0 == rc)
01053             {
01054                 <span class="comment">/* EOF */</span>
01055                 pError-&gt;<a class="code" href="classLLRP_1_1CErrorDetails.html#a4">resultCodeAndWhatStr</a>(RC_RecvEOF,
01056                         <span class="stringliteral">"recv end-of-file"</span>);
01057                 <span class="keywordflow">break</span>;
01058             }
01059 
01060             <span class="comment">/*</span>
01061 <span class="comment">             * When we get here, rc&gt;0 meaning some bytes were read.</span>
01062 <span class="comment">             * Update the number of bytes present.</span>
01063 <span class="comment">             * Then loop to the top and retry the FrameExtract().</span>
01064 <span class="comment">             */</span>
01065             m_Recv.nBuffer += rc;
01066 
01067             <span class="keywordflow">continue</span>;
01068         }
01069 
01070         <span class="comment">/*</span>
01071 <span class="comment">         * Is the frame ready?</span>
01072 <span class="comment">         * If a valid frame is present, decode and enqueue it.</span>
01073 <span class="comment">         */</span>
01074         <span class="keywordflow">if</span>(CFrameExtract::READY == m_Recv.FrameExtract.m_eStatus)
01075         {
01076             <span class="comment">/*</span>
01077 <span class="comment">             * Frame appears complete. Time to try to decode it.</span>
01078 <span class="comment">             */</span>
01079             CFrameDecoder *     pDecoder;
01080             CMessage *          pMessage;
01081 
01082             <span class="comment">/*</span>
01083 <span class="comment">             * Construct a new frame decoder. It needs the registry</span>
01084 <span class="comment">             * to facilitate decoding.</span>
01085 <span class="comment">             */</span>
01086             pDecoder = <span class="keyword">new</span> CFrameDecoder(m_pTypeRegistry,
01087                     m_Recv.pBuffer, m_Recv.nBuffer);
01088 
01089             <span class="comment">/*</span>
01090 <span class="comment">             * Make sure we really got one. If not, weird problem.</span>
01091 <span class="comment">             */</span>
01092             <span class="keywordflow">if</span>(pDecoder == NULL)
01093             {
01094                 <span class="comment">/* All we can do is discard the frame. */</span>
01095                 m_Recv.nBuffer = 0;
01096                 m_Recv.bFrameValid = FALSE;
01097                 pError-&gt;<a class="code" href="classLLRP_1_1CErrorDetails.html#a4">resultCodeAndWhatStr</a>(RC_MiscError,
01098                         <span class="stringliteral">"decoder constructor failed"</span>);
01099                 <span class="keywordflow">break</span>;
01100             }
01101 
01102             <span class="comment">/*</span>
01103 <span class="comment">             * Now ask the nice, brand new decoder to decode the frame.</span>
01104 <span class="comment">             * It returns NULL for some kind of error.</span>
01105 <span class="comment">             */</span>
01106             pMessage = pDecoder-&gt;decodeMessage();
01107 
01108             <span class="comment">/*</span>
01109 <span class="comment">             * Always capture the error details even when it works.</span>
01110 <span class="comment">             * Whatever happened, we are done with the decoder.</span>
01111 <span class="comment">             */</span>
01112             m_Recv.ErrorDetails = pDecoder-&gt;m_ErrorDetails;
01113 
01114             <span class="comment">/*</span>
01115 <span class="comment">             * Bye bye and thank you li'l decoder.</span>
01116 <span class="comment">             */</span>
01117             <span class="keyword">delete</span> pDecoder;
01118 
01119             <span class="comment">/*</span>
01120 <span class="comment">             * If NULL there was an error. Clean up the</span>
01121 <span class="comment">             * receive state. Return the error.</span>
01122 <span class="comment">             */</span>
01123             <span class="keywordflow">if</span>(NULL == pMessage)
01124             {
01125                 <span class="comment">/*</span>
01126 <span class="comment">                 * Make sure the return is not RC_OK</span>
01127 <span class="comment">                 */</span>
01128                 <span class="keywordflow">if</span>(<a class="code" href="namespaceLLRP.html#a333a251">RC_OK</a> == pError-&gt;<a class="code" href="classLLRP_1_1CErrorDetails.html#o0">m_eResultCode</a>)
01129                 {
01130                     pError-&gt;<a class="code" href="classLLRP_1_1CErrorDetails.html#a4">resultCodeAndWhatStr</a>(RC_MiscError,
01131                             <span class="stringliteral">"NULL message but no error"</span>);
01132                 }
01133 
01134                 <span class="comment">/*</span>
01135 <span class="comment">                 * All we can do is discard the frame.</span>
01136 <span class="comment">                 */</span>
01137                 m_Recv.nBuffer = 0;
01138                 m_Recv.bFrameValid = FALSE;
01139 
01140                 <span class="keywordflow">break</span>;
01141             }
01142 
01143             <span class="comment">/*</span>
01144 <span class="comment">             * Yay! It worked. Enqueue the message.</span>
01145 <span class="comment">             */</span>
01146             m_listInputQueue.push_back(pMessage);
01147 
01148             <span class="comment">/*</span>
01149 <span class="comment">             * Note that the frame is valid. Consult</span>
01150 <span class="comment">             * Recv.FrameExtract.m_MessageLength.</span>
01151 <span class="comment">             * Clear the buffer count to be ready for next time.</span>
01152 <span class="comment">             */</span>
01153             m_Recv.bFrameValid = TRUE;
01154             m_Recv.nBuffer = 0;
01155 
01156             <span class="keywordflow">break</span>;
01157         }
01158 
01159         <span class="comment">/*</span>
01160 <span class="comment">         * If we get here there was an FrameExtract status</span>
01161 <span class="comment">         * we didn't expect.</span>
01162 <span class="comment">         */</span>
01163 
01164         <span class="comment">/*NOTREACHED*/</span>
01165         assert(0);
01166     }
01167 
01168     <span class="keywordflow">return</span> pError-&gt;<a class="code" href="classLLRP_1_1CErrorDetails.html#o0">m_eResultCode</a>;
01169 }
01170 
01171 
01194 time_t
01195 CConnection::calculateTimeLimit (
01196   <span class="keywordtype">int</span>                           nMaxMS)
01197 {
01198     <span class="keywordflow">if</span>(0 == nMaxMS)
01199     {
01200         <span class="comment">/* When just peeking, try for at most one second */</span>
01201         <span class="keywordflow">return</span> time(NULL) + 1;
01202     }
01203     <span class="keywordflow">else</span> <span class="keywordflow">if</span>(0 &lt; nMaxMS)
01204     {
01205         <span class="comment">/*</span>
01206 <span class="comment">         * Try for a at most a certain period of time.</span>
01207 <span class="comment">         *</span>
01208 <span class="comment">         * timeLimit = now + ceil(nMaxMS/1000) + 1</span>
01209 <span class="comment">         *</span>
01210 <span class="comment">         * The last +1 compensates for not knowing</span>
01211 <span class="comment">         * when the next time() tick will happen.</span>
01212 <span class="comment">         *</span>
01213 <span class="comment">         * For example, if now is SECONDS.999 seconds</span>
01214 <span class="comment">         * the next tick will happen in 1 millisecond.</span>
01215 <span class="comment">         * Suppose nMaxMS is 500ms (1/2 second).</span>
01216 <span class="comment">         * Even rounding 500ms up to 1 second, the</span>
01217 <span class="comment">         * time limit without the +1 would be</span>
01218 <span class="comment">         * SECONDS+1 -- 1ms away. That's too soon.</span>
01219 <span class="comment">         *</span>
01220 <span class="comment">         * The extra +1 makes the maximum timeout</span>
01221 <span class="comment">         * longer than required. But the timeLimit</span>
01222 <span class="comment">         * is a safeguard anyway and usually the</span>
01223 <span class="comment">         * timeout will occur when the user wants.</span>
01224 <span class="comment">         */</span>
01225         <span class="keywordflow">return</span> time(NULL) + ((nMaxMS + 1999u) / 1000u);
01226     }
01227     <span class="keywordflow">else</span>
01228     {
01229         <span class="comment">/* Try indefinitely */</span>
01230         <span class="keywordflow">return</span> 0;
01231     }
01232 }
01233 
01234 }; <span class="comment">/* namespace LLRP */</span>
01235 
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Wed Feb 24 09:16:21 2010 for LTKCPP-- LLRP Toolkit C Plus Plus Library by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.3.9.1 </small></address>
</body>
</html>
